

<!DOCTYPE html>
<html lang="zh-cn" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="xrt">
  <meta name="keywords" content="">
  <meta name="description" content="Java对象和多态 （面向对象）面向对象基础面向对象程序设计(Object Oriented Programming) 对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方">
<meta property="og:type" content="article">
<meta property="og:title" content="Java对象和多态 （面向对象）">
<meta property="og:url" content="http://blurryf.github.io/2022/02/21/1.html/index.html">
<meta property="og:site_name" content="XRTing&#39;s Blog">
<meta property="og:description" content="Java对象和多态 （面向对象）面向对象基础面向对象程序设计(Object Oriented Programming) 对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&refer=http%3A%2F%2Fimgs.itxueyuan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632192902&t=7a6d67fc01d0e3ea7816adf951c49605">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2FDD%2F01%2Fo4YBAGASjymAK8QIAADiOdWkSVA342.jpg&refer=http%3A%2F%2Ffile.elecfans.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632204192&t=52381354d190d09899776f9bb868ef3e">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg1.jjhgame.com%2Fstatic_data%2Fnewshelp%2F113_5c08e82d2ac8b.jpg&refer=http%3A%2F%2Fimg1.jjhgame.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632208529&t=f3fb9be4dce91c6364f5ec4f9faafc94">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png">
<meta property="article:published_time" content="2022-02-21T08:28:34.941Z">
<meta property="article:modified_time" content="2022-02-23T09:11:59.515Z">
<meta property="article:author" content="xrt">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&refer=http%3A%2F%2Fimgs.itxueyuan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632192902&t=7a6d67fc01d0e3ea7816adf951c49605">
  
  <title>Java对象和多态 （面向对象） - XRTing&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blurryf.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>XRTing</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java对象和多态 （面向对象）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-21 16:28" pubdate>
        2022年2月21日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      22k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      70 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java对象和多态 （面向对象）</h1>
            
            <div class="markdown-body">
              <h1 id="Java对象和多态-（面向对象）"><a href="#Java对象和多态-（面向对象）" class="headerlink" title="Java对象和多态 （面向对象）"></a>Java对象和多态 （面向对象）</h1><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><p>面向对象程序设计(Object Oriented Programming)</p>
<p>对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String str = sc.nextLine();<br>System.out.println(<span class="hljs-string"><code class="language-hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String str = sc.nextLine();<br>System.out.println(<span class="hljs-string">"你输入了："</span>+str);<br>sc.close();<br></code></pre></td></tr></table></figure>

<p>所有的对象，都需要通过<code>new</code>关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！</p>
<p>不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论）</p>
<p>对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！</p>
<hr>
<h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a>类的基本结构</h2><p>为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过<code>.</code>来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    test.name = <span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    test.name = <span class="hljs-string">"奥利给"</span>;<br>    System.out.println(test.name);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>成员变量默认带有初始值，也可以自己定义初始值。</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>我们之前的学习中接触过方法(Method)吗？主方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//Body</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p>
<h4 id="方法的定义和使用"><a href="#方法的定义和使用" class="headerlink" title="方法的定义和使用"></a>方法的定义和使用</h4><p>在类中，我们可以定义自己的方法，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">[返回值类型] 方法名称([参数])&#123;<br>  <span class="hljs-comment">//方法体</span><br>  <span class="hljs-keyword"><code class="language-hljs java">[返回值类型] 方法名称([参数])&#123;<br>  <span class="hljs-comment">//方法体</span><br>  <span class="hljs-keyword">return</span> 结果;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值</li>
<li>方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！</li>
<li>参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法</li>
<li>方法体：方法具体要干的事情</li>
<li>结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return）</li>
</ul>
<p>非void方法中，<code>return</code>关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//缺少retrun语句！</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//缺少retrun语句！</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>return</code>也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>       <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//在循环内返回了！和break区别？</span><br>   &#125;<br>   System.out.println(<span class="hljs-string">&quot;淦&quot;</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>       <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//在循环内返回了！和break区别？</span><br>   &#125;<br>   System.out.println(<span class="hljs-string">&quot;淦&quot;</span>);   <span class="hljs-comment">//还会到这里吗？</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  	<span class="hljs-keyword">new</span> Test().swap(a, b);<br>  	System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string">&quot;, b=&quot;</span>+b);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br> 	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;  <span class="hljs-comment">//传递的仅仅是值而已！</span><br>  		<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  	<span class="hljs-keyword">new</span> Test().swap(a, b);<br>  	System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string">&quot;, b=&quot;</span>+b);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br> 	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;  <span class="hljs-comment">//传递的仅仅是值而已！</span><br>  		<span class="hljs-keyword">int</span> temp = a;<br>  		a = b;<br> 			b = temp;<br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br> 	String name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br> 	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(B b)</span></span>&#123;  <span class="hljs-comment">//传递的是对象的引用，而不是值</span><br>    System.out.println(b.name);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  	B b = <span class="hljs-keyword">new</span> B();<br>  	b.name = <span class="hljs-string">&quot;lbw&quot;</span>;<br>  	<span class="hljs-keyword">new</span> A().test(b);<br>  	System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br> 	String name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br> 	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(B b)</span></span>&#123;  <span class="hljs-comment">//传递的是对象的引用，而不是值</span><br>    System.out.println(b.name);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  	B b = <span class="hljs-keyword">new</span> B();<br>  	b.name = <span class="hljs-string">&quot;lbw&quot;</span>;<br>  	<span class="hljs-keyword">new</span> A().test(b);<br>  	System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string">", b="</span>+b);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法之间可以相互调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//xxxx</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//xxxx</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;<br>  a();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> a();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>成员方法和成员变量一样，是属于对象的，只能通过对象去调用！</p>
<hr>
<h3 id="对象设计练习"><a href="#对象设计练习" class="headerlink" title="对象设计练习"></a>对象设计练习</h3><ul>
<li>学生应该具有以下属性：名字、年龄</li>
<li>学生应该具有以下行为：学习、运动、说话</li>
</ul>
<hr>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//原本的方法</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，形参不同</span><br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，返回类型和形参都不同</span><br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//原本的方法</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，形参不同</span><br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，返回类型和形参都不同</span><br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//错误，仅返回值类型名称不同不能重载</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;   <span class="hljs-comment">//只有int支持，不灵活！</span><br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>&#123;  <span class="hljs-comment">//重写一个double类型的，就支持小数计算了</span><br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;   <span class="hljs-comment">//只有int支持，不灵活！</span><br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>&#123;  <span class="hljs-comment">//重写一个double类型的，就支持小数计算了</span><br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了int&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">short</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了short&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">long</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了long&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">char</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了char&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了double&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">float</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了float&quot;</span>);<br>    &#125;<br>  <br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        test.a(<span class="hljs-number">1</span>);   <span class="hljs-comment">//直接输入整数</span><br>        test.a(<span class="hljs-number">1.0</span>);  <span class="hljs-comment">//直接输入小数</span><br><br>        <span class="hljs-keyword">short</span> s = <span class="hljs-number">2</span>;<br>        test.a(s);  <span class="hljs-comment">//会对号入座吗？</span><br>        test.a(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了int&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">short</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了short&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">long</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了long&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">char</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了char&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了double&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">float</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了float&quot;</span>);<br>    &#125;<br>  <br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        test.a(<span class="hljs-number">1</span>);   <span class="hljs-comment">//直接输入整数</span><br>        test.a(<span class="hljs-number">1.0</span>);  <span class="hljs-comment">//直接输入小数</span><br><br>        <span class="hljs-keyword">short</span> s = <span class="hljs-number">2</span>;<br>        test.a(s);  <span class="hljs-comment">//会对号入座吗？</span><br>        test.a(<span class="hljs-number">1.0F</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//反编译结果</span><br><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//反编译结果</span><br><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反编译其实就是把我们编译好的class文件变回Java源代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Test test = <span class="hljs-keyword">new</span> Test();  <span class="hljs-comment">//实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的</span><br><span class="hljs-comment"><code class="language-hljs java">Test test = <span class="hljs-keyword">new</span> Test();  <span class="hljs-comment">//实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的</span><br><span class="hljs-comment">// new + 你想要使用的构造方法</span><br></code></pre></td></tr></table></figure>

<p>这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！</p>
<p>类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！</p>
<p>一般最常用的就是给成员属性赋初始值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    <br>    Student()&#123;<br>        name = <span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    <br>    Student()&#123;<br>        name = <span class="hljs-string">"伞兵一号"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student(String name)&#123;   <span class="hljs-comment">//形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！</span><br>        <span class="hljs-keyword">this</span>.name = name;  <span class="hljs-comment">//通过this指代当前的对象属性，this就代表当前对象</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student(String name)&#123;   <span class="hljs-comment">//形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！</span><br>        <span class="hljs-keyword">this</span>.name = name;  <span class="hljs-comment">//通过this指代当前的对象属性，this就代表当前对象</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//idea 右键快速生成！</span><br></code></pre></td></tr></table></figure>

<p>注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。</p>
<p>在我们定义了新的有参构造之后，默认的无参构造会被覆盖！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//反编译后依然只有我们定义的有参构造！</span><br></code></pre></td></tr></table></figure>

<p>如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student()&#123;<br><br>    &#125;<br><br>    Student(String name)&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student()&#123;<br><br>    &#125;<br><br>    Student(String name)&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>成员变量的初始化始终在构造方法执行之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String a = <span class="hljs-string">&quot;sadasa&quot;</span>;<br><br>    Student()&#123;<br>        System.out.println(a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String a = <span class="hljs-string">&quot;sadasa&quot;</span>;<br><br>    Student()&#123;<br>        System.out.println(a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><p>静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	Student s1 = <span class="hljs-keyword">new</span> Student();<br>	s1.a = <span class="hljs-number">10</span>;<br>	Student s2 = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	Student s1 = <span class="hljs-keyword">new</span> Student();<br>	s1.a = <span class="hljs-number">10</span>;<br>	Student s2 = <span class="hljs-keyword">new</span> Student();<br>	System.out.println(s2.a);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不推荐使用对象来调用，被标记为静态的内容，可以直接通过<code>类名.xxx</code>的形式访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   Student.a = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   Student.a = <span class="hljs-number">10</span>;<br>   System.out.println(Student.a);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="简述类加载机制"><a href="#简述类加载机制" class="headerlink" title="简述类加载机制"></a>简述类加载机制</h4><p>类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类：</p>
<ul>
<li>访问类的静态变量，或者为静态变量赋值</li>
<li>new 创建类的实例（隐式加载）</li>
<li>调用类的静态方法</li>
<li>子类初始化时</li>
<li>其他的情况会在讲到反射时介绍</li>
</ul>
<p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();  <span class="hljs-comment">//直接调用静态方法，只能调用静态方法</span><br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string">&quot;构造类对象&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//静态方法刚加载时就有了</span><br>        System.out.println(<span class="hljs-string">&quot;初始化变量a&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();  <span class="hljs-comment">//直接调用静态方法，只能调用静态方法</span><br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string">&quot;构造类对象&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//静态方法刚加载时就有了</span><br>        System.out.println(<span class="hljs-string">&quot;初始化变量a&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Student.a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0</p>
<h3 id="代码块和静态代码块"><a href="#代码块和静态代码块" class="headerlink" title="代码块和静态代码块"></a>代码块和静态代码块</h3><p>代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是代码块&quot;</span>);<br>    &#125;<br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是代码块&quot;</span>);<br>    &#125;<br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string">"我是构造方法"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        a = <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        a = <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Student.a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="String和StringBuilder类"><a href="#String和StringBuilder类" class="headerlink" title="String和StringBuilder类"></a>String和StringBuilder类</h3><p>字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例)</p>
<p>String的对象直接支持使用<code>+</code>或<code>+=</code>运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java">String a = <span class="hljs-string">&quot;dasdsa&quot;</span>, b = <span class="hljs-string"><code class="language-hljs java">String a = <span class="hljs-string">&quot;dasdsa&quot;</span>, b = <span class="hljs-string">"dasdasdsa"</span>;<br>String l = a+b;<br>System.out.println(l);<br></code></pre></td></tr></table></figure>

<p>大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">String result=<span class="hljs-string">&quot;String&quot;</span>+<span class="hljs-string">&quot;and&quot;</span>; <span class="hljs-comment"><code class="language-hljs java">String result=<span class="hljs-string">&quot;String&quot;</span>+<span class="hljs-string">&quot;and&quot;</span>; <span class="hljs-comment">//会被优化成一句！</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=str1+str2;<br><span class="hljs-comment"><code class="language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=str1+str2;<br><span class="hljs-comment">//变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=(<span class="hljs-keyword">new</span> StringBuilder(String.valueOf(str1))).append(str2).toString();<br><span class="hljs-comment"><code class="language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=(<span class="hljs-keyword">new</span> StringBuilder(String.valueOf(str1))).append(str2).toString();<br><span class="hljs-comment">//使用StringBuilder，会采用类似于第一种实现，显然会更快！</span><br></code></pre></td></tr></table></figure>

<p>StringBuilder也是一个类，但是它能够存储可变长度的字符串！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>builder<br>       .append(<span class="hljs-string">&quot;a&quot;</span>)<br>       .append(<span class="hljs-string">&quot;bc&quot;</span>)<br>       .append(<span class="hljs-string">&quot;d&quot;</span>);   <span class="hljs-comment"><code class="language-hljs java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>builder<br>       .append(<span class="hljs-string">&quot;a&quot;</span>)<br>       .append(<span class="hljs-string">&quot;bc&quot;</span>)<br>       .append(<span class="hljs-string">&quot;d&quot;</span>);   <span class="hljs-comment">//链式调用</span><br>String str = builder.toString();<br>System.out.println(str);<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="包和访问控制"><a href="#包和访问控制" class="headerlink" title="包和访问控制"></a>包和访问控制</h2><h3 id="包声明和导入"><a href="#包声明和导入" class="headerlink" title="包声明和导入"></a>包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。</p>
<p>一般包按照个人或是公司域名的规则倒过来写 <code>顶级域名.一级域名.二级域名</code> <code>com.java.xxxx</code></p>
<p>如果需要使用其他包里面的类，那么我们需要<code>import</code>（类似于C/C++中的include）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">import</span> com.test.Student;<br></code></pre></td></tr></table></figure>

<p>也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">import</span> com.test.*<br></code></pre></td></tr></table></figure>

<p>Java默认为我们导入了以下的包，不需要去声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">import</span> java.lang.*<br></code></pre></td></tr></table></figure>

<h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><p>静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.test.ui.Student.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.test.ui.Student.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态导入不会进行类的初始化！</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。</p>
<p>![image-20210819160939950](/Users/nagocoler/Library/Application Support/typora-user-images/image-20210819160939950.png)</p>
<p>权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//具有私有访问权限，只能类内部访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    System.out.println(s.a);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//具有私有访问权限，只能类内部访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    System.out.println(s.a);  <span class="hljs-comment">//还可以访问吗？</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// Student.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Student.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;   <span class="hljs-comment">//不能添加权限修饰符！只能是default</span><br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&refer=http%3A%2F%2Fimgs.itxueyuan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632192902&t=7a6d67fc01d0e3ea7816adf951c49605" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];  <span class="hljs-comment">//需要new关键字来创建！</span><br>String[] arr2 = <span class="hljs-keyword">new</span> String[<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];  <span class="hljs-comment">//需要new关键字来创建！</span><br>String[] arr2 = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure>

<p>数组本身也是类（编程不可见，C++写的），不是基本数据类型！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>System.out.println(arr.length);   <span class="hljs-comment">//数组有成员变量！</span><br>System.out.println(arr.toString());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>System.out.println(arr.length);   <span class="hljs-comment">//数组有成员变量！</span><br>System.out.println(arr.toString());   <span class="hljs-comment">//数组有成员方法！</span><br></code></pre></td></tr></table></figure>

<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[数组大小];<br>类型 变量名称n = <span class="hljs-keyword">new</span> 类型[数组大小];  <span class="hljs-comment">//支持C语言样式，但不推荐！</span><br><br>类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[]&#123;...&#125;;  <span class="hljs-comment">//静态初始化（直接指定值和大小）</span><br>类型[] 变量名称 = &#123;...&#125;;   <span class="hljs-comment"><code class="language-hljs java">类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[数组大小];<br>类型 变量名称n = <span class="hljs-keyword">new</span> 类型[数组大小];  <span class="hljs-comment">//支持C语言样式，但不推荐！</span><br><br>类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[]&#123;...&#125;;  <span class="hljs-comment">//静态初始化（直接指定值和大小）</span><br>类型[] 变量名称 = &#123;...&#125;;   <span class="hljs-comment">//同上，但是只能在定义时赋值</span><br></code></pre></td></tr></table></figure>

<p> 创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">626</span>;<br>System.out.println(arr[<span class="hljs-number">0</span>]);<br>System.out.println(arr[<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">626</span>;<br>System.out.println(arr[<span class="hljs-number">0</span>]);<br>System.out.println(arr[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure>

<p>我们可以通过<code>数组变量名称.length</code>来获取当前数组长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(arr.length);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(arr.length);  <span class="hljs-comment">//打印length成员变量的值</span><br></code></pre></td></tr></table></figure>

<p>数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">String[] arr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>System.out.println(arr[<span class="hljs-number">10</span>]);  <span class="hljs-comment">//出现异常！</span><br><br><span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11</span><br><span class="hljs-comment"><code class="language-hljs java">String[] arr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>System.out.println(arr[<span class="hljs-number">10</span>]);  <span class="hljs-comment">//出现异常！</span><br><br><span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11</span><br><span class="hljs-comment">//	at com.test.Application.main(Application.java:7)</span><br></code></pre></td></tr></table></figure>

<p>思考：能不能直接修改length的值来实现动态扩容呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>arr.length = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>arr.length = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p>数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    test(arr);<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    test(arr);<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number">2934</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>如果我们想要快速打印数组中的每一个元素，又怎么办呢？</p>
<h4 id="传统for循环"><a href="#传统for循环" class="headerlink" title="传统for循环"></a>传统for循环</h4><p>我们很容易就联想到for循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < arr.length; i++) &#123;<br>   System.out.println(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。</p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2FDD%2F01%2Fo4YBAGASjymAK8QIAADiOdWkSVA342.jpg&refer=http%3A%2F%2Ffile.elecfans.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632204192&t=52381354d190d09899776f9bb868ef3e" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//三行两列</span><br><span class="hljs-keyword">int</span>[][] arr = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>System.out.println(arr[<span class="hljs-number">2</span>][<span class="hljs-number"><code class="language-hljs java"><span class="hljs-comment">//三行两列</span><br><span class="hljs-keyword">int</span>[][] arr = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>System.out.println(arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure>

<p>二维数组的遍历同一维数组一样，只不过需要嵌套循环！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                           &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                           &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                           &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                           &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>          System.out.println(arr[i][j]);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。</p>
<h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     test(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);    <span class="hljs-comment">//可变长，最后都会被自动封装成一个数组</span><br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String... test)</span></span>&#123;<br>     System.out.println(test[<span class="hljs-number">0</span>]);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     test(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);    <span class="hljs-comment">//可变长，最后都会被自动封装成一个数组</span><br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String... test)</span></span>&#123;<br>     System.out.println(test[<span class="hljs-number">0</span>]);    <span class="hljs-comment">//其实参数就是一个数组</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！</p>
<h3 id="实战：三大基本排序算法"><a href="#实战：三大基本排序算法" class="headerlink" title="实战：三大基本排序算法"></a>实战：三大基本排序算法</h3><p>现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法：</p>
<ul>
<li>冒泡排序</li>
</ul>
<p>冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。</p>
<ul>
<li>插入排序</li>
</ul>
<p>插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg1.jjhgame.com%2Fstatic_data%2Fnewshelp%2F113_5c08e82d2ac8b.jpg&refer=http%3A%2F%2Fimg1.jjhgame.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632208529&t=f3fb9be4dce91c6364f5ec4f9faafc94" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>选择排序</li>
</ul>
<p>选择排序其实就是每次都选择当前数组中最大的数排到最前面！</p>
<hr>
<h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。</p>
<p>设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">&quot;小&quot;</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">&quot;小&quot;</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">this</span>.name = name;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！</p>
<p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。</p>
<p>封装就是通过访问权限控制来实现的。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p>
<p>现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;   <span class="hljs-comment">//通过extends关键字来继承父类</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SportsStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);   <span class="hljs-comment">//必须先通过super关键字（指代父类），实现父类的构造方法！</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exercise</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我超勇的！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArtStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArtStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">art</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;   <span class="hljs-comment">//通过extends关键字来继承父类</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SportsStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);   <span class="hljs-comment">//必须先通过super关键字（指代父类），实现父类的构造方法！</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exercise</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我超勇的！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArtStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArtStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">art</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"随手画个毕加索！"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>子类具有父类的全部属性，protected可见但外部无法使用（包括<code>private</code>属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！</p>
<p>每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用<code>super()</code>，如果父类使用的是默认构造方法，那么子类不用手动指明。</p>
<p>所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Object obj = <span class="hljs-keyword">new</span> Object;<br>System.out.println(obj.hashCode());  <span class="hljs-comment">//求对象的hashcode，默认是对象的内存地址</span><br>System.out.println(obj.equals(obj));  <span class="hljs-comment">//比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 ==</span><br>System.out.println(obj.toString());  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Object obj = <span class="hljs-keyword">new</span> Object;<br>System.out.println(obj.hashCode());  <span class="hljs-comment">//求对象的hashcode，默认是对象的内存地址</span><br>System.out.println(obj.equals(obj));  <span class="hljs-comment">//比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 ==</span><br>System.out.println(obj.toString());  <span class="hljs-comment">//将对象转换为字符串，默认生成对象的类名称+hashcode</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>关于Object类的其他方法，我们会在Java多线程中再来提及。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！</p>
<h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//父类中的study</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;学习&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//子类中的study</span><br><span class="hljs-meta">@Override</span>  <span class="hljs-comment">//声明这个方法是重写的，但是可以不要，我们现阶段不接触</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-comment">//父类中的study</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;学习&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//子类中的study</span><br><span class="hljs-meta">@Override</span>  <span class="hljs-comment">//声明这个方法是重写的，但是可以不要，我们现阶段不接触</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">"给你看点好康的"</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     SportsStudent student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);<br>     student.study();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     SportsStudent student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);<br>     student.study();   <span class="hljs-comment">//输出子类定义的内容</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>思考：静态方法能被重写吗？</p>
<p>当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">super</span>.study();<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">super</span>.study();<br>    System.out.println(<span class="hljs-string">"给你看点好康的"</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> test)</span></span>&#123;<br>    test = <span class="hljs-number">1</span>;<br>  	<span class="hljs-keyword">this</span>.test = <span class="hljs-number">1</span>;<br>  	<span class="hljs-keyword">super</span>.test = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> test)</span></span>&#123;<br>    test = <span class="hljs-number">1</span>;<br>  	<span class="hljs-keyword">this</span>.test = <span class="hljs-number">1</span>;<br>  	<span class="hljs-keyword">super</span>.test = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="再谈类型转换"><a href="#再谈类型转换" class="headerlink" title="再谈类型转换"></a>再谈类型转换</h4><p>我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//父类变量引用子类实例</span><br>student.study();     <span class="hljs-comment"><code class="language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//父类变量引用子类实例</span><br>student.study();     <span class="hljs-comment">//得到依然是具体实现的结果，而不是当前类型的结果</span><br></code></pre></td></tr></table></figure>

<p>我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//是由SportsStudent进行实现的</span><br><span class="hljs-comment">//... do something...</span><br><br>SportsStudent ps = (SportsStudent)student;  <span class="hljs-comment">//让它变成一个具体的子类</span><br>ps.sport();  <span class="hljs-comment"><code class="language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//是由SportsStudent进行实现的</span><br><span class="hljs-comment">//... do something...</span><br><br>SportsStudent ps = (SportsStudent)student;  <span class="hljs-comment">//让它变成一个具体的子类</span><br>ps.sport();  <span class="hljs-comment">//调用具体实现类的方法</span><br></code></pre></td></tr></table></figure>

<p>这样的类型转换称为向下转型。</p>
<h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Student student)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> SportsStudent)&#123;<br>        SportsStudent sportsStudent = (SportsStudent) student;<br>        sportsStudent.sport();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (student <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Student student)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> SportsStudent)&#123;<br>        SportsStudent sportsStudent = (SportsStudent) student;<br>        sportsStudent.sport();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> ArtStudent)&#123;<br>        ArtStudent artStudent = (ArtStudent) student;<br>        artStudent.art();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！</p>
<p>思考：<code>student instanceof Student</code>的结果是什么？</p>
<h4 id="再谈final关键字"><a href="#再谈final关键字" class="headerlink" title="再谈final关键字"></a>再谈final关键字</h4><p>我们目前只知道<code>final</code>关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-comment">//类被声明为终态，那么它还能被继承吗</span><br>  	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//还能重写吗</span><br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//还能重写吗</span><br>    System.out.println(<span class="hljs-string">"学习"</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;   <span class="hljs-comment">//引用类型不允许再指向其他对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-comment">//基本类型值不允许发生改变</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;   <span class="hljs-comment">//引用类型不允许再指向其他对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-comment">//基本类型值不允许发生改变</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-comment">//抽象类</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-comment">//抽象类</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过使用<code>abstract</code>关键字来表明一个类是一个抽象类，抽象类可以使用<code>abstract</code>关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是<strong>必须</strong>由子类实现（除非子类也是一个抽象类）！</p>
<p>抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">Student s = <span class="hljs-keyword">new</span> Student()&#123;    <span class="hljs-comment">//只能直接创建带实现的匿名内部类！</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params"><code class="language-hljs java">Student s = <span class="hljs-keyword">new</span> Student()&#123;    <span class="hljs-comment">//只能直接创建带实现的匿名内部类！</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span><br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span><br>    System.out.println(<span class="hljs-string">"给你看点好康的"</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过使用<code>interface</code>关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含<code>public</code>权限的<strong>抽象方法</strong>！（Java8以后可以有默认实现）我们可以通过声明<code>default</code>关键字来给抽象方法一个默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//do something...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接口中定义的变量，默认为public static final</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Eat</span>, ...</span>&#123;<br>		<span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Eat</span>, ...</span>&#123;<br>		<span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类通过<code>implements</code>关键字来声明实现的接口！每个接口之间用逗号隔开！</p>
<p>实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>我们的类中可以在嵌套一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;   <span class="hljs-comment">//类中定义的一个内部类</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    Test.Inner inner = test.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    Test.Inner inner = test.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//写法有那么一丝怪异，但是没毛病！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过<code>类名.</code>去访问:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test.Inner inner = <span class="hljs-keyword">new</span> Test.Inner();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test.Inner inner = <span class="hljs-keyword">new</span> Test.Inner();   <span class="hljs-comment">//不用再创建外部类对象了！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>对，你没猜错，就是和局部变量一样哒~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>        &#125;<br>        <br>        Inner inner = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>        &#125;<br>        <br>        Inner inner = <span class="hljs-keyword">new</span> Inner();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反正我是没用过！内部类 -&gt; 累不累 -&gt; 反正我累了！</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//DO something...</span><br>            &#125;<br>        &#125;;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！</p>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>读作<code>λ</code>表达式，它其实就是我们接口匿名实现的简化，比如说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//DO something...</span><br>            &#125;<br>        &#125;;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = () -&gt; &#123;&#125;;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//DO something...</span><br>            &#125;<br>        &#125;;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = () -&gt; &#123;&#125;;   <span class="hljs-comment">//等价于上述内容</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！</p>
<p>为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String status;<br>  <br>  	<span class="hljs-comment">//...</span><br>  <br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String status;<br>  <br>  	<span class="hljs-comment">//...</span><br>  <br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！</p>
<p>有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING, STUDY, SLEEP    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING, STUDY, SLEEP    <span class="hljs-comment">//直接写每个状态的名字即可，分号可以不打，但是推荐打上</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用枚举类也非常方便，我们只需要直接访问即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> Status status;<br>  <br> 		<span class="hljs-comment">//...</span><br>  <br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(Status status)</span> </span>&#123;   <span class="hljs-comment">//不再是String，而是我们指定的枚举类型</span><br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> Status status;<br>  <br> 		<span class="hljs-comment">//...</span><br>  <br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(Status status)</span> </span>&#123;   <span class="hljs-comment">//不再是String，而是我们指定的枚举类型</span><br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>);<br>    student.setStatus(Status.RUNNING);<br>    System.out.println(student.getStatus());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// Compiled from &quot;Status.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Enum</span>&lt;<span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status RUNNING;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status STUDY;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status SLEEP;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status[] values();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.<span class="hljs-function">Status <span class="hljs-title">valueOf</span><span class="hljs-params">(java.lang.String)</span></span>;<br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">// Compiled from &quot;Status.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Enum</span>&lt;<span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status RUNNING;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status STUDY;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status SLEEP;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status[] values();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.<span class="hljs-function">Status <span class="hljs-title">valueOf</span><span class="hljs-params">(java.lang.String)</span></span>;<br>  <span class="hljs-keyword">static</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING(<span class="hljs-string">&quot;睡觉&quot;</span>), STUDY(<span class="hljs-string">&quot;学习&quot;</span>), SLEEP(<span class="hljs-string">&quot;睡觉&quot;</span>);   <span class="hljs-comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-comment">//枚举的成员变量</span><br>    Status(String name)&#123;    <span class="hljs-comment">//覆盖原有构造方法（默认private，只能内部使用！）</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>  <br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//获取封装的成员变量</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING(<span class="hljs-string">&quot;睡觉&quot;</span>), STUDY(<span class="hljs-string">&quot;学习&quot;</span>), SLEEP(<span class="hljs-string">&quot;睡觉&quot;</span>);   <span class="hljs-comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-comment">//枚举的成员变量</span><br>    Status(String name)&#123;    <span class="hljs-comment">//覆盖原有构造方法（默认private，只能内部使用！）</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>  <br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//获取封装的成员变量</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>);<br>    student.setStatus(Status.RUNNING);<br>    System.out.println(student.getStatus().getName());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>枚举类还自带一些继承下来的实用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Status.valueOf(<span class="hljs-string">&quot;&quot;</span>)   <span class="hljs-comment">//将名称相同的字符串转换为枚举</span><br>Status.values()   <span class="hljs-comment"><code class="language-hljs java">Status.valueOf(<span class="hljs-string">&quot;&quot;</span>)   <span class="hljs-comment">//将名称相同的字符串转换为枚举</span><br>Status.values()   <span class="hljs-comment">//快速获取所有的枚举</span><br></code></pre></td></tr></table></figure>

<h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！</p>
<p>我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p>
<p><img src="https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>byte  -&gt;  Byte      </li>
<li>boolean  -&gt;  Boolean   </li>
<li>short  -&gt;  Short    </li>
<li>char  -&gt;  Character  </li>
<li>int -&gt; Integer    </li>
<li>long -&gt;  Long     </li>
<li>float -&gt; Float      </li>
<li>double -&gt; Double   </li>
</ul>
<p>包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-comment">//Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-comment">//Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.value = value;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们操作的就是Integer对象而不是一个int基本类型了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     Integer i = <span class="hljs-number">1</span>;   <span class="hljs-comment">//包装类型可以直接接收对应类型的数据，并变为一个对象！</span><br>     System.out.println(i + i);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     Integer i = <span class="hljs-number">1</span>;   <span class="hljs-comment">//包装类型可以直接接收对应类型的数据，并变为一个对象！</span><br>     System.out.println(i + i);    <span class="hljs-comment">//包装类型可以直接被当做一个基本类型进行操作！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Integer i = <span class="hljs-number">1</span>;    <span class="hljs-comment">//其实这里只是简写了而已</span><br>Integer i = Integer.valueOf(<span class="hljs-number">1</span>);  <span class="hljs-comment"><code class="language-hljs java">Integer i = <span class="hljs-number">1</span>;    <span class="hljs-comment">//其实这里只是简写了而已</span><br>Integer i = Integer.valueOf(<span class="hljs-number">1</span>);  <span class="hljs-comment">//编译后真正的样子</span><br></code></pre></td></tr></table></figure>

<p>调用valueOf来生成一个Integer对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="hljs-comment">//注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）</span><br>       <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>  	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="hljs-comment">//注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）</span><br>       <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>  	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);   <span class="hljs-comment">//返回一个新创建好的对象</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = Integer.valueOf(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> a = i;    <span class="hljs-comment">//简写</span><br>    <span class="hljs-keyword">int</span> a = i.intValue();   <span class="hljs-comment">//编译后实际的代码</span><br>  <br>  	<span class="hljs-keyword">long</span> c = i.longValue();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = Integer.valueOf(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> a = i;    <span class="hljs-comment">//简写</span><br>    <span class="hljs-keyword">int</span> a = i.intValue();   <span class="hljs-comment">//编译后实际的代码</span><br>  <br>  	<span class="hljs-keyword">long</span> c = i.longValue();   <span class="hljs-comment">//其他类型也有！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然现在是包装类型了，那么我们还能使用<code>==</code>来判断两个数是否相等吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1 == i2);   <span class="hljs-comment">//实际上判断是两个对象是否为同一个对象（内存地址是否相同）</span><br>    System.out.println(i1.equals(i2));   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1 == i2);   <span class="hljs-comment">//实际上判断是两个对象是否为同一个对象（内存地址是否相同）</span><br>    System.out.println(i1.equals(i2));   <span class="hljs-comment">//这个才是真正的值判断！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意IntegerCache带来的影响！</p>
<p>思考：下面这种情况结果会是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1+<span class="hljs-number">1</span> == i2+<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1+<span class="hljs-number">1</span> == i2+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在集合类的学习中，我们还会继续用到我们的包装类型！</p>
<hr>
<h2 id="面向对象编程实战"><a href="#面向对象编程实战" class="headerlink" title="面向对象编程实战"></a>面向对象编程实战</h2><p>虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;   <span class="hljs-comment">//for循环暴力求解，简单，但是效率似乎低了一些</span><br>        sum += i;<br>    &#125;<br>    System.out.println(sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println((<span class="hljs-number">1</span> + <span class="hljs-number">100</span>) * <span class="hljs-number">50</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;   <span class="hljs-comment">//for循环暴力求解，简单，但是效率似乎低了一些</span><br>        sum += i;<br>    &#125;<br>    System.out.println(sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println((<span class="hljs-number">1</span> + <span class="hljs-number">100</span>) * <span class="hljs-number">50</span>);  <span class="hljs-comment">//高斯求和公式，利用数学，瞬间计算结果！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>说到最后，其实数学和逻辑思维才是解决问题的最终办法！</p>
<h3 id="对象设计（面向对象、多态运用）"><a href="#对象设计（面向对象、多态运用）" class="headerlink" title="对象设计（面向对象、多态运用）"></a>对象设计（面向对象、多态运用）</h3><ul>
<li>设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。</li>
<li>设计设计一个接口<code>考试</code>，只有老师和学生会考试。</li>
<li>设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。</li>
</ul>
<h3 id="二分搜索（搜索算法）"><a href="#二分搜索（搜索算法）" class="headerlink" title="二分搜索（搜索算法）"></a>二分搜索（搜索算法）</h3><p>现在有一个有序数组（从小到大，数组长度 0 &lt; n &lt; 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回<code>-1</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">26</span>&#125;;   <span class="hljs-comment">//测试用例</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">26</span>&#125;;   <span class="hljs-comment">//测试用例</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-comment">//请在这里实现搜索算法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="快速排序（排序算法、递归分治）"><a href="#快速排序（排序算法、递归分治）" class="headerlink" title="快速排序（排序算法、递归分治）"></a>快速排序（排序算法、递归分治）</h3><p>（开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用<strong>分治法</strong>来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。</p>
<p>快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！</p>
<h3 id="0-1背包问题（回溯法、剪枝-动态规划优化）"><a href="#0-1背包问题（回溯法、剪枝-动态规划优化）" class="headerlink" title="0/1背包问题（回溯法、剪枝/动态规划优化）"></a>0/1背包问题（回溯法、剪枝/动态规划优化）</h3><p>给定 <code>n </code>件物品，每一个物品的重量为 <code>w[n]</code>，每个物品的价值为 <code>v[n]</code>。现挑选物品放入背包中，假定背包能承受的最大重量为 <code>capacity</code>，求装入物品的最大价值是多少?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] w = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span>[] v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">int</span> capacity = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] w = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span>[] v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">int</span> capacity = <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JavaSE/">JavaSE</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/02/23/3.html/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java异常机制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/21/2.html/">
                        <span class="hidden-mobile">Java语法规范</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
