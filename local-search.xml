<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/21/1.html/"/>
    <url>/2022/02/21/1.html/</url>
    
    <content type="html"><![CDATA[<h1 id="Java对象和多态-（面向对象）"><a href="#Java对象和多态-（面向对象）" class="headerlink" title="Java对象和多态 （面向对象）"></a>Java对象和多态 （面向对象）</h1><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><p>面向对象程序设计(Object Oriented Programming)</p><p>对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String str = sc.nextLine();<br>System.out.println(<span class="hljs-string"><code class="language-hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String str = sc.nextLine();<br>System.out.println(<span class="hljs-string">"你输入了："</span>+str);<br>sc.close();<br></code></pre></td></tr></table></figure><p>所有的对象，都需要通过<code>new</code>关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！</p><p>不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论）</p><p>对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！</p><hr><h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a>类的基本结构</h2><p>为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过<code>.</code>来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    test.name = <span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    test.name = <span class="hljs-string">"奥利给"</span>;<br>    System.out.println(test.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>成员变量默认带有初始值，也可以自己定义初始值。</p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>我们之前的学习中接触过方法(Method)吗？主方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//Body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p><h4 id="方法的定义和使用"><a href="#方法的定义和使用" class="headerlink" title="方法的定义和使用"></a>方法的定义和使用</h4><p>在类中，我们可以定义自己的方法，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">[返回值类型] 方法名称([参数])&#123;<br>  <span class="hljs-comment">//方法体</span><br>  <span class="hljs-keyword"><code class="language-hljs java">[返回值类型] 方法名称([参数])&#123;<br>  <span class="hljs-comment">//方法体</span><br>  <span class="hljs-keyword">return</span> 结果;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值</li><li>方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！</li><li>参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法</li><li>方法体：方法具体要干的事情</li><li>结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return）</li></ul><p>非void方法中，<code>return</code>关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//缺少retrun语句！</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//缺少retrun语句！</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>return</code>也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>       <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//在循环内返回了！和break区别？</span><br>   &#125;<br>   System.out.println(<span class="hljs-string">&quot;淦&quot;</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>       <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//在循环内返回了！和break区别？</span><br>   &#125;<br>   System.out.println(<span class="hljs-string">&quot;淦&quot;</span>);   <span class="hljs-comment">//还会到这里吗？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">new</span> Test().swap(a, b);<br>  System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string">&quot;, b=&quot;</span>+b);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;  <span class="hljs-comment">//传递的仅仅是值而已！</span><br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">new</span> Test().swap(a, b);<br>  System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string">&quot;, b=&quot;</span>+b);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;  <span class="hljs-comment">//传递的仅仅是值而已！</span><br>  <span class="hljs-keyword">int</span> temp = a;<br>  a = b;<br> b = temp;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br> String name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(B b)</span></span>&#123;  <span class="hljs-comment">//传递的是对象的引用，而不是值</span><br>    System.out.println(b.name);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  B b = <span class="hljs-keyword">new</span> B();<br>  b.name = <span class="hljs-string">&quot;lbw&quot;</span>;<br>  <span class="hljs-keyword">new</span> A().test(b);<br>  System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br> String name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(B b)</span></span>&#123;  <span class="hljs-comment">//传递的是对象的引用，而不是值</span><br>    System.out.println(b.name);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  B b = <span class="hljs-keyword">new</span> B();<br>  b.name = <span class="hljs-string">&quot;lbw&quot;</span>;<br>  <span class="hljs-keyword">new</span> A().test(b);<br>  System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string">", b="</span>+b);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法之间可以相互调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//xxxx</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//xxxx</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;<br>  a();<br>&#125;<br></code></pre></td></tr></table></figure><p>当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> a();<br>&#125;<br></code></pre></td></tr></table></figure><p>成员方法和成员变量一样，是属于对象的，只能通过对象去调用！</p><hr><h3 id="对象设计练习"><a href="#对象设计练习" class="headerlink" title="对象设计练习"></a>对象设计练习</h3><ul><li>学生应该具有以下属性：名字、年龄</li><li>学生应该具有以下行为：学习、运动、说话</li></ul><hr><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//原本的方法</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，形参不同</span><br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，返回类型和形参都不同</span><br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//原本的方法</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，形参不同</span><br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，返回类型和形参都不同</span><br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//错误，仅返回值类型名称不同不能重载</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;   <span class="hljs-comment">//只有int支持，不灵活！</span><br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>&#123;  <span class="hljs-comment">//重写一个double类型的，就支持小数计算了</span><br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;   <span class="hljs-comment">//只有int支持，不灵活！</span><br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>&#123;  <span class="hljs-comment">//重写一个double类型的，就支持小数计算了</span><br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了int&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">short</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了short&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">long</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了long&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">char</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了char&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了double&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">float</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了float&quot;</span>);<br>    &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        test.a(<span class="hljs-number">1</span>);   <span class="hljs-comment">//直接输入整数</span><br>        test.a(<span class="hljs-number">1.0</span>);  <span class="hljs-comment">//直接输入小数</span><br><br>        <span class="hljs-keyword">short</span> s = <span class="hljs-number">2</span>;<br>        test.a(s);  <span class="hljs-comment">//会对号入座吗？</span><br>        test.a(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了int&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">short</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了short&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">long</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了long&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">char</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了char&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了double&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">float</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了float&quot;</span>);<br>    &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        test.a(<span class="hljs-number">1</span>);   <span class="hljs-comment">//直接输入整数</span><br>        test.a(<span class="hljs-number">1.0</span>);  <span class="hljs-comment">//直接输入小数</span><br><br>        <span class="hljs-keyword">short</span> s = <span class="hljs-number">2</span>;<br>        test.a(s);  <span class="hljs-comment">//会对号入座吗？</span><br>        test.a(<span class="hljs-number">1.0F</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//反编译结果</span><br><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//反编译结果</span><br><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译其实就是把我们编译好的class文件变回Java源代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Test test = <span class="hljs-keyword">new</span> Test();  <span class="hljs-comment">//实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的</span><br><span class="hljs-comment"><code class="language-hljs java">Test test = <span class="hljs-keyword">new</span> Test();  <span class="hljs-comment">//实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的</span><br><span class="hljs-comment">// new + 你想要使用的构造方法</span><br></code></pre></td></tr></table></figure><p>这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！</p><p>类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！</p><p>一般最常用的就是给成员属性赋初始值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    <br>    Student()&#123;<br>        name = <span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    <br>    Student()&#123;<br>        name = <span class="hljs-string">"伞兵一号"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student(String name)&#123;   <span class="hljs-comment">//形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！</span><br>        <span class="hljs-keyword">this</span>.name = name;  <span class="hljs-comment">//通过this指代当前的对象属性，this就代表当前对象</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student(String name)&#123;   <span class="hljs-comment">//形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！</span><br>        <span class="hljs-keyword">this</span>.name = name;  <span class="hljs-comment">//通过this指代当前的对象属性，this就代表当前对象</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//idea 右键快速生成！</span><br></code></pre></td></tr></table></figure><p>注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。</p><p>在我们定义了新的有参构造之后，默认的无参构造会被覆盖！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//反编译后依然只有我们定义的有参构造！</span><br></code></pre></td></tr></table></figure><p>如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student()&#123;<br><br>    &#125;<br><br>    Student(String name)&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student()&#123;<br><br>    &#125;<br><br>    Student(String name)&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成员变量的初始化始终在构造方法执行之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String a = <span class="hljs-string">&quot;sadasa&quot;</span>;<br><br>    Student()&#123;<br>        System.out.println(a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String a = <span class="hljs-string">&quot;sadasa&quot;</span>;<br><br>    Student()&#123;<br>        System.out.println(a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><p>静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Student s1 = <span class="hljs-keyword">new</span> Student();<br>s1.a = <span class="hljs-number">10</span>;<br>Student s2 = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Student s1 = <span class="hljs-keyword">new</span> Student();<br>s1.a = <span class="hljs-number">10</span>;<br>Student s2 = <span class="hljs-keyword">new</span> Student();<br>System.out.println(s2.a);<br>&#125;<br></code></pre></td></tr></table></figure><p>不推荐使用对象来调用，被标记为静态的内容，可以直接通过<code>类名.xxx</code>的形式访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   Student.a = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   Student.a = <span class="hljs-number">10</span>;<br>   System.out.println(Student.a);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="简述类加载机制"><a href="#简述类加载机制" class="headerlink" title="简述类加载机制"></a>简述类加载机制</h4><p>类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new 创建类的实例（隐式加载）</li><li>调用类的静态方法</li><li>子类初始化时</li><li>其他的情况会在讲到反射时介绍</li></ul><p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();  <span class="hljs-comment">//直接调用静态方法，只能调用静态方法</span><br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string">&quot;构造类对象&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//静态方法刚加载时就有了</span><br>        System.out.println(<span class="hljs-string">&quot;初始化变量a&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();  <span class="hljs-comment">//直接调用静态方法，只能调用静态方法</span><br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string">&quot;构造类对象&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//静态方法刚加载时就有了</span><br>        System.out.println(<span class="hljs-string">&quot;初始化变量a&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Student.a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0</p><h3 id="代码块和静态代码块"><a href="#代码块和静态代码块" class="headerlink" title="代码块和静态代码块"></a>代码块和静态代码块</h3><p>代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是代码块&quot;</span>);<br>    &#125;<br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是代码块&quot;</span>);<br>    &#125;<br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string">"我是构造方法"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        a = <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        a = <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Student.a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="String和StringBuilder类"><a href="#String和StringBuilder类" class="headerlink" title="String和StringBuilder类"></a>String和StringBuilder类</h3><p>字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例)</p><p>String的对象直接支持使用<code>+</code>或<code>+=</code>运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java">String a = <span class="hljs-string">&quot;dasdsa&quot;</span>, b = <span class="hljs-string"><code class="language-hljs java">String a = <span class="hljs-string">&quot;dasdsa&quot;</span>, b = <span class="hljs-string">"dasdasdsa"</span>;<br>String l = a+b;<br>System.out.println(l);<br></code></pre></td></tr></table></figure><p>大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">String result=<span class="hljs-string">&quot;String&quot;</span>+<span class="hljs-string">&quot;and&quot;</span>; <span class="hljs-comment"><code class="language-hljs java">String result=<span class="hljs-string">&quot;String&quot;</span>+<span class="hljs-string">&quot;and&quot;</span>; <span class="hljs-comment">//会被优化成一句！</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=str1+str2;<br><span class="hljs-comment"><code class="language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=str1+str2;<br><span class="hljs-comment">//变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=(<span class="hljs-keyword">new</span> StringBuilder(String.valueOf(str1))).append(str2).toString();<br><span class="hljs-comment"><code class="language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=(<span class="hljs-keyword">new</span> StringBuilder(String.valueOf(str1))).append(str2).toString();<br><span class="hljs-comment">//使用StringBuilder，会采用类似于第一种实现，显然会更快！</span><br></code></pre></td></tr></table></figure><p>StringBuilder也是一个类，但是它能够存储可变长度的字符串！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>builder<br>       .append(<span class="hljs-string">&quot;a&quot;</span>)<br>       .append(<span class="hljs-string">&quot;bc&quot;</span>)<br>       .append(<span class="hljs-string">&quot;d&quot;</span>);   <span class="hljs-comment"><code class="language-hljs java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>builder<br>       .append(<span class="hljs-string">&quot;a&quot;</span>)<br>       .append(<span class="hljs-string">&quot;bc&quot;</span>)<br>       .append(<span class="hljs-string">&quot;d&quot;</span>);   <span class="hljs-comment">//链式调用</span><br>String str = builder.toString();<br>System.out.println(str);<br></code></pre></td></tr></table></figure><hr><h2 id="包和访问控制"><a href="#包和访问控制" class="headerlink" title="包和访问控制"></a>包和访问控制</h2><h3 id="包声明和导入"><a href="#包声明和导入" class="headerlink" title="包声明和导入"></a>包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。</p><p>一般包按照个人或是公司域名的规则倒过来写 <code>顶级域名.一级域名.二级域名</code> <code>com.java.xxxx</code></p><p>如果需要使用其他包里面的类，那么我们需要<code>import</code>（类似于C/C++中的include）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">import</span> com.test.Student;<br></code></pre></td></tr></table></figure><p>也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">import</span> com.test.*<br></code></pre></td></tr></table></figure><p>Java默认为我们导入了以下的包，不需要去声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">import</span> java.lang.*<br></code></pre></td></tr></table></figure><h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><p>静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.test.ui.Student.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.test.ui.Student.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态导入不会进行类的初始化！</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。</p><p>![image-20210819160939950](/Users/nagocoler/Library/Application Support/typora-user-images/image-20210819160939950.png)</p><p>权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//具有私有访问权限，只能类内部访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    System.out.println(s.a);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//具有私有访问权限，只能类内部访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    System.out.println(s.a);  <span class="hljs-comment">//还可以访问吗？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// Student.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Student.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;   <span class="hljs-comment">//不能添加权限修饰符！只能是default</span><br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&refer=http%3A%2F%2Fimgs.itxueyuan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632192902&t=7a6d67fc01d0e3ea7816adf951c49605" alt="img"></p><p>我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];  <span class="hljs-comment">//需要new关键字来创建！</span><br>String[] arr2 = <span class="hljs-keyword">new</span> String[<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];  <span class="hljs-comment">//需要new关键字来创建！</span><br>String[] arr2 = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>数组本身也是类（编程不可见，C++写的），不是基本数据类型！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>System.out.println(arr.length);   <span class="hljs-comment">//数组有成员变量！</span><br>System.out.println(arr.toString());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>System.out.println(arr.length);   <span class="hljs-comment">//数组有成员变量！</span><br>System.out.println(arr.toString());   <span class="hljs-comment">//数组有成员方法！</span><br></code></pre></td></tr></table></figure><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[数组大小];<br>类型 变量名称n = <span class="hljs-keyword">new</span> 类型[数组大小];  <span class="hljs-comment">//支持C语言样式，但不推荐！</span><br><br>类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[]&#123;...&#125;;  <span class="hljs-comment">//静态初始化（直接指定值和大小）</span><br>类型[] 变量名称 = &#123;...&#125;;   <span class="hljs-comment"><code class="language-hljs java">类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[数组大小];<br>类型 变量名称n = <span class="hljs-keyword">new</span> 类型[数组大小];  <span class="hljs-comment">//支持C语言样式，但不推荐！</span><br><br>类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[]&#123;...&#125;;  <span class="hljs-comment">//静态初始化（直接指定值和大小）</span><br>类型[] 变量名称 = &#123;...&#125;;   <span class="hljs-comment">//同上，但是只能在定义时赋值</span><br></code></pre></td></tr></table></figure><p> 创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">626</span>;<br>System.out.println(arr[<span class="hljs-number">0</span>]);<br>System.out.println(arr[<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">626</span>;<br>System.out.println(arr[<span class="hljs-number">0</span>]);<br>System.out.println(arr[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>我们可以通过<code>数组变量名称.length</code>来获取当前数组长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(arr.length);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(arr.length);  <span class="hljs-comment">//打印length成员变量的值</span><br></code></pre></td></tr></table></figure><p>数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">String[] arr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>System.out.println(arr[<span class="hljs-number">10</span>]);  <span class="hljs-comment">//出现异常！</span><br><br><span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11</span><br><span class="hljs-comment"><code class="language-hljs java">String[] arr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>System.out.println(arr[<span class="hljs-number">10</span>]);  <span class="hljs-comment">//出现异常！</span><br><br><span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11</span><br><span class="hljs-comment">//at com.test.Application.main(Application.java:7)</span><br></code></pre></td></tr></table></figure><p>思考：能不能直接修改length的值来实现动态扩容呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>arr.length = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>arr.length = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    test(arr);<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    test(arr);<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number">2934</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>如果我们想要快速打印数组中的每一个元素，又怎么办呢？</p><h4 id="传统for循环"><a href="#传统for循环" class="headerlink" title="传统for循环"></a>传统for循环</h4><p>我们很容易就联想到for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < arr.length; i++) &#123;<br>   System.out.println(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2FDD%2F01%2Fo4YBAGASjymAK8QIAADiOdWkSVA342.jpg&refer=http%3A%2F%2Ffile.elecfans.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632204192&t=52381354d190d09899776f9bb868ef3e" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//三行两列</span><br><span class="hljs-keyword">int</span>[][] arr = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>System.out.println(arr[<span class="hljs-number">2</span>][<span class="hljs-number"><code class="language-hljs java"><span class="hljs-comment">//三行两列</span><br><span class="hljs-keyword">int</span>[][] arr = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>System.out.println(arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>二维数组的遍历同一维数组一样，只不过需要嵌套循环！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                           &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                           &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                           &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                           &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>          System.out.println(arr[i][j]);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。</p><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     test(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);    <span class="hljs-comment">//可变长，最后都会被自动封装成一个数组</span><br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String... test)</span></span>&#123;<br>     System.out.println(test[<span class="hljs-number">0</span>]);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     test(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);    <span class="hljs-comment">//可变长，最后都会被自动封装成一个数组</span><br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String... test)</span></span>&#123;<br>     System.out.println(test[<span class="hljs-number">0</span>]);    <span class="hljs-comment">//其实参数就是一个数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！</p><h3 id="实战：三大基本排序算法"><a href="#实战：三大基本排序算法" class="headerlink" title="实战：三大基本排序算法"></a>实战：三大基本排序算法</h3><p>现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br></code></pre></td></tr></table></figure><p>排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法：</p><ul><li>冒泡排序</li></ul><p>冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。</p><ul><li>插入排序</li></ul><p>插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg1.jjhgame.com%2Fstatic_data%2Fnewshelp%2F113_5c08e82d2ac8b.jpg&refer=http%3A%2F%2Fimg1.jjhgame.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632208529&t=f3fb9be4dce91c6364f5ec4f9faafc94" alt="img"></p><ul><li>选择排序</li></ul><p>选择排序其实就是每次都选择当前数组中最大的数排到最前面！</p><hr><h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。</p><p>设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">&quot;小&quot;</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">&quot;小&quot;</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">this</span>.name = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！</p><p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。</p><p>封装就是通过访问权限控制来实现的。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p><p>现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;   <span class="hljs-comment">//通过extends关键字来继承父类</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SportsStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);   <span class="hljs-comment">//必须先通过super关键字（指代父类），实现父类的构造方法！</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exercise</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我超勇的！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArtStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArtStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">art</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;   <span class="hljs-comment">//通过extends关键字来继承父类</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SportsStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);   <span class="hljs-comment">//必须先通过super关键字（指代父类），实现父类的构造方法！</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exercise</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我超勇的！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArtStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArtStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">art</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"随手画个毕加索！"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类具有父类的全部属性，protected可见但外部无法使用（包括<code>private</code>属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！</p><p>每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用<code>super()</code>，如果父类使用的是默认构造方法，那么子类不用手动指明。</p><p>所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Object obj = <span class="hljs-keyword">new</span> Object;<br>System.out.println(obj.hashCode());  <span class="hljs-comment">//求对象的hashcode，默认是对象的内存地址</span><br>System.out.println(obj.equals(obj));  <span class="hljs-comment">//比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 ==</span><br>System.out.println(obj.toString());  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Object obj = <span class="hljs-keyword">new</span> Object;<br>System.out.println(obj.hashCode());  <span class="hljs-comment">//求对象的hashcode，默认是对象的内存地址</span><br>System.out.println(obj.equals(obj));  <span class="hljs-comment">//比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 ==</span><br>System.out.println(obj.toString());  <span class="hljs-comment">//将对象转换为字符串，默认生成对象的类名称+hashcode</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于Object类的其他方法，我们会在Java多线程中再来提及。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！</p><h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//父类中的study</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;学习&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//子类中的study</span><br><span class="hljs-meta">@Override</span>  <span class="hljs-comment">//声明这个方法是重写的，但是可以不要，我们现阶段不接触</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-comment">//父类中的study</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;学习&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//子类中的study</span><br><span class="hljs-meta">@Override</span>  <span class="hljs-comment">//声明这个方法是重写的，但是可以不要，我们现阶段不接触</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">"给你看点好康的"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     SportsStudent student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);<br>     student.study();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     SportsStudent student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);<br>     student.study();   <span class="hljs-comment">//输出子类定义的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>思考：静态方法能被重写吗？</p><p>当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">super</span>.study();<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">super</span>.study();<br>    System.out.println(<span class="hljs-string">"给你看点好康的"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> test)</span></span>&#123;<br>    test = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">this</span>.test = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">super</span>.test = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> test)</span></span>&#123;<br>    test = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">this</span>.test = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">super</span>.test = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="再谈类型转换"><a href="#再谈类型转换" class="headerlink" title="再谈类型转换"></a>再谈类型转换</h4><p>我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//父类变量引用子类实例</span><br>student.study();     <span class="hljs-comment"><code class="language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//父类变量引用子类实例</span><br>student.study();     <span class="hljs-comment">//得到依然是具体实现的结果，而不是当前类型的结果</span><br></code></pre></td></tr></table></figure><p>我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//是由SportsStudent进行实现的</span><br><span class="hljs-comment">//... do something...</span><br><br>SportsStudent ps = (SportsStudent)student;  <span class="hljs-comment">//让它变成一个具体的子类</span><br>ps.sport();  <span class="hljs-comment"><code class="language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//是由SportsStudent进行实现的</span><br><span class="hljs-comment">//... do something...</span><br><br>SportsStudent ps = (SportsStudent)student;  <span class="hljs-comment">//让它变成一个具体的子类</span><br>ps.sport();  <span class="hljs-comment">//调用具体实现类的方法</span><br></code></pre></td></tr></table></figure><p>这样的类型转换称为向下转型。</p><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Student student)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> SportsStudent)&#123;<br>        SportsStudent sportsStudent = (SportsStudent) student;<br>        sportsStudent.sport();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (student <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Student student)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> SportsStudent)&#123;<br>        SportsStudent sportsStudent = (SportsStudent) student;<br>        sportsStudent.sport();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> ArtStudent)&#123;<br>        ArtStudent artStudent = (ArtStudent) student;<br>        artStudent.art();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！</p><p>思考：<code>student instanceof Student</code>的结果是什么？</p><h4 id="再谈final关键字"><a href="#再谈final关键字" class="headerlink" title="再谈final关键字"></a>再谈final关键字</h4><p>我们目前只知道<code>final</code>关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-comment">//类被声明为终态，那么它还能被继承吗</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//还能重写吗</span><br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//还能重写吗</span><br>    System.out.println(<span class="hljs-string">"学习"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;   <span class="hljs-comment">//引用类型不允许再指向其他对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-comment">//基本类型值不允许发生改变</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;   <span class="hljs-comment">//引用类型不允许再指向其他对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-comment">//基本类型值不允许发生改变</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure><p>学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-comment">//抽象类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-comment">//抽象类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用<code>abstract</code>关键字来表明一个类是一个抽象类，抽象类可以使用<code>abstract</code>关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是<strong>必须</strong>由子类实现（除非子类也是一个抽象类）！</p><p>抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">Student s = <span class="hljs-keyword">new</span> Student()&#123;    <span class="hljs-comment">//只能直接创建带实现的匿名内部类！</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params"><code class="language-hljs java">Student s = <span class="hljs-keyword">new</span> Student()&#123;    <span class="hljs-comment">//只能直接创建带实现的匿名内部类！</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span><br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span><br>    System.out.println(<span class="hljs-string">"给你看点好康的"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用<code>interface</code>关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含<code>public</code>权限的<strong>抽象方法</strong>！（Java8以后可以有默认实现）我们可以通过声明<code>default</code>关键字来给抽象方法一个默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//do something...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口中定义的变量，默认为public static final</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Eat</span>, ...</span>&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Eat</span>, ...</span>&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类通过<code>implements</code>关键字来声明实现的接口！每个接口之间用逗号隔开！</p><p>实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>我们的类中可以在嵌套一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;   <span class="hljs-comment">//类中定义的一个内部类</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    Test.Inner inner = test.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    Test.Inner inner = test.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//写法有那么一丝怪异，但是没毛病！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过<code>类名.</code>去访问:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test.Inner inner = <span class="hljs-keyword">new</span> Test.Inner();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test.Inner inner = <span class="hljs-keyword">new</span> Test.Inner();   <span class="hljs-comment">//不用再创建外部类对象了！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>对，你没猜错，就是和局部变量一样哒~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>        &#125;<br>        <br>        Inner inner = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>        &#125;<br>        <br>        Inner inner = <span class="hljs-keyword">new</span> Inner();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反正我是没用过！内部类 -&gt; 累不累 -&gt; 反正我累了！</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//DO something...</span><br>            &#125;<br>        &#125;;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！</p><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>读作<code>λ</code>表达式，它其实就是我们接口匿名实现的简化，比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//DO something...</span><br>            &#125;<br>        &#125;;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = () -&gt; &#123;&#125;;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//DO something...</span><br>            &#125;<br>        &#125;;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = () -&gt; &#123;&#125;;   <span class="hljs-comment">//等价于上述内容</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！</p><p>为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String status;<br>  <br>  <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String status;<br>  <br>  <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！</p><p>有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING, STUDY, SLEEP    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING, STUDY, SLEEP    <span class="hljs-comment">//直接写每个状态的名字即可，分号可以不打，但是推荐打上</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用枚举类也非常方便，我们只需要直接访问即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> Status status;<br>  <br> <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(Status status)</span> </span>&#123;   <span class="hljs-comment">//不再是String，而是我们指定的枚举类型</span><br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> Status status;<br>  <br> <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(Status status)</span> </span>&#123;   <span class="hljs-comment">//不再是String，而是我们指定的枚举类型</span><br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>);<br>    student.setStatus(Status.RUNNING);<br>    System.out.println(student.getStatus());<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// Compiled from &quot;Status.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Enum</span>&lt;<span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status RUNNING;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status STUDY;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status SLEEP;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status[] values();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.<span class="hljs-function">Status <span class="hljs-title">valueOf</span><span class="hljs-params">(java.lang.String)</span></span>;<br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">// Compiled from &quot;Status.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Enum</span>&lt;<span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status RUNNING;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status STUDY;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status SLEEP;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status[] values();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.<span class="hljs-function">Status <span class="hljs-title">valueOf</span><span class="hljs-params">(java.lang.String)</span></span>;<br>  <span class="hljs-keyword">static</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING(<span class="hljs-string">&quot;睡觉&quot;</span>), STUDY(<span class="hljs-string">&quot;学习&quot;</span>), SLEEP(<span class="hljs-string">&quot;睡觉&quot;</span>);   <span class="hljs-comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-comment">//枚举的成员变量</span><br>    Status(String name)&#123;    <span class="hljs-comment">//覆盖原有构造方法（默认private，只能内部使用！）</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//获取封装的成员变量</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING(<span class="hljs-string">&quot;睡觉&quot;</span>), STUDY(<span class="hljs-string">&quot;学习&quot;</span>), SLEEP(<span class="hljs-string">&quot;睡觉&quot;</span>);   <span class="hljs-comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-comment">//枚举的成员变量</span><br>    Status(String name)&#123;    <span class="hljs-comment">//覆盖原有构造方法（默认private，只能内部使用！）</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//获取封装的成员变量</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>);<br>    student.setStatus(Status.RUNNING);<br>    System.out.println(student.getStatus().getName());<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类还自带一些继承下来的实用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Status.valueOf(<span class="hljs-string">&quot;&quot;</span>)   <span class="hljs-comment">//将名称相同的字符串转换为枚举</span><br>Status.values()   <span class="hljs-comment"><code class="language-hljs java">Status.valueOf(<span class="hljs-string">&quot;&quot;</span>)   <span class="hljs-comment">//将名称相同的字符串转换为枚举</span><br>Status.values()   <span class="hljs-comment">//快速获取所有的枚举</span><br></code></pre></td></tr></table></figure><h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！</p><p>我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p><p><img src="https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png" alt="img"></p><ul><li>byte  -&gt;  Byte      </li><li>boolean  -&gt;  Boolean   </li><li>short  -&gt;  Short    </li><li>char  -&gt;  Character  </li><li>int -&gt; Integer    </li><li>long -&gt;  Long     </li><li>float -&gt; Float      </li><li>double -&gt; Double   </li></ul><p>包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-comment">//Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-comment">//Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.value = value;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们操作的就是Integer对象而不是一个int基本类型了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     Integer i = <span class="hljs-number">1</span>;   <span class="hljs-comment">//包装类型可以直接接收对应类型的数据，并变为一个对象！</span><br>     System.out.println(i + i);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     Integer i = <span class="hljs-number">1</span>;   <span class="hljs-comment">//包装类型可以直接接收对应类型的数据，并变为一个对象！</span><br>     System.out.println(i + i);    <span class="hljs-comment">//包装类型可以直接被当做一个基本类型进行操作！</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Integer i = <span class="hljs-number">1</span>;    <span class="hljs-comment">//其实这里只是简写了而已</span><br>Integer i = Integer.valueOf(<span class="hljs-number">1</span>);  <span class="hljs-comment"><code class="language-hljs java">Integer i = <span class="hljs-number">1</span>;    <span class="hljs-comment">//其实这里只是简写了而已</span><br>Integer i = Integer.valueOf(<span class="hljs-number">1</span>);  <span class="hljs-comment">//编译后真正的样子</span><br></code></pre></td></tr></table></figure><p>调用valueOf来生成一个Integer对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="hljs-comment">//注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）</span><br>       <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="hljs-comment">//注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）</span><br>       <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);   <span class="hljs-comment">//返回一个新创建好的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = Integer.valueOf(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> a = i;    <span class="hljs-comment">//简写</span><br>    <span class="hljs-keyword">int</span> a = i.intValue();   <span class="hljs-comment">//编译后实际的代码</span><br>  <br>  <span class="hljs-keyword">long</span> c = i.longValue();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = Integer.valueOf(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> a = i;    <span class="hljs-comment">//简写</span><br>    <span class="hljs-keyword">int</span> a = i.intValue();   <span class="hljs-comment">//编译后实际的代码</span><br>  <br>  <span class="hljs-keyword">long</span> c = i.longValue();   <span class="hljs-comment">//其他类型也有！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>既然现在是包装类型了，那么我们还能使用<code>==</code>来判断两个数是否相等吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1 == i2);   <span class="hljs-comment">//实际上判断是两个对象是否为同一个对象（内存地址是否相同）</span><br>    System.out.println(i1.equals(i2));   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1 == i2);   <span class="hljs-comment">//实际上判断是两个对象是否为同一个对象（内存地址是否相同）</span><br>    System.out.println(i1.equals(i2));   <span class="hljs-comment">//这个才是真正的值判断！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意IntegerCache带来的影响！</p><p>思考：下面这种情况结果会是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1+<span class="hljs-number">1</span> == i2+<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1+<span class="hljs-number">1</span> == i2+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在集合类的学习中，我们还会继续用到我们的包装类型！</p><hr><h2 id="面向对象编程实战"><a href="#面向对象编程实战" class="headerlink" title="面向对象编程实战"></a>面向对象编程实战</h2><p>虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;   <span class="hljs-comment">//for循环暴力求解，简单，但是效率似乎低了一些</span><br>        sum += i;<br>    &#125;<br>    System.out.println(sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println((<span class="hljs-number">1</span> + <span class="hljs-number">100</span>) * <span class="hljs-number">50</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;   <span class="hljs-comment">//for循环暴力求解，简单，但是效率似乎低了一些</span><br>        sum += i;<br>    &#125;<br>    System.out.println(sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println((<span class="hljs-number">1</span> + <span class="hljs-number">100</span>) * <span class="hljs-number">50</span>);  <span class="hljs-comment">//高斯求和公式，利用数学，瞬间计算结果！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>说到最后，其实数学和逻辑思维才是解决问题的最终办法！</p><h3 id="对象设计（面向对象、多态运用）"><a href="#对象设计（面向对象、多态运用）" class="headerlink" title="对象设计（面向对象、多态运用）"></a>对象设计（面向对象、多态运用）</h3><ul><li>设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。</li><li>设计设计一个接口<code>考试</code>，只有老师和学生会考试。</li><li>设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。</li></ul><h3 id="二分搜索（搜索算法）"><a href="#二分搜索（搜索算法）" class="headerlink" title="二分搜索（搜索算法）"></a>二分搜索（搜索算法）</h3><p>现在有一个有序数组（从小到大，数组长度 0 &lt; n &lt; 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回<code>-1</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">26</span>&#125;;   <span class="hljs-comment">//测试用例</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">26</span>&#125;;   <span class="hljs-comment">//测试用例</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-comment">//请在这里实现搜索算法</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序（排序算法、递归分治）"><a href="#快速排序（排序算法、递归分治）" class="headerlink" title="快速排序（排序算法、递归分治）"></a>快速排序（排序算法、递归分治）</h3><p>（开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用<strong>分治法</strong>来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。</p><p>快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！</p><h3 id="0-1背包问题（回溯法、剪枝-动态规划优化）"><a href="#0-1背包问题（回溯法、剪枝-动态规划优化）" class="headerlink" title="0/1背包问题（回溯法、剪枝/动态规划优化）"></a>0/1背包问题（回溯法、剪枝/动态规划优化）</h3><p>给定 <code>n </code>件物品，每一个物品的重量为 <code>w[n]</code>，每个物品的价值为 <code>v[n]</code>。现挑选物品放入背包中，假定背包能承受的最大重量为 <code>capacity</code>，求装入物品的最大价值是多少?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] w = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span>[] v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">int</span> capacity = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] w = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span>[] v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">int</span> capacity = <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/21/0.html/"/>
    <url>/2022/02/21/0.html/</url>
    
    <content type="html"><![CDATA[<h1 id="Java语法规范"><a href="#Java语法规范" class="headerlink" title="Java语法规范"></a>Java语法规范</h1><p>所有的Java语句必须以<code>;</code>结尾！</p><p>无论是<code>()</code>、<code>[]</code>还是<code>&#123;&#125;</code>，所有的括号必须一一匹配！</p><p>主方法的代码只能写在<code>&#123;&#125;</code>中！</p><h1 id="Java基础语法（面向过程）"><a href="#Java基础语法（面向过程）" class="headerlink" title="Java基础语法（面向过程）"></a>Java基础语法（面向过程）</h1><p>在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Python就会很轻松！</p><h2 id="变量和关键字"><a href="#变量和关键字" class="headerlink" title="变量和关键字"></a>变量和关键字</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量就是一个可变的量，例如定义一个int类型的变量（int就是整数类型）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">20</span>;<br>a = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">20</span>;<br>a = <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p>我们能够随意更改它的值，也就是说它的值是随时可变的，我们称为变量。变量可以是类的变量，也可以是方法内部的局部变量（我们现阶段主要用局部变量，类变量在面向对象再讲解）</p><p>变量和C语言中的变量不同，Java中的变量是存放在JVM管理的内存中，C语言的变量存放在内存（某些情况下需要手动释放内存，而Java会自动帮助我们清理变量占据的内存）Java和C++很类似，但是没有指针！Java也叫C++–</p><p>Java是强类型语言，只有明确定义了变量之后，你才能使用！一旦被指定某个数据类型，那么它将始终被认为是对应的类型（和JS不一样！）</p><p>定义一个变量的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">[类型] [标识符(名字)] = [初始值(可选)]<br><span class="hljs-keyword">int</span> a = <span class="hljs-number"><code class="language-hljs java">[类型] [标识符(名字)] = [初始值(可选)]<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>注意：标识符不能为以下内容：</p><ul><li>标识符以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。</li><li>大小写敏感！</li><li>不能有空格、@、#、+、-、/ 等符号</li><li>应该使用有意义的名称，达到见名知意的目的，最好以小写字母开头</li><li>不可以是 true 和 false </li><li>不能与Java语言的关键字重名</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>![image-20210817150135886](/Users/nagocoler/Library/Application Support/typora-user-images/image-20210817150135886.png)</p><p>包括基本数据类型、流程控制语句等，了解就行，不用去记，后面我们会一点一点带大家认识！</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量就是无法修改值的变量，常量的值，只能定义一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">10</span>;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">10</span>;  <span class="hljs-comment">//报错！</span><br></code></pre></td></tr></table></figure><p>常量前面必须添加final关键字（C语言里面是const，虽然Java也有，但是不能使用！）</p><p>这只是final关键字的第一个用法，后面还会有更多的用法。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>养成注释的好习惯，不然以后自己都看不懂自己的代码！注释包括单行注释和多行注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//我是单行注释</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 我是</span><br><span class="hljs-comment">* 多行注释</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//我是单行注释</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 我是</span><br><span class="hljs-comment">* 多行注释</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//TODO 待做标记</span><br></code></pre></td></tr></table></figure><hr><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java中的数据类型分为基本数据类型和引用类型两大类，引用类型我们在面向对象时再提，基本数据类型是重点中的重点！首先我们需要了解有哪些类型。然后，我们需要知道的，并不是他们的精度如何，能够表示的范围有多大，而是为什么Java会给我们定义这些类型，计算机是怎么表示这些类型的，这样我们才能够更好的记忆他们的精度、表示的范围大小。所以，我们从计算机原理的角度出发，带领大家走进Java的基本数据类型。</p><p>这一部分稍微有点烧脑，但是是重中之重，如果你掌握了这些，任何相关的面试题都难不倒你！（如果你学习过计算机组成原理就很好理解了）</p><h3 id="计算机中的二进制表示"><a href="#计算机中的二进制表示" class="headerlink" title="计算机中的二进制表示"></a>计算机中的二进制表示</h3><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p><p>十进制的7 -&gt; 在二进制中为 111 = 2^2 + 2^1 + 2^0</p><p>现在有4个bit位，最大能够表示多大的数字呢？</p><ul><li>最小：0000 =&gt; 0</li><li>最大：1111 =&gt; 2^3+2^2+2^1+2^0 =&gt; 8 + 4 + 2 + 1 = 15</li></ul><p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p><ul><li>最小：1111 =&gt; -(2^2+2^1+2^0) =&gt; -7</li><li>最大：0111 =&gt; +(2^2+2^1+2^0) =&gt; +7 =&gt; 7</li></ul><p>现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。</p><h3 id="计算机中的加减法"><a href="#计算机中的加减法" class="headerlink" title="计算机中的加减法"></a>计算机中的加减法</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p><p>1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）</p><p>我们得创造一种更好的表示方式！于是我们引入了反码：</p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li></ul><p>经过上面的定义，我们再来进行加减法：</p><p>1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！）</p><p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？</p><ul><li>0既不是正数也不是负数，那么显然这样的表示依然不够合理！</li></ul><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：</p><ul><li>正数的补码就是其本身 （不变！）</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</li></ul><p>其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：</p><p>1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！）</p><p>所以现在，4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）</p><p><code>以上内容是重点， 是一定要掌握的知识，这些知识是你在面试中的最终防线！有了这些理论基础，无论面试题如何变换，都能够通过理论知识来破解</code></p><hr><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。</p><p>在Java中，整数类型包括以下几个：</p><ul><li>byte 字节型 （8个bit，也就是1个字节）范围：-128~+127</li><li>short 短整形（16个bit，也就是2个字节）范围：-32768~+32767</li><li>int 整形（32个bit，也就是4个字节）最常用的类型！</li><li>long 长整形（64个bit，也就是8个字节）最后需要添加l或L</li></ul><p>long都装不下怎么办？BigInteger！</p><p>数字已经达到byte的最大值了，还能加吗？为了便于理解，以4bit为例：</p><p>0111 + 0001 = 1000 =&gt;  -8（你没看错，就是这样！）</p><p>整数还能使用8进制、16进制表示：</p><ul><li>十进制为15 = 八进制表示为017 = 十六进制表示为 0xF = 二进制表示 1111 (代码里面不能使用二进制！)</li></ul><h3 id="字符类型和字符串"><a href="#字符类型和字符串" class="headerlink" title="字符类型和字符串"></a>字符类型和字符串</h3><p>在Java中，存在字符类型，它能够代表一个字符：</p><ul><li>char 字符型（16个bit，也就是2字节，它不带符号！）范围是0 ~ 65535</li><li>使用Unicode表示就是：\u0000 ~ \uffff</li></ul><p>字符要用单引号扩起来！比如 char c = ‘淦’;</p><p>字符其实本质也是数字，但是这些数字通过编码表进行映射，代表了不同的字符，比如字符<code>&#39;A&#39;</code>的ASCII码就是数字<code>65</code>，所以，char类型其实可以转换为上面的整数类型。</p><p>Java的char采用Unicode编码表（不是ASCII编码！），Unicode编码表包含ASCII的所有内容，同时还包括了全世界的语言，ASCII只有1字节，而Unicode编码是2字节，能够代表65536种文字，足以包含全世界的文字了！（我们编译出来的字节码文件也是使用Unicode编码的，所以利用这种特性，其实Java支持中文变量名称、方法名称甚至是类名）</p><p>既然char只能代表一个字符，那怎么才能包含一句话呢？（关于数组，我们这里先不了解，数组我们放在面向对象章节讲解）</p><p>String就是Java中的字符串类型（注意，它是一个类，创建出来的字符串本质是一个对象，不是我们的基本类型）字符串就像它的名字一样，代表一串字符，也就是一句完整的话。</p><p>字符串用双引号括起来！比如：String str = “一日三餐没烦恼”;</p><h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h3><p>小数类型比较难理解（比较难理解指的是原理，不是使用）首先来看看Java中的小数类型包含哪些：</p><ul><li>float 单精度浮点型 （32bit，4字节）</li><li>double 双精度浮点型（64bit，8字节）</li></ul><p>思考：小数的范围该怎么定义呢？我们首先要了解的是小数在计算机里面是如何存放的：</p><p>![image-20210817143234500](/Users/nagocoler/Library/Application Support/typora-user-images/image-20210817143234500.png)</p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：<br>V = (-1)^S × M × 2^E<br>（1）(-1)^S 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。<br>（2）M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）<br>（3）2^E 表示指数位。（用于移动小数点）</p><p>比如： 对于十进制的 5.25 对应的二进制为：101.01，相当于：1.0101*2^2。所以，S 为 0，M 为 1.0101，E 为 2。所以，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码。我们在这里就不去计算了，想了解的可以去搜索相关资料。</p><p>思考：就算double有64bit位数，但是依然存在精度限制，如果我要进行高精度的计算，怎么办？BigDecimal！</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句。（C语言一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p><hr><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换支持字节数小的类型自动转换为字节数大的类型，整数类型自动转换为小数类型，转换规则如下：</p><ul><li>byte→short(char)→int→long→float→double</li></ul><p>问题：为什么long比float大，还能转换为float呢？小数的存储规则让float的最大值比long还大，只是可能会丢失某些位上的精度！</p><p>所以，如下的代码就能够正常运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">short</span> s = b;<br><span class="hljs-keyword">int</span> i = s;<br><span class="hljs-keyword">long</span> l = i;<br><span class="hljs-keyword">float</span> f = l;<br><span class="hljs-keyword">double</span> d = f;<br>System.out.println(d);<br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">short</span> s = b;<br><span class="hljs-keyword">int</span> i = s;<br><span class="hljs-keyword">long</span> l = i;<br><span class="hljs-keyword">float</span> f = l;<br><span class="hljs-keyword">double</span> d = f;<br>System.out.println(d);<br><br><span class="hljs-comment">//输出 9.0</span><br></code></pre></td></tr></table></figure><h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><p>显示类型转换也叫做强制类型转换，也就是说，违反隐式转换的规则，牺牲精度强行进行类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">128</span>;<br><span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>)i;<br>System.out.println(b);<br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">128</span>;<br><span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>)i;<br>System.out.println(b);<br><br><span class="hljs-comment">//输出 -128</span><br></code></pre></td></tr></table></figure><p>为什么结果是-128？精度丢失了！</p><ul><li>int 类型的128表示：00000000 00000000 00000000 10000000</li><li>byte类型转换后表示：xxxxxxxx xxxxxxxx xxxxxxxx 10000000 =&gt; -128</li></ul><h3 id="数据类型自动提升"><a href="#数据类型自动提升" class="headerlink" title="数据类型自动提升"></a>数据类型自动提升</h3><p>在参与运算时（也可以位于表达式中时，自增自减除外），所有的byte型、short型和char的值将被提升到int型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">105</span>;<br>b = b + <span class="hljs-number">1</span>;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">105</span>;<br>b = b + <span class="hljs-number">1</span>;   <span class="hljs-comment">//报错！</span><br>System.out.println(b);<br></code></pre></td></tr></table></figure><p>这个特性是由 <strong>Java虚拟机规范</strong> 定义的，也是为了提高运行的效率。其他的特性还有：</p><ul><li>如果一个操作数是long型，计算结果就是long型</li><li>如果一个操作数是float型，计算结果就是float型</li><li>如果一个操作数是double型，计算结果就是double型</li></ul><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值和算术运算符"><a href="#赋值和算术运算符" class="headerlink" title="赋值和算术运算符"></a>赋值和算术运算符</h3><p>赋值运算符<code>=</code>是最常用的运算符，其实就是将我们等号右边的结果，传递给等号左边的变量，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span> + <span class="hljs-number">8</span>;<br><span class="hljs-keyword">int</span> c = <span class="hljs-number">5</span> * <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span> + <span class="hljs-number">8</span>;<br><span class="hljs-keyword">int</span> c = <span class="hljs-number">5</span> * <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>算术运算符也就是我们在小学阶段学习的<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code>，分别代表加减乘除还有取余，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> c = a * b;<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> c = a * b;<br><span class="hljs-comment">//结果为6</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>+</code>还可以用作字符串连接符使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">System.out.println(<span class="hljs-string">&quot;lbw&quot;</span> + <span class="hljs-string">&quot;nb&quot;</span>);  <span class="hljs-comment"><code class="language-hljs java">System.out.println(<span class="hljs-string">&quot;lbw&quot;</span> + <span class="hljs-string">&quot;nb&quot;</span>);  <span class="hljs-comment">//lbwnb</span><br></code></pre></td></tr></table></figure><p>当然，字符串可以直接连接其他类型，但是会全部当做字符串处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>System.out.println(<span class="hljs-string">&quot;lbw&quot;</span> + a + b); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>System.out.println(<span class="hljs-string">&quot;lbw&quot;</span> + a + b); <span class="hljs-comment">//lbw715</span><br></code></pre></td></tr></table></figure><p>算术运算符还包括<code>++</code>和<code>--</code>也就是自增和自减，以自增为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a++;<br>System.out.println(a); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a++;<br>System.out.println(a); <span class="hljs-comment">//输出为11</span><br></code></pre></td></tr></table></figure><p>自增自减运算符放在变量的前后的返回值是有区别的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(a++);  <span class="hljs-comment">//10 （先返回值，再自增）</span><br>System.out.println(a);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(a++);  <span class="hljs-comment">//10 （先返回值，再自增）</span><br>System.out.println(a);   <span class="hljs-comment">//11</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(++a);  <span class="hljs-comment">//11 （先自增，再返回值）</span><br>System.out.println(a);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(++a);  <span class="hljs-comment">//11 （先自增，再返回值）</span><br>System.out.println(a);  <span class="hljs-comment">//11</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>System.out.println(b+++a++);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>System.out.println(b+++a++);  <span class="hljs-comment">//猜猜看结果是多少</span><br></code></pre></td></tr></table></figure><p>为了使得代码更简洁，你还可以使用扩展的赋值运算符，包括<code>+=</code>、<code>-=</code>、<code>/=</code>、<code>*=</code>、<code>%=</code>，和自增自减类似，先执行运算，再返回结果，同时自身改变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(a += <span class="hljs-number">2</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(a += <span class="hljs-number">2</span>);  <span class="hljs-comment">//等价于 a = a + 2</span><br></code></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符的结果只能是布尔类型，也就是要么为真要么为假，关系运算符包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">&gt; &lt; == <span class="hljs-comment">//大于小于等于</span><br>&gt;= &lt;=  !=  <span class="hljs-comment"><code class="language-hljs java">&gt; &lt; == <span class="hljs-comment">//大于小于等于</span><br>&gt;= &lt;=  !=  <span class="hljs-comment">//大于等于，小于等于，不等于</span><br></code></pre></td></tr></table></figure><p>关系运算符一般只用于基本类型的比较，运算结果只能是boolean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b;<br>System.out.println(x);<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b;<br>System.out.println(x);<br><span class="hljs-comment">//结果为 true</span><br></code></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符两边只能是boolean类型或是关系/逻辑运算表达式，返回值只能是boolean类型！逻辑运算符包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java">&amp;&amp; <span class="hljs-comment">//与运算，要求两边同时为true才能返回true</span><br>|| <span class="hljs-comment">//或运算，要求两边至少要有一个为true才能返回true</span><br>! <span class="hljs-comment"><code class="language-hljs java">&amp;&amp; <span class="hljs-comment">//与运算，要求两边同时为true才能返回true</span><br>|| <span class="hljs-comment">//或运算，要求两边至少要有一个为true才能返回true</span><br>! <span class="hljs-comment">//非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转</span><br></code></pre></td></tr></table></figure><p>实际案例来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b &amp;&amp; a &lt; b;  <span class="hljs-comment">//怎么可能同时满足呢</span><br>System.out.println(x);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b &amp;&amp; a &lt; b;  <span class="hljs-comment">//怎么可能同时满足呢</span><br>System.out.println(x);   <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b || a &lt;= b;  <span class="hljs-comment">//一定有一个满足！</span><br>System.out.println(x);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b || a &lt;= b;  <span class="hljs-comment">//一定有一个满足！</span><br>System.out.println(x);   <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = !(a &gt; b); <span class="hljs-comment">//对结果进行反转，本来应该是true</span><br>System.out.println(x); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = !(a &gt; b); <span class="hljs-comment">//对结果进行反转，本来应该是true</span><br>System.out.println(x); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">&amp; <span class="hljs-comment">//按位与，注意，返回的是运算后的同类型值，不是boolean！</span><br>| <span class="hljs-comment">//按位或</span><br>^ <span class="hljs-comment">//按位异或 0 ^ 0 = 0</span><br>~ <span class="hljs-comment"><code class="language-hljs java">&amp; <span class="hljs-comment">//按位与，注意，返回的是运算后的同类型值，不是boolean！</span><br>| <span class="hljs-comment">//按位或</span><br>^ <span class="hljs-comment">//按位异或 0 ^ 0 = 0</span><br>~ <span class="hljs-comment">//按位非</span><br></code></pre></td></tr></table></figure><p>按位运算实际上是根据值的二进制编码来计算结果，例如按位与，以4bit为例：</p><p>0101 &amp; 0100 = 0100 （只有同时为1对应位才得1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>System.out.println(a &amp; b); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>System.out.println(a &amp; b); <span class="hljs-comment">//结果为7</span><br></code></pre></td></tr></table></figure><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>三目运算符其实是为了简化代码而生，可以根据条件是否满足来决定返回值，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>String str = a &gt; b ? <span class="hljs-string">&quot;行&quot;</span> : <span class="hljs-string">&quot;不行&quot;</span>;  <span class="hljs-comment">// 判断条件(只能是boolean,或返回boolean的表达式) ? 满足的返回值 : 不满足的返回值 </span><br>System.out.println(<span class="hljs-string">&quot;汉堡做的行不行？&quot;</span>+str);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>String str = a &gt; b ? <span class="hljs-string">&quot;行&quot;</span> : <span class="hljs-string">&quot;不行&quot;</span>;  <span class="hljs-comment">// 判断条件(只能是boolean,或返回boolean的表达式) ? 满足的返回值 : 不满足的返回值 </span><br>System.out.println(<span class="hljs-string">&quot;汉堡做的行不行？&quot;</span>+str);  <span class="hljs-comment">//汉堡做的行不行？不行</span><br></code></pre></td></tr></table></figure><p>理解三目运算符，就很容易理解后面的if-else语句了。</p><hr><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来帮我进行更灵活的控制。比如，判断用户输入的数字，大于1则输出ok，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！</p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>选择结构包含if和switch类型，选择结构能够帮助我们根据条件判断，再执行哪一块代码。</p><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>就像上面所说，判断用户输入的数字，大于1则输出ok，小于1则输出no，要实现这种效果，我们首先可以采用if语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">if</span>(判断条件)&#123;<br>  <span class="hljs-comment">//判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">//判断失败执行的内容</span><br>&#125;<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">if</span>(判断条件)&#123;<br>  <span class="hljs-comment">//判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">//判断失败执行的内容</span><br>&#125;<br><span class="hljs-comment">//if的内容执行完成后，后面的内容正常执行</span><br></code></pre></td></tr></table></figure><p>其中，<code>else</code>语句不是必须的。</p><p>现在，又来了一个新的需求，用户输入的是1打印ok，输入2，打印yes，其他打印no，那么这样就需要我们进行多种条件的判断了，当然if能进行多分支判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">//判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-comment">//再次判断，如果判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">//判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-comment">//再次判断，如果判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">//上面的都没成功，只能走这里</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样，<code>else</code>语句不是必须的。</p><p>现在，又来了一个新的需求，用户输入1之后，在判断用户下一次输入的是什么，如果是1，打印yes，不是就打印no，这样就可以用嵌套if了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">//前提是判断条件1要成功才能进来！</span><br>  <span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-comment">//判断成功执行的内容</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">//前提是判断条件1要成功才能进来！</span><br>  <span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-comment">//判断成功执行的内容</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//判断失败执行的内容</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>我们不难发现，虽然<code>else-if</code>能解决多分支判断的问题，但是效率实在是太低了，多分支if采用的是逐级向下判断，显然费时费力，那么有没有一直更专业的解决多分支判断问题的东西呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">switch</span>(判断主体)&#123;<br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//break用于跳出switch语句，不添加会导致程序继续向下运行！</span><br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">3</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">switch</span>(判断主体)&#123;<br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//break用于跳出switch语句，不添加会导致程序继续向下运行！</span><br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">3</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述语句中，只有判断主体等于case后面的值时，才会执行case中的语句，同时需要使用break来跳出switch语句，否则会继续向下运行！</p><p>为什么switch效率更高呢，因为switch采用二分思想进行查找（这也是为什么switch只能判断值相等的原因），能够更快地找到我们想要的结果！</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>小明想向小红表白，于是他在屏幕上打印了520个 “我爱你”，我们用Java该如何实现呢？</p><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p>for语句是比较灵活的循环控制语句，一个for语句的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">for</span>(初始条件;循环条件;更新)&#123;<br>  <span class="hljs-comment">//循环执行的内容</span><br>&#125;<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">for</span>(初始条件;循环条件;更新)&#123;<br>  <span class="hljs-comment">//循环执行的内容</span><br>&#125;<br><span class="hljs-comment">//循环结束后，继续执行</span><br></code></pre></td></tr></table></figure><ul><li>初始条件：循环开始时的条件，一般用于定义控制循环的变量。</li><li>循环条件：每轮循环开始之前，进行一次判断，如果满足则继续，不满足则结束，要求为boolean变量或是boolean表达式。</li><li>更新：每轮循环结束后都会执行的内容，一般写增量表达式。</li></ul><p>初始条件、循环条件、更新条件不是缺一不可，甚至可以都缺！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">520</span>;i++)&#123;<br>  System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">520</span>;i++)&#123;<br>  System.out.println(<span class="hljs-string">"我爱你"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>  <span class="hljs-comment">//这里的内容将会永远地进行下去！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>增强for循环在数组时再讲解！</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while循环和for循环类似，但是它更加的简单，只需要添加维持循环的判断条件即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">while</span>(循环条件)&#123;<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">while</span>(循环条件)&#123;<br>  <span class="hljs-comment">//循环执行的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>和for一样，每次循环开始，当循环条件不满足时，自动退出！那么有时候我们希望先执行了我们的代码再去判断怎么办呢，我们可以使用do-while语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">do</span>&#123;<br>  <span class="hljs-comment">//执行内容</span><br>&#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">do</span>&#123;<br>  <span class="hljs-comment">//执行内容</span><br>&#125;<span class="hljs-keyword">while</span>(循环条件);<br></code></pre></td></tr></table></figure><p>一定会先执行do里面的内容，再做判断！</p><p>思考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>  <br>&#125;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>  <br>&#125;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//它们的性能谁更高？</span><br></code></pre></td></tr></table></figure><hr><h2 id="面向过程编程实战（基础-算法）"><a href="#面向过程编程实战（基础-算法）" class="headerlink" title="面向过程编程实战（基础+算法）"></a>面向过程编程实战（基础+算法）</h2><h3 id="打印九九乘法表"><a href="#打印九九乘法表" class="headerlink" title="打印九九乘法表"></a>打印九九乘法表</h3><p>简单：将九九乘法表打印到控制台。</p><h3 id="求1000以内的水仙花数"><a href="#求1000以内的水仙花数" class="headerlink" title="求1000以内的水仙花数"></a>求1000以内的水仙花数</h3><p>中等：打印1000以内所有满足水仙花的数，“水仙花数”是指一个三位数其各位数字的立方和等于该数本身，例如153是“水仙花数”，因为：153 = 1^3 + 5^3 + 3^3</p><h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><p>困难：一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？例如n=2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。</p><p>动态规划：其实，就是利用，上次得到的结果，给下一次作参考，下一次就能利用上次的结果快速得到结果，依次类推</p><hr><p>不对啊，别的教程都讲了数组、方法，怎么我们还没讲就进入面向对象了呢？</p><ul><li>数组在Java中，并非基本类型，数组是编程不可见的对象类型，学习了面向对象再来理解，会更加容易！</li><li>方法在Java中是类具有的属性，所以，在了解了对象类型之后，再来了解方法，就更加简单了！</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring/SpringBoot常用注解</title>
    <link href="/2021/11/29/40566.html/"/>
    <url>/2021/11/29/40566.html/</url>
    
    <content type="html"><![CDATA[<h4 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1.@SpringBootApplication"></a>1.@SpringBootApplication</h4><span id="more"></span><p>可以把 @SpringBootApplication看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。</p><h4 id="2-Spring-Bean相关"><a href="#2-Spring-Bean相关" class="headerlink" title="2.Spring Bean相关"></a>2.Spring Bean相关</h4><h5 id="2-1-Autowired"><a href="#2-1-Autowired" class="headerlink" title="2.1 @Autowired"></a>2.1 @Autowired</h5><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理。</p><h5 id="2-2-Component-Repository-Service-Controller"><a href="#2-2-Component-Repository-Service-Controller" class="headerlink" title="2.2 @Component,@Repository,@Service, @Controller"></a>2.2 @Component,@Repository,@Service, @Controller</h5><p>我们一般使用 @Autowired 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,可以采用以下注解实现：<br>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。<br>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。<br>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。<br>@Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</p>]]></content>
    
    
    <categories>
      
      <category>Spring/SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot_tm表结构设计</title>
    <link href="/2021/11/19/27267.html/"/>
    <url>/2021/11/19/27267.html/</url>
    
    <content type="html"><![CDATA[<h2 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h2><span id="more"></span><h3 id="建表顺序"><a href="#建表顺序" class="headerlink" title="建表顺序"></a>建表顺序</h3><p>在建表过程中，会设置外键约束，所以表和表之间有依赖关系。 因此会先建立被外键指向的表，比如User,Category，然后再是其他表</p><h4 id="1-用户表"><a href="#1-用户表" class="headerlink" title="1.用户表"></a>1.用户表</h4><p>salt 是盐，用来和 shiro 结合的时候，加密用的</p><blockquote><p>CREATE TABLE user (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   name varchar(255) DEFAULT NULL,<br>   password varchar(255) DEFAULT NULL,<br>   salt varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id)<br> ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></blockquote><h4 id="2-分类表"><a href="#2-分类表" class="headerlink" title="2.分类表"></a>2.分类表</h4><blockquote><p>CREATE TABLE category (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   name varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote><h4 id="3-属性表"><a href="#3-属性表" class="headerlink" title="3.属性表"></a>3.属性表</h4><p>从这个表开始， 就有外键约束了。<br>本表的外键cid，指向分类表的id字段</p><blockquote><p>CREATE TABLE property (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   cid int(11) DEFAULT NULL,<br>   name varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_property_category FOREIGN KEY (cid) REFERENCES category (id)<br> ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></blockquote><h4 id="4-产品表"><a href="#4-产品表" class="headerlink" title="4.产品表"></a>4.产品表</h4><p>产品表字段稍多，讲解一下<br>name: 产品名称<br>subTitle: 小标题<br>originalPrice: 原始价格<br>promotePrice: 优惠价格<br>stock: 库存<br>createDate: 创建日期</p><p>本表的外键cid，指向分类表的id字段</p><blockquote><p>CREATE TABLE product (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   name varchar(255) DEFAULT NULL,<br>   subTitle varchar(255) DEFAULT NULL,<br>   originalPrice float DEFAULT NULL,<br>   promotePrice float DEFAULT NULL,<br>   stock int(11) DEFAULT NULL,<br>   cid int(11) DEFAULT NULL,<br>   createDate datetime DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_product_category FOREIGN KEY (cid) REFERENCES category (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote><h4 id="5-属性值表"><a href="#5-属性值表" class="headerlink" title="5.属性值表"></a>5.属性值表</h4><p>本表有两个外键<br>外键ptid，指向属性表的id字段<br>外键pid，指向产品表的id字段</p><blockquote><p>CREATE TABLE propertyvalue (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   pid int(11) DEFAULT NULL,<br>   ptid int(11) DEFAULT NULL,<br>   value varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_propertyvalue_property FOREIGN KEY (ptid) REFERENCES property (id),<br>   CONSTRAINT fk_propertyvalue_product FOREIGN KEY (pid) REFERENCES product (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote><h4 id="6-产品图片表"><a href="#6-产品图片表" class="headerlink" title="6.产品图片表"></a>6.产品图片表</h4><p>type表示类型，产品图片分单个图片和详情图片两种</p><p>本表的外键pid，指向产品表的id字段</p><blockquote><p>CREATE TABLE productimage (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   pid int(11) DEFAULT NULL,<br>   type varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_productimage_product FOREIGN KEY (pid) REFERENCES product (id)<br> ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></blockquote><h4 id="7-评价表"><a href="#7-评价表" class="headerlink" title="7.评价表"></a>7.评价表</h4><p>外键pid，指向产品表的id字段<br>外键uid，指向用户表的id字段</p><blockquote><p>CREATE TABLE review (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   content varchar(4000) DEFAULT NULL,<br>   uid int(11) DEFAULT NULL,<br>   pid int(11) DEFAULT NULL,<br>   createDate datetime DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_review_product FOREIGN KEY (pid) REFERENCES product (id),<br>     CONSTRAINT fk_review_user FOREIGN KEY (uid) REFERENCES user (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote><h4 id="8-订单表"><a href="#8-订单表" class="headerlink" title="8.订单表"></a>8.订单表</h4><p>订单表的字段也比较多，讲解一下：<br>orderCode： 订单号<br>address:收货地址<br>post: 邮编<br>receiver: 收货人信息<br>mobile: 手机号码<br>userMessage: 用户备注信息<br>createDate: 订单创建日期<br>payDate: 支付日期<br>deliveryDate: 发货日期<br>confirmDate：确认收货日期<br>status: 订单状态<br>外键uid，指向用户表id字段</p><blockquote><p>CREATE TABLE order_ (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   orderCode varchar(255) DEFAULT NULL,<br>   address varchar(255) DEFAULT NULL,<br>   post varchar(255) DEFAULT NULL,<br>   receiver varchar(255) DEFAULT NULL,<br>   mobile varchar(255) DEFAULT NULL,<br>   userMessage varchar(255) DEFAULT NULL,<br>   createDate datetime DEFAULT NULL,<br>   payDate datetime DEFAULT NULL,<br>   deliveryDate datetime DEFAULT NULL,<br>   confirmDate datetime DEFAULT NULL,<br>   uid int(11) DEFAULT NULL,<br>   status varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_order_user FOREIGN KEY (uid) REFERENCES user (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote><h4 id="9-订单项表"><a href="#9-订单项表" class="headerlink" title="9.订单项表"></a>9.订单项表</h4><p>这个表是外键最多的一个表<br>外键pid，指向产品表id字段<br>外键oid，指向订单表id字段<br>外键uid，指向用户表id字段<br>number字段表示购买数量</p><blockquote><p>CREATE TABLE orderitem (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   pid int(11) DEFAULT NULL,<br>   oid int(11) DEFAULT NULL,<br>   uid int(11) DEFAULT NULL,<br>   number int(11) DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_orderitem_user FOREIGN KEY (uid) REFERENCES user (id),<br>   CONSTRAINT fk_orderitem_product FOREIGN KEY (pid) REFERENCES product (id),<br>   CONSTRAINT fk_orderitem_order FOREIGN KEY (oid) REFERENCES order_ (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Doc</title>
    <link href="/2021/11/17/52269.html/"/>
    <url>/2021/11/17/52269.html/</url>
    
    <content type="html"><![CDATA[<h1 id="notes"><a href="#notes" class="headerlink" title="notes"></a>notes</h1><span id="more"></span><h1 id="1-张志虎-测向交叉定位体制下平台航迹最优规划算法"><a href="#1-张志虎-测向交叉定位体制下平台航迹最优规划算法" class="headerlink" title="1.张志虎 测向交叉定位体制下平台航迹最优规划算法"></a>1.张志虎 测向交叉定位体制下平台航迹最优规划算法</h1><h3 id="可观测性-最优航路算法-精度几何散布-最优航迹规划"><a href="#可观测性-最优航路算法-精度几何散布-最优航迹规划" class="headerlink" title="可观测性; 最优航路算法; 精度几何散布; 最优航迹规划"></a>可观测性; 最优航路算法; 精度几何散布; 最优航迹规划</h3><p>单站被动雷达由于可观测性较弱，对其进行航迹优化可以提高系统可观测性。给出无限制条件下的最优航<br>路算法，以最小化克劳美劳下界的迹即精度几何散布作为航路优化的性能指标，针对实际环境，又研究只采取 180°转<br>弯条件下的时长已知和未知两种环境下的最优航迹规划算法，给出了最优的航路规划，同时给出不同情景下的跟误差。</p><h1 id="2-张君君-对固定辐射源的多站无源定位研究"><a href="#2-张君君-对固定辐射源的多站无源定位研究" class="headerlink" title="2.张君君 对固定辐射源的多站无源定位研究"></a>2.张君君 对固定辐射源的多站无源定位研究</h1><h3 id="无源定位-运动多站-精度分析-布站优化-布谷鸟搜索算法"><a href="#无源定位-运动多站-精度分析-布站优化-布谷鸟搜索算法" class="headerlink" title="无源定位 运动多站 精度分析 布站优化 布谷鸟搜索算法"></a>无源定位 运动多站 精度分析 布站优化 布谷鸟搜索算法</h3><p>无源定位是一门相对独立的定位技术，既可以作为一种辐射源位置获取的重要手<br>段，也可以用作许多有源探测定位系统的补充。无源定位具有不同于雷达的多种优势，<br>因此受到世界各国的青睐。<br>多站无源定位相比单站无源定位具有容错率高，可利用的<br>数据多等特点，但是对各定位站的协同工作能力具有较高的要求。目前对多站无源定<br>位的研究主要集中在协同信号处理、定位算法、定位精度分析、布站优化等方面。而<br>这些都是围绕如何提高无源定位系统的性能来展开的。<br>本文首先介绍了几种常见的多站无源定位体制，分别对测向交叉法、无源时差法、<br>无源频差法以及多站联合定位法的基本定位原理做了研究。<br>然后以多站无源定位体制为基础，研究了运动多站对固定目标辐射源的定位算法<br>和定位精度。详细推导了运动多站无源频差定位和空间四站时差定位的定位方程以及<br>定位精度公式，并进行实验仿真做出了相应的结果对比，分析了各测量参数对定位精<br>度的影响。在进行运动双站时差/频差联合定位的相关研究时，除了对定位精度进行<br>分析外，针对定位方程中存在非线性方程求解复杂的问题，在对差分进化算法和牛顿<br>迭代法研究后，提出了基于差分进化算法和牛顿迭代法的目标位置求解模型，实现了<br>对目标位置的精确估计。实验表明该方法具有良好的性能以及不需要提供迭代初始点<br>等优点。<br>最后针对无源定位在应用中常见的布站优化问题，以空间四站时差定位体制为应<br>用背景，先是研究并仿真了几种常见布站构型的定位精度和适用场景，然后基于最优<br>化理论，提出了基于布谷鸟搜索算法的无源定位布站优化方法。通过与使用差分进化<br>算法的仿真结果进行对比，验证了该算法切实可行，而且还具有更好的收敛速度。</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote><p>第一章 绪论</p><blockquote><p>研究背景及意义<br>多站无源定位技术的研究现状<br>论文主要研究内容  </p></blockquote></blockquote><blockquote><p>第二章 多站无源定位体制</p><blockquote><p>1 引言<br>2 测向交叉法    </p><blockquote><p>2.1 双站测向交叉定位<br>2.2 基于 SWLS 的测向交叉定位  </p></blockquote></blockquote></blockquote><blockquote><blockquote><p>3 无源时差定位法<br>4 无源频差定位法<br>5 多站联合定位法</p><blockquote><p>5.1 测向/时差联合定位<br>5.2时差/频差联合定位  </p></blockquote></blockquote></blockquote><blockquote><blockquote><p>6 小结</p></blockquote></blockquote><blockquote><p>第三章 运动多站无源定位算法及精度分析  </p><blockquote><p>1 引言<br>2 运动多站对固定目标的无源频差定位    </p><blockquote><p>2.1 基本原理及目标位置求解<br>2.2 多普勒频差曲线精度推导<br>2.3 多普勒频差曲线分布仿真分析</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>3 空间四站时差定位原理<br>4 运动双站时差/频差联合定位<br>5 小结</p></blockquote></blockquote><blockquote><p>第四章 多站无源定位布站优化</p><blockquote><p>1 引言<br>2 布站方式对定位精度的影响<br>3 多站无源定位布站的最优化问题  </p><blockquote><p>3.1 最优化问题<br>3.2 多站无源定位布站的最优化问题描述</p></blockquote></blockquote><blockquote><p>4 基于差分进化算法的布站优化<br>5 基于布谷鸟搜索算法的布站优化</p><blockquote><p>5.1 基于布谷鸟搜索算法的布站优化原理<br>5.2 仿真分析  </p></blockquote></blockquote></blockquote><blockquote><blockquote><p>6 小结  </p></blockquote><p>第五章 总结与展望</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>“spring整合redis”</title>
    <link href="/2021/11/16/47151.html/"/>
    <url>/2021/11/16/47151.html/</url>
    
    <content type="html"><![CDATA[<h1 id="spring整合redis"><a href="#spring整合redis" class="headerlink" title="spring整合redis"></a>spring整合redis</h1><hr><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.搭建SpringBoot工程</p><p>2.引入redis起步依赖</p><p>3.配置redis相关属性</p><p>4.注入RedisTemplate模板</p><p>5.编写测试方法，测试</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2021/11/15/63785.html/"/>
    <url>/2021/11/15/63785.html/</url>
    
    <content type="html"><![CDATA[<h1 id="我的博客"><a href="#我的博客" class="headerlink" title="我的博客"></a>我的博客</h1><span id="more"></span><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用标题时需要使用#</p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>这是第一个段落内容</p><p>这是第二个段落内容</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><blockquote><p>这是一段引用段落将会被高亮显示</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>[百度] (<a href="https://www.baidu.com/?tn=44004473_27_oem_dg">https://www.baidu.com/?tn=44004473_27_oem_dg</a>)</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>![风景]（<a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg38.51tietu.net%2Fpic%2F2017-010520%2F20170105204459da41352i05a51903.jpg&amp;refer=http%3A%2F%2Fimg38.51tietu.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639553891&amp;t=0db40b6436229ffd99cd448638031620%EF%BC%89">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg38.51tietu.net%2Fpic%2F2017-010520%2F20170105204459da41352i05a51903.jpg&amp;refer=http%3A%2F%2Fimg38.51tietu.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639553891&amp;t=0db40b6436229ffd99cd448638031620）</a></p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>无序列表项</li><li>无序列表项</li><li>无序列表项<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2></li></ul><ol><li>有序列表项1</li><li>有序列表项2</li><li>有序列表项3<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2></li></ol><hr><hr><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/11/15/16107.html/"/>
    <url>/2021/11/15/16107.html/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash">$ hexo new <span class="hljs-string"><code class="language-hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
