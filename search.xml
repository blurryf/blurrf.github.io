<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/04/13/0.html/"/>
      <url>/2022/04/13/0.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-054d8ff6135b3638aca543eff7424f98_1200x500.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644500043&t=72a4f8ecfca9ff5a2a0b3896edef4be7" alt="点击查看源网页"></p><h1 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><p><strong>灵魂拷问：</strong>不是学了MySQL吗，存数据也能存了啊，又学一个数据库干嘛？</p><p>在前面我们学习了MySQL数据库，它是一种传统的关系型数据库，我们可以使用MySQL来更好地管理和组织我们的数据，虽然在小型Web应用下，只需要一个MySQL+Mybatis自带的缓存系统就可以胜任大部分的数据存储工作。但是MySQL的缺点也很明显，它的数据始终是存储在硬盘上的，对于我们的用户信息这种不需要经常发生修改的内容，使用MySQL存储确实可以，但是如果是快速更新或是频繁使用的数据，比如微博热搜、双十一秒杀，这些数据不仅要求服务器需要提供更高的响应速度，而且还需要面对短时间内上百万甚至上千万次访问，而MySQL的磁盘IO读写性能完全不能满足上面的需求，能够满足上述需求的只有内存，因为速度远高于磁盘IO。</p><p>因此，我们需要寻找一种更好的解决方案，来存储上述这类特殊数据，弥补MySQL的不足，以应对大数据时代的重重考验。</p><h2 id="NoSQL概论"><a href="#NoSQL概论" class="headerlink" title="NoSQL概论"></a>NoSQL概论</h2><p>NoSQL全称是Not Only SQL（不仅仅是SQL）它是一种非关系型数据库，相比传统SQL关系型数据库，它：</p><ul><li>不保证关系数据的ACID特性</li><li>并不遵循SQL标准</li><li>消除数据之间关联性</li></ul><p>乍一看，这玩意不比MySQL垃圾？我们再来看看它的优势：</p><ul><li>远超传统关系型数据库的性能</li><li>非常易于扩展</li><li>数据模型更加灵活</li><li>高可用</li></ul><p>这样，NoSQL的优势一下就出来了，这不就是我们正要寻找的高并发海量数据的解决方案吗！</p><p>NoSQL数据库分为以下几种：</p><ul><li><strong>键值存储数据库：</strong>所有的数据都是以键值方式存储的，类似于我们之前学过的HashMap，使用起来非常简单方便，性能也非常高。</li><li><strong>列存储数据库：</strong>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。</li><li><strong>文档型数据库：</strong>它是以一种特定的文档格式存储数据，比如JSON格式，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。</li><li><strong>图形数据库：</strong>利用类似于图的数据结构存储数据，结合图相关算法实现高速访问。</li></ul><p>其中我们要学习的Redis数据库，就是一个开源的<strong>键值存储数据库</strong>，所有的数据全部存放在内存中，它的性能大大高于磁盘IO，并且它也可以支持数据持久化，他还支持横向扩展、主从复制等。</p><p>实际生产中，我们一般会配合使用Redis和MySQL以发挥它们各自的优势，取长补短。</p><h2 id="Redis安装和部署"><a href="#Redis安装和部署" class="headerlink" title="Redis安装和部署"></a>Redis安装和部署</h2><p>我们这里还是使用Windows安装Redis服务器，但是官方指定是安装到Linux服务器上，我们后面学习了Linux之后，再来安装到Linux服务器上。由于官方并没有提供Windows版本的安装包，我们需要另外寻找：</p><ul><li>官网地址：<a href="https://redis.io/">https://redis.io</a></li><li>GitHub Windows版本维护地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></li></ul><hr><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>在我们之前使用MySQL时，我们需要先在数据库中创建一张表，并定义好表的每个字段内容，最后再通过<code>insert</code>语句向表中添加数据，而Redis并不具有MySQL那样的严格的表结构，Redis是一个键值数据库，因此，可以像Map一样的操作方式，通过键值对向Redis数据库中添加数据（操作起来类似于向一个HashMap中存放数据）</p><p>在Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。 默认情况下，我们连接Redis数据库之后，会使用0号数据库，我们可以通过Redis配置文件中的参数来修改数据库总数，默认为16个。</p><p>我们可以通过<code>select</code>语句进行切换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">select</span> 序号;<br></code></pre></td></tr></table></figure><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><p>我们来看看，如何向Redis数据库中添加数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 一次性多个</span><br>mset [<span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 一次性多个</span><br>mset [<span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">></span>]...<br></code></pre></td></tr></table></figure><p>所有存入的数据默认会以<strong>字符串</strong>的形式保存，键值具有一定的命名规范，以方便我们可以快速定位我们的数据属于哪一个部分，比如用户的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 使用冒号来进行板块分割，比如下面表示用户XXX的信息中的name属性，值为lbw</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 使用冒号来进行板块分割，比如下面表示用户XXX的信息中的name属性，值为lbw</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">user</span>:info:用户ID:name lbw<br></code></pre></td></tr></table></figure><p>我们可以通过键值获取存入的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">get</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-keyword">get</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>你以为Redis就仅仅只是存取个数据吗？它还支持数据的过期时间设定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> EX 秒<br><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> EX 秒<br><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">></span> PX 毫秒<br></code></pre></td></tr></table></figure><p>当数据到达指定时间时，会被自动删除。我们也可以单独为其他的键值对设置过期时间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">expire <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql">expire <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span> 秒<br></code></pre></td></tr></table></figure><p>通过下面的命令来查询某个键值对的过期时间还剩多少：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs sql">ttl <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 毫秒显示</span><br>pttl <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 转换为永久</span><br>persist <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql">ttl <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 毫秒显示</span><br>pttl <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 转换为永久</span><br>persist <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>那么当我们想直接删除这个数据时呢？直接使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">del <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql">del <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span>...<br></code></pre></td></tr></table></figure><p>删除命令可以同时拼接多个键值一起删除。</p><p>当我们想要查看数据库中所有的键值时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">keys <span class="hljs-operator"><code class="language-hljs sql">keys <span class="hljs-operator">*</span><br></code></pre></td></tr></table></figure><p>也可以查询某个键是否存在：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">exists</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-keyword">exists</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span>...<br></code></pre></td></tr></table></figure><p>还可以随机拿一个键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><code class="language-hljs sql">randomkey<br></code></pre></td></tr></table></figure><p>我们可以将一个数据库中的内容移动到另一个数据库中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">move <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql">move <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span> 数据库序号<br></code></pre></td></tr></table></figure><p>修改一个键为另一个键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sql">rename <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>新的名称<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 下面这个会检查新的名称是否已经存在</span><br>renamex <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>新的名称<span class="hljs-operator"><code class="language-hljs sql">rename <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>新的名称<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 下面这个会检查新的名称是否已经存在</span><br>renamex <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>新的名称<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>如果存放的数据是一个数字，我们还可以对其进行自增自减操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 等价于a = a + 1</span><br>incr <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 等价于a = a + b</span><br>incrby <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> b<br><span class="hljs-comment">-- 等价于a = a - 1</span><br>decr <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-comment">-- 等价于a = a + 1</span><br>incr <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 等价于a = a + b</span><br>incrby <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> b<br><span class="hljs-comment">-- 等价于a = a - 1</span><br>decr <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>最后就是查看值的数据类型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">type <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql">type <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>Redis数据库也支持多种数据类型，但是它更偏向于我们在Java中认识的那些数据类型。</p><h2 id="数据类型介绍"><a href="#数据类型介绍" class="headerlink" title="数据类型介绍"></a>数据类型介绍</h2><p>一个键值对除了存储一个String类型的值以外，还支持多种常用的数据类型。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>这种类型本质上就是一个HashMap，也就是嵌套了一个HashMap罢了，在Java中就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">#Redis默认存String类似于这样：<br>Map&lt;String, String&gt; hash = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>#Redis存Hash类型的数据类似于这样：<br>Map&lt;String, Map&lt;String, String&gt;&gt; hash = <span class="hljs-keyword"><code class="language-hljs java">#Redis默认存String类似于这样：<br>Map&lt;String, String&gt; hash = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>#Redis存Hash类型的数据类似于这样：<br>Map&lt;String, Map&lt;String, String&gt;&gt; hash = <span class="hljs-keyword">new</span> HashMap<>();<br></code></pre></td></tr></table></figure><p>它比较适合存储类这样的数据，由于值本身又是一个Map，因此我们可以在此Map中放入类的各种属性和值，以实现一个Hash数据类型存储一个类的数据。</p><p>我们可以像这样来添加一个Hash类型的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">hset <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>值<span class="hljs-operator"><code class="language-hljs sql">hset <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>值<span class="hljs-operator">></span>]...<br></code></pre></td></tr></table></figure><p>我们可以直接获取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sql">hget <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 如果想要一次性获取所有的字段和值</span><br>hgetall <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql">hget <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 如果想要一次性获取所有的字段和值</span><br>hgetall <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>同样的，我们也可以判断某个字段是否存在：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">hexists <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>字段<span class="hljs-operator"><code class="language-hljs sql">hexists <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>删除Hash中的某个字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">hdel <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql">hdel <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>我们发现，在操作一个Hash时，实际上就是我们普通操作命令前面添加一个<code>h</code>，这样就能以同样的方式去操作Hash里面存放的键值对了，这里就不一一列出所有的操作了。我们来看看几个比较特殊的。</p><p>我们现在想要知道Hash中一共存了多少个键值对：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">hlen <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql">hlen <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>我们也可以一次性获取所有字段的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">hvals <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql">hvals <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>唯一需要注意的是，Hash中只能存放字符串值，不允许出现嵌套的的情况。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>我们接着来看List类型，实际上这个猜都知道，它就是一个列表，而列表中存放一系列的字符串，它支持随机访问，支持双端操作，就像我们使用Java中的LinkedList一样。</p><p>我们可以直接向一个已存在或是不存在的List中添加数据，如果不存在，会自动创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 向列表头部添加元素</span><br>lpush <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 向列表尾部添加元素</span><br>rpush <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 在指定元素前面/后面插入元素</span><br>linsert <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> before<span class="hljs-operator">/</span>after <span class="hljs-operator">&lt;</span>指定元素<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-comment">-- 向列表头部添加元素</span><br>lpush <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 向列表尾部添加元素</span><br>rpush <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 在指定元素前面/后面插入元素</span><br>linsert <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> before<span class="hljs-operator">/</span>after <span class="hljs-operator">&lt;</span>指定元素<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>同样的，获取元素也非常简单：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 根据下标获取元素</span><br>lindex <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>下标<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取并移除头部元素</span><br>lpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取并移除尾部元素</span><br>rpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取指定范围内的</span><br>lrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 根据下标获取元素</span><br>lindex <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>下标<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取并移除头部元素</span><br>lpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取并移除尾部元素</span><br>rpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取指定范围内的</span><br>lrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> stop<br></code></pre></td></tr></table></figure><p>注意下标可以使用负数来表示从后到前数的数字（Python：搁这儿抄呢是吧）:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 获取列表a中的全部元素</span><br>lrange a <span class="hljs-number">0</span> <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-comment">-- 获取列表a中的全部元素</span><br>lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p>没想到吧，push和pop还能连着用呢：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment"><code class="language-hljs sql"><span class="hljs-comment">-- 从前一个数组的最后取一个数出来放到另一个数组的头部，并返回元素</span><br>rpoplpush 当前数组 目标数组<br></code></pre></td></tr></table></figure><p>它还支持阻塞操作，类似于生产者和消费者，比如我们想要等待列表中有了数据后再进行pop操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 如果列表中没有元素，那么就等待，如果指定时间（秒）内被添加了数据，那么就执行pop操作，如果超时就作废，支持同时等待多个列表，只要其中一个列表有元素了，那么就能执行</span><br>blpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-comment">-- 如果列表中没有元素，那么就等待，如果指定时间（秒）内被添加了数据，那么就执行pop操作，如果超时就作废，支持同时等待多个列表，只要其中一个列表有元素了，那么就能执行</span><br>blpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span>... timeout<br></code></pre></td></tr></table></figure><h3 id="Set和SortedSet"><a href="#Set和SortedSet" class="headerlink" title="Set和SortedSet"></a>Set和SortedSet</h3><p>Set集合其实就像Java中的HashSet一样（我们在JavaSE中已经讲解过了，HashSet本质上就是利用了一个HashMap，但是Value都是固定对象，仅仅是Key不同）它不允许出现重复元素，不支持随机访问，但是能够利用Hash表提供极高的查找效率。</p><p>向Set中添加一个或多个值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">sadd <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator"><code class="language-hljs sql">sadd <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">></span>...<br></code></pre></td></tr></table></figure><p>查看Set集合中有多少个值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">scard <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql">scard <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>判断集合中是否包含：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 是否包含指定值</span><br>sismember <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 列出所有值</span><br>smembers <span class="hljs-operator">&lt;</span>key<span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-comment">-- 是否包含指定值</span><br>sismember <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 列出所有值</span><br>smembers <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>集合之间的运算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 集合之间的差集</span><br>sdiff <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 集合之间的交集</span><br>sinter <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 求并集</span><br>sunion <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 将集合之间的差集存到目标集合中</span><br>sdiffstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 同上</span><br>sinterstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 同上</span><br>sunionstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-comment">-- 集合之间的差集</span><br>sdiff <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 集合之间的交集</span><br>sinter <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 求并集</span><br>sunion <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 将集合之间的差集存到目标集合中</span><br>sdiffstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 同上</span><br>sinterstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 同上</span><br>sunionstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p>移动指定值到另一个集合中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">smove <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> 目标 <span class="hljs-keyword"><code class="language-hljs sql">smove <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> 目标 <span class="hljs-keyword">value</span> <br></code></pre></td></tr></table></figure><p>移除操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 随机移除一个幸运儿</span><br>spop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 移除指定</span><br>srem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-comment">-- 随机移除一个幸运儿</span><br>spop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 移除指定</span><br>srem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">></span>...<br></code></pre></td></tr></table></figure><p>那么如果我们要求Set集合中的数据按照我们指定的顺序进行排列怎么办呢？这时就可以使用SortedSet，它支持我们为每个值设定一个分数，分数的大小决定了值的位置，所以它是有序的。</p><p>我们可以添加一个带分数的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">zadd <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>score<span class="hljs-operator"><code class="language-hljs sql">zadd <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>score<span class="hljs-operator">></span>]...<br></code></pre></td></tr></table></figure><p>同样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 查询有多少个值</span><br>zcard <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 移除</span><br>zrem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 获取区间内的所有</span><br>zrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 查询有多少个值</span><br>zcard <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 移除</span><br>zrem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 获取区间内的所有</span><br>zrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> stop<br></code></pre></td></tr></table></figure><p>由于所有的值都有一个分数，我们也可以根据分数段来获取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 通过分数段查看</span><br>zrangebyscore <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> stop [withscores] [limit]<br><span class="hljs-comment">-- 统计分数段内的数量</span><br>zcount <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">start</span> stop<br><span class="hljs-comment">-- 根据分数获取指定值的排名</span><br>zrank <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-comment">-- 通过分数段查看</span><br>zrangebyscore <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> stop [withscores] [limit]<br><span class="hljs-comment">-- 统计分数段内的数量</span><br>zcount <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">start</span> stop<br><span class="hljs-comment">-- 根据分数获取指定值的排名</span><br>zrank <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">></span><br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/32b9fe8c20e1">https://www.jianshu.com/p/32b9fe8c20e1</a></p><p>有关Bitmap、HyperLogLog和Geospatial等数据类型，这里暂时不做介绍，感兴趣可以自行了解。</p><hr><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>我们知道，Redis数据库中的数据都是存放在内存中，虽然很高效，但是这样存在一个非常严重的问题，如果突然停电，那我们的数据不就全部丢失了吗？它不像硬盘上的数据，断电依然能够保存。</p><p>这个时候我们就需要持久化，我们需要将我们的数据备份到硬盘上，防止断电或是机器故障导致的数据丢失。</p><p>持久化的实现方式有两种方案：一种是直接保存当前<strong>已经存储的数据</strong>，相当于复制内存中的数据到硬盘上，需要恢复数据时直接读取即可；还有一种就是保存我们存放数据的<strong>所有过程</strong>，需要恢复数据时，只需要将整个过程完整地重演一遍就能保证与之前数据库中的内容一致。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB就是我们所说的第一种解决方案，那么如何将数据保存到本地呢？我们可以使用命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sql">save<br><span class="hljs-comment"><code class="language-hljs sql">save<br><span class="hljs-comment">-- 注意上面这个命令是直接保存，会占用一定的时间，也可以单独开一个子进程后台执行保存</span><br>bgsave<br></code></pre></td></tr></table></figure><p>执行后，会在服务端目录下生成一个dump.rdb文件，而这个文件中就保存了内存中存放的数据，当服务器重启后，会自动加载里面的内容到对应数据库中。保存后我们可以关闭服务器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><code class="language-hljs sql">shutdown<br></code></pre></td></tr></table></figure><p>重启后可以看到数据依然存在。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fqqe2.com%2Fjava%2Fzb_users%2Fupload%2F2020%2F04%2F202004281588086055367603.png&refer=http%3A%2F%2Fqqe2.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644843952&t=ec4cd6eb2c6d47a10aff5b9f264d2f16" alt="点击查看图片来源"></p><p>虽然这种方式非常方便，但是由于会完整复制所有的数据，如果数据库中的数据量比较大，那么复制一次可能就需要花费大量的时间，所以我们可以每隔一段时间自动进行保存；还有就是，如果我们基本上都是在进行读操作，而没有进行写操作，实际上只需要偶尔保存一次即可，因为数据几乎没有怎么变化，可能两次保存的都是一样的数据。</p><p>我们可以在配置文件中设置自动保存，并设定在一段时间内写入多少数据时，执行一次保存操作：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span> # <span class="hljs-number">300</span>秒（<span class="hljs-number">5</span>分钟）内有<span class="hljs-number">10</span>个写入<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span> # <span class="hljs-number">60</span>秒（<span class="hljs-number">1</span>分钟）内有<span class="hljs-number"><code class="language-hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span> # <span class="hljs-number">300</span>秒（<span class="hljs-number">5</span>分钟）内有<span class="hljs-number">10</span>个写入<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span> # <span class="hljs-number">60</span>秒（<span class="hljs-number">1</span>分钟）内有<span class="hljs-number">10000</span>个写入<br></code></pre></td></tr></table></figure><p>配置的save使用的都是bgsave后台执行。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>虽然RDB能够很好地解决数据持久化问题，但是它的缺点也很明显：每次都需要去完整地保存整个数据库中的数据，同时后台保存过程中也会产生额外的内存开销，最严重的是它并不是实时保存的，如果在自动保存触发之前服务器崩溃，那么依然会导致少量数据的丢失。</p><p>而AOF就是另一种方式，它会以日志的形式将我们每次执行的命令都进行保存，服务器重启时会将所有命令依次执行，通过这种重演的方式将数据恢复，这样就能很好解决实时性存储问题。</p><p><img src="https://qqe2.com/java/zb_users/upload/2020/04/202004281588086068660716.png" alt="rdb和aof区别"></p><p>但是，我们多久写一次日志呢？我们可以自己配置保存策略，有三种策略：</p><ul><li>always：每次执行写操作都会保存一次</li><li>everysec：每秒保存一次（默认配置），这样就算丢失数据也只会丢一秒以内的数据</li><li>no：看系统心情保存</li></ul><p>可以在配置文件中配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs sql"># 注意得改成也是<br>appendonly yes<br><br># appendfsync always<br>appendfsync everysec<br># appendfsync <span class="hljs-keyword"><code class="language-hljs sql"># 注意得改成也是<br>appendonly yes<br><br># appendfsync always<br>appendfsync everysec<br># appendfsync <span class="hljs-keyword">no</span><br></code></pre></td></tr></table></figure><p>重启服务器后，可以看到服务器目录下多了一个<code>appendonly.aof</code>文件，存储的就是我们执行的命令。</p><p> AOF的缺点也很明显，每次服务器启动都需要进行过程重演，相比RDB更加耗费时间，并且随着我们的操作变多，不断累计，可能到最后我们的aof文件会变得无比巨大，我们需要一个改进方案来优化这些问题。</p><p>Redis有一个AOF重写机制进行优化，比如我们执行了这样的语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs apache"><span class="hljs-attribute">lpush</span> test <span class="hljs-number">666</span><br><span class="hljs-attribute">lpush</span> test <span class="hljs-number">777</span><br><span class="hljs-attribute">lpush</span> test <span class="hljs-number"><code class="language-hljs apache"><span class="hljs-attribute">lpush</span> test <span class="hljs-number">666</span><br><span class="hljs-attribute">lpush</span> test <span class="hljs-number">777</span><br><span class="hljs-attribute">lpush</span> test <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>实际上用一条语句也可以实现：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs apache"><span class="hljs-attribute">lpush</span> test <span class="hljs-number">666</span> <span class="hljs-number">777</span> <span class="hljs-number"><code class="language-hljs apache"><span class="hljs-attribute">lpush</span> test <span class="hljs-number">666</span> <span class="hljs-number">777</span> <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>正是如此，只要我们能够保证最终的重演结果和原有语句的结果一致，无论语句如何修改都可以，所以我们可以通过这种方式将多条语句进行压缩。</p><p>我们可以输入命令来手动执行重写操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><code class="language-hljs sql">bgrewriteaof<br></code></pre></td></tr></table></figure><p>或是在配置文件中配置自动重写：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs apache"><span class="hljs-comment"># 百分比计算，这里不多介绍</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-comment"># 当达到这个大小时，触发自动重写</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-min-size <span class="hljs-number"><code class="language-hljs apache"><span class="hljs-comment"># 百分比计算，这里不多介绍</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-comment"># 当达到这个大小时，触发自动重写</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb<br></code></pre></td></tr></table></figure><p>至此，我们就完成了两种持久化方案的介绍，最后我们再来进行一下总结：</p><ul><li>AOF：<ul><li>优点：存储速度快、消耗资源少、支持实时存储</li><li>缺点：加载速度慢、数据体积大</li></ul></li><li>RDB：<ul><li>优点：加载速度快、数据体积小</li><li>缺点：存储速度慢大量消耗资源、会发生数据丢失</li></ul></li></ul><hr><h2 id="事务和锁机制"><a href="#事务和锁机制" class="headerlink" title="事务和锁机制"></a>事务和锁机制</h2><p>和MySQL一样，在Redis中也有事务机制，当我们需要保证多条命令一次性完整执行而中途不受到其他命令干扰时，就可以使用事务机制。</p><p>我们可以使用命令来直接开启事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><code class="language-hljs sql">multi<br></code></pre></td></tr></table></figure><p>当我们输入完所有要执行的命令时，可以使用命令来立即执行事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">exec</span><br></code></pre></td></tr></table></figure><p>我们也可以中途取消事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><code class="language-hljs sql">discard<br></code></pre></td></tr></table></figure><p>实际上整个事务是创建了一个命令队列，它不像MySQL那种在事务中也能单独得到结果，而是我们提前将所有的命令装在队列中，但是并不会执行，而是等我们提交事务的时候再统一执行。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>又提到锁了，实际上这个概念对我们来说已经不算是陌生了。实际上在Redis中也会出现多个命令同时竞争同一个数据的情况，比如现在有两条命令同时执行，他们都要去修改a的值，那么这个时候就只能动用锁机制来保证同一时间只能有一个命令操作。</p><p>虽然Redis中也有锁机制，但是它是一种乐观锁，不同于MySQL，我们在MySQL中认识的锁是悲观锁，那么什么是乐观锁什么是悲观锁呢？</p><ul><li>悲观锁：时刻认为别人会来抢占资源，禁止一切外来访问，直到释放锁，具有强烈的排他性质。</li><li>乐观锁：并不认为会有人来抢占资源，所以会直接对数据进行操作，在操作时再去验证是否有其他人抢占资源。</li></ul><p>Redis中可以使用watch来监视一个目标，如果执行事务之前被监视目标发生了修改，则取消本次事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><code class="language-hljs sql">watch<br></code></pre></td></tr></table></figure><p>我们可以开两个客户端进行测试。</p><p>取消监视可以使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><code class="language-hljs sql">unwatch<br></code></pre></td></tr></table></figure><p>至此，Redis的基础内容就讲解完毕了，在之后的SpringCloud阶段，我们还会去讲解集群相关的知识，包括主从复制、哨兵模式等。</p><hr><h2 id="使用Java与Redis交互"><a href="#使用Java与Redis交互" class="headerlink" title="使用Java与Redis交互"></a>使用Java与Redis交互</h2><p>既然了解了如何通过命令窗口操作Redis数据库，那么我们如何使用Java来操作呢？</p><p>这里我们需要使用到Jedis框架，它能够实现Java与Redis数据库的交互，依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>></span><br></code></pre></td></tr></table></figure><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p>我们来看看如何连接Redis数据库，非常简单，只需要创建一个对象即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建Jedis对象</span><br>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>);<br>  <br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建Jedis对象</span><br>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>);<br>  <br>  <span class="hljs-comment">//使用之后关闭连接</span><br>  jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Jedis对象，我们就可以直接调用命令的同名方法来执行Redis命令了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//直接使用try-with-resouse，省去close</span><br>    <span class="hljs-keyword">try</span>(Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.set(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//等同于 set test lbwnb 命令</span><br>        System.out.println(jedis.get(<span class="hljs-string">&quot;test&quot;</span>));  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//直接使用try-with-resouse，省去close</span><br>    <span class="hljs-keyword">try</span>(Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.set(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//等同于 set test lbwnb 命令</span><br>        System.out.println(jedis.get(<span class="hljs-string">&quot;test&quot;</span>));  <span class="hljs-comment">//等同于 get test 命令</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Hash类型的数据也是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.hset(<span class="hljs-string">&quot;hhh&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;sxc&quot;</span>);   <span class="hljs-comment">//等同于 hset hhh name sxc</span><br>        jedis.hset(<span class="hljs-string">&quot;hhh&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;19&quot;</span>);    <span class="hljs-comment">//等同于 hset hhh age 19</span><br>        jedis.hgetAll(<span class="hljs-string">&quot;hhh&quot;</span>).forEach((k, v) -&gt; System.out.println(k+<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.hset(<span class="hljs-string">&quot;hhh&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;sxc&quot;</span>);   <span class="hljs-comment">//等同于 hset hhh name sxc</span><br>        jedis.hset(<span class="hljs-string">&quot;hhh&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;19&quot;</span>);    <span class="hljs-comment">//等同于 hset hhh age 19</span><br>        jedis.hgetAll(<span class="hljs-string">&quot;hhh&quot;</span>).forEach((k, v) -&gt; System.out.println(k+<span class="hljs-string">": "</span>+v));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看看列表操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.lpush(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>);  <span class="hljs-comment">//等同于 lpush mylist 111 222 333 命令</span><br>        jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br>                .forEach(System.out::println);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.lpush(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>);  <span class="hljs-comment">//等同于 lpush mylist 111 222 333 命令</span><br>        jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br>                .forEach(System.out::println);    <span class="hljs-comment">//等同于 lrange mylist 0 -1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上我们只需要按照对应的操作去调用同名方法即可，所有的类型封装Jedis已经帮助我们完成了。</p><h3 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h3><p>我们接着来看如何在SpringBoot项目中整合Redis操作框架，只需要一个starter即可，但是它底层没有用Jedis，而是Lettuce：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>starter提供的默认配置会去连接本地的Redis服务器，并使用0号数据库，当然你也可以手动进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>  <span class="hljs-comment">#Redis服务器地址</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.3</span><br>    <span class="hljs-comment">#端口</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-comment">#使用几号数据库</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number"><code class="language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>  <span class="hljs-comment">#Redis服务器地址</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.3</span><br>    <span class="hljs-comment">#端口</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-comment">#使用几号数据库</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>starter已经给我们提供了两个默认的模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Configuration(</span><br><span class="hljs-meta">    proxyBeanMethods = false</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span><br><span class="hljs-meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisAutoConfiguration</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(</span><br><span class="hljs-meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>        RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Configuration(</span><br><span class="hljs-meta">    proxyBeanMethods = false</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span><br><span class="hljs-meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisAutoConfiguration</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(</span><br><span class="hljs-meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>        RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringRedisTemplate(redisConnectionFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如何去使用这两个模板类呢？我们可以直接注入<code>StringRedisTemplate</code>来使用模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootTestApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StringRedisTemplate template;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        ValueOperations&lt;String, String&gt; operations = template.opsForValue();<br>        operations.set(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;xxxxx&quot;</span>);   <span class="hljs-comment">//设置值</span><br>        System.out.println(operations.get(<span class="hljs-string">&quot;c&quot;</span>));   <span class="hljs-comment">//获取值</span><br>      <br>        template.delete(<span class="hljs-string">&quot;c&quot;</span>);    <span class="hljs-comment">//删除键</span><br>        System.out.println(template.hasKey(<span class="hljs-string">&quot;c&quot;</span>));   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootTestApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StringRedisTemplate template;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        ValueOperations&lt;String, String&gt; operations = template.opsForValue();<br>        operations.set(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;xxxxx&quot;</span>);   <span class="hljs-comment">//设置值</span><br>        System.out.println(operations.get(<span class="hljs-string">&quot;c&quot;</span>));   <span class="hljs-comment">//获取值</span><br>      <br>        template.delete(<span class="hljs-string">&quot;c&quot;</span>);    <span class="hljs-comment">//删除键</span><br>        System.out.println(template.hasKey(<span class="hljs-string">&quot;c&quot;</span>));   <span class="hljs-comment">//判断是否包含键</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上所有的值的操作都被封装到了<code>ValueOperations</code>对象中，而普通的键操作直接通过模板对象就可以使用了，大致使用方式其实和Jedis一致。</p><p>我们接着来看看事务操作，由于Spring没有专门的Redis事务管理器，所以只能借用JDBC提供的，只不过无所谓，正常情况下反正我们也要用到这玩意：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    StringRedisTemplate template;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        template.setEnableTransactionSupport(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//需要开启事务</span><br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-comment">//需要添加此注解</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        template.multi();<br>        template.opsForValue().set(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    StringRedisTemplate template;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        template.setEnableTransactionSupport(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//需要开启事务</span><br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-comment">//需要添加此注解</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        template.multi();<br>        template.opsForValue().set(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">"xxxxx"</span>);<br>        template.exec();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以为RedisTemplate对象配置一个Serializer来实现对象的JSON存储：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoad2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//注意Student需要实现序列化接口才能存入Redis</span><br>    template.opsForValue().set(<span class="hljs-string">&quot;student&quot;</span>, <span class="hljs-keyword">new</span> Student());<br>    System.out.println(template.opsForValue().get(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoad2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//注意Student需要实现序列化接口才能存入Redis</span><br>    template.opsForValue().set(<span class="hljs-string">&quot;student&quot;</span>, <span class="hljs-keyword">new</span> Student());<br>    System.out.println(template.opsForValue().get(<span class="hljs-string">"student"</span>));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="使用Redis做缓存"><a href="#使用Redis做缓存" class="headerlink" title="使用Redis做缓存"></a>使用Redis做缓存</h2><p>我们可以轻松地使用Redis来实现一些框架的缓存和其他存储。</p><h3 id="Mybatis二级缓存"><a href="#Mybatis二级缓存" class="headerlink" title="Mybatis二级缓存"></a>Mybatis二级缓存</h3><p>还记得我们在学习Mybatis讲解的缓存机制吗，我们当时介绍了二级缓存，它是Mapper级别的缓存，能够作用与所有会话。但是当时我们提出了一个问题，由于Mybatis的默认二级缓存只能是单机的，如果存在多台服务器访问同一个数据库，实际上二级缓存只会在各自的服务器上生效，但是我们希望的是多台服务器都能使用同一个二级缓存，这样就不会造成过多的资源浪费。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5afd7713f9a97615dc3a0b1d3bc7db27.png" alt="img"></p><p>我们可以将Redis作为Mybatis的二级缓存，这样就能实现多台服务器使用同一个二级缓存，因为它们只需要连接同一个Redis服务器即可，所有的缓存数据全部存储在Redis服务器上。我们需要手动实现Mybatis提供的Cache接口，这里我们简单编写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//实现Mybatis的Cache接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisMybatisCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cache</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RedisTemplate&lt;Object, Object&gt; template;<br><br>   <span class="hljs-comment">//注意构造方法必须带一个String类型的参数接收id</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisMybatisCache</span><span class="hljs-params">(String id)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>  <span class="hljs-comment">//初始化时通过配置类将RedisTemplate给过来</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTemplate</span><span class="hljs-params">(RedisTemplate&lt;Object, Object&gt; template)</span> </span>&#123;<br>        RedisMybatisCache.template = template;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putObject</span><span class="hljs-params">(Object o, Object o1)</span> </span>&#123;<br>      <span class="hljs-comment">//这里直接向Redis数据库中丢数据即可，o就是Key，o1就是Value，60秒为过期时间</span><br>        template.opsForValue().set(o, o1, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>      <span class="hljs-comment">//这里根据Key直接从Redis数据库中获取值即可</span><br>        <span class="hljs-keyword">return</span> template.opsForValue().get(o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">removeObject</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>      <span class="hljs-comment">//根据Key删除</span><br>        <span class="hljs-keyword">return</span> template.delete(o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//由于template中没封装清除操作，只能通过connection来执行</span><br>template.execute((RedisCallback&lt;Void&gt;) connection -&gt; &#123;<br>          <span class="hljs-comment">//通过connection对象执行清空操作</span><br>            connection.flushDb();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//这里也是使用connection对象来获取当前的Key数量</span><br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">//实现Mybatis的Cache接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisMybatisCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cache</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RedisTemplate&lt;Object, Object&gt; template;<br><br>   <span class="hljs-comment">//注意构造方法必须带一个String类型的参数接收id</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisMybatisCache</span><span class="hljs-params">(String id)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>  <span class="hljs-comment">//初始化时通过配置类将RedisTemplate给过来</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTemplate</span><span class="hljs-params">(RedisTemplate&lt;Object, Object&gt; template)</span> </span>&#123;<br>        RedisMybatisCache.template = template;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putObject</span><span class="hljs-params">(Object o, Object o1)</span> </span>&#123;<br>      <span class="hljs-comment">//这里直接向Redis数据库中丢数据即可，o就是Key，o1就是Value，60秒为过期时间</span><br>        template.opsForValue().set(o, o1, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>      <span class="hljs-comment">//这里根据Key直接从Redis数据库中获取值即可</span><br>        <span class="hljs-keyword">return</span> template.opsForValue().get(o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">removeObject</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>      <span class="hljs-comment">//根据Key删除</span><br>        <span class="hljs-keyword">return</span> template.delete(o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//由于template中没封装清除操作，只能通过connection来执行</span><br>template.execute((RedisCallback&lt;Void&gt;) connection -&gt; &#123;<br>          <span class="hljs-comment">//通过connection对象执行清空操作</span><br>            connection.flushDb();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//这里也是使用connection对象来获取当前的Key数量</span><br>        <span class="hljs-keyword">return</span> template.execute(RedisServerCommands::dbSize).intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缓存类编写完成后，我们接着来编写配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    RedisTemplate&lt;Object, Object&gt; template;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    RedisTemplate&lt;Object, Object&gt; template;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//把RedisTemplate给到RedisMybatisCache</span><br>        RedisMybatisCache.setTemplate(template);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们在Mapper上启用此缓存即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//只需要修改缓存实现类implementation为我们的RedisMybatisCache即可</span><br><span class="hljs-meta">@CacheNamespace(implementation = RedisMybatisCache.class)</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MainMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select name from student where sid = 1&quot;)</span><br>    <span class="hljs-function">String <span class="hljs-title">getSid</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-comment">//只需要修改缓存实现类implementation为我们的RedisMybatisCache即可</span><br><span class="hljs-meta">@CacheNamespace(implementation = RedisMybatisCache.class)</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MainMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select name from student where sid = 1&quot;)</span><br>    <span class="hljs-function">String <span class="hljs-title">getSid</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们提供一个测试用例来查看当前的二级缓存是否生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootTestApplicationTests</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@Resource</span><br>    MainMapper mapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootTestApplicationTests</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@Resource</span><br>    MainMapper mapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(mapper.getSid());<br>        System.out.println(mapper.getSid());<br>        System.out.println(mapper.getSid());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>手动使用客户端查看Redis数据库，可以看到已经有一条Mybatis生成的缓存数据了。</p><h3 id="Token持久化存储"><a href="#Token持久化存储" class="headerlink" title="Token持久化存储"></a>Token持久化存储</h3><p>我们之前使用SpringSecurity时，remember-me的Token是支持持久化存储的，而我们当时是存储在数据库中，那么Token信息能否存储在缓存中呢，当然也是可以的，我们可以手动实现一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//实现PersistentTokenRepository接口</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisTokenRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PersistentTokenRepository</span> </span>&#123;<br>  <span class="hljs-comment">//Key名称前缀，用于区分</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String REMEMBER_ME_KEY = <span class="hljs-string">&quot;spring:security:rememberMe:&quot;</span>;<br>    <span class="hljs-meta">@Resource</span><br>    RedisTemplate&lt;Object, Object&gt; template;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createNewToken</span><span class="hljs-params">(PersistentRememberMeToken token)</span> </span>&#123;<br>      <span class="hljs-comment">//这里要放两个，一个存seriesId-&gt;Token，一个存username-&gt;seriesId，因为删除时是通过username删除</span><br>        template.opsForValue().set(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+token.getUsername(), token.getSeries());<br>        template.expire(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+token.getUsername(), <span class="hljs-number">1</span>, TimeUnit.DAYS);<br>        <span class="hljs-keyword">this</span>.setToken(token);<br>    &#125;<br><br>  <span class="hljs-comment">//先获取，然后修改创建一个新的，再放入</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateToken</span><span class="hljs-params">(String series, String tokenValue, Date lastUsed)</span> </span>&#123;<br>        PersistentRememberMeToken token = <span class="hljs-keyword">this</span>.getToken(series);<br>        <span class="hljs-keyword">if</span>(token != <span class="hljs-keyword">null</span>)<br>           <span class="hljs-keyword">this</span>.setToken(<span class="hljs-keyword">new</span> PersistentRememberMeToken(token.getUsername(), series, tokenValue, lastUsed));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersistentRememberMeToken <span class="hljs-title">getTokenForSeries</span><span class="hljs-params">(String seriesId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getToken(seriesId);<br>    &#125;<br><br>  <span class="hljs-comment">//通过username找seriesId直接删除这两个</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeUserTokens</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        String series = (String) template.opsForValue().get(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+username);<br>        template.delete(REMEMBER_ME_KEY+series);<br>        template.delete(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+username);<br>    &#125;<br><br>  <br>  <span class="hljs-comment">//由于PersistentRememberMeToken没实现序列化接口，这里只能用Hash来存储了，所以单独编写一个set和get操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> PersistentRememberMeToken <span class="hljs-title">getToken</span><span class="hljs-params">(String series)</span></span>&#123;<br>        Map&lt;Object, Object&gt; map = template.opsForHash().entries(REMEMBER_ME_KEY+series);<br>        <span class="hljs-keyword">if</span>(map.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PersistentRememberMeToken(<br>                (String) map.get(<span class="hljs-string">&quot;username&quot;</span>),<br>                (String) map.get(<span class="hljs-string">&quot;series&quot;</span>),<br>                (String) map.get(<span class="hljs-string">&quot;tokenValue&quot;</span>),<br>                <span class="hljs-keyword">new</span> Date(Long.parseLong((String) map.get(<span class="hljs-string">&quot;date&quot;</span>))));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setToken</span><span class="hljs-params">(PersistentRememberMeToken token)</span></span>&#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;username&quot;</span>, token.getUsername());<br>        map.put(<span class="hljs-string">&quot;series&quot;</span>, token.getSeries());<br>        map.put(<span class="hljs-string">&quot;tokenValue&quot;</span>, token.getTokenValue());<br>        map.put(<span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;&quot;</span>+token.getDate().getTime());<br>        template.opsForHash().putAll(REMEMBER_ME_KEY+token.getSeries(), map);<br>        template.expire(REMEMBER_ME_KEY+token.getSeries(), <span class="hljs-number"><code class="language-hljs java"><span class="hljs-comment">//实现PersistentTokenRepository接口</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisTokenRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PersistentTokenRepository</span> </span>&#123;<br>  <span class="hljs-comment">//Key名称前缀，用于区分</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String REMEMBER_ME_KEY = <span class="hljs-string">&quot;spring:security:rememberMe:&quot;</span>;<br>    <span class="hljs-meta">@Resource</span><br>    RedisTemplate&lt;Object, Object&gt; template;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createNewToken</span><span class="hljs-params">(PersistentRememberMeToken token)</span> </span>&#123;<br>      <span class="hljs-comment">//这里要放两个，一个存seriesId-&gt;Token，一个存username-&gt;seriesId，因为删除时是通过username删除</span><br>        template.opsForValue().set(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+token.getUsername(), token.getSeries());<br>        template.expire(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+token.getUsername(), <span class="hljs-number">1</span>, TimeUnit.DAYS);<br>        <span class="hljs-keyword">this</span>.setToken(token);<br>    &#125;<br><br>  <span class="hljs-comment">//先获取，然后修改创建一个新的，再放入</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateToken</span><span class="hljs-params">(String series, String tokenValue, Date lastUsed)</span> </span>&#123;<br>        PersistentRememberMeToken token = <span class="hljs-keyword">this</span>.getToken(series);<br>        <span class="hljs-keyword">if</span>(token != <span class="hljs-keyword">null</span>)<br>           <span class="hljs-keyword">this</span>.setToken(<span class="hljs-keyword">new</span> PersistentRememberMeToken(token.getUsername(), series, tokenValue, lastUsed));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersistentRememberMeToken <span class="hljs-title">getTokenForSeries</span><span class="hljs-params">(String seriesId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getToken(seriesId);<br>    &#125;<br><br>  <span class="hljs-comment">//通过username找seriesId直接删除这两个</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeUserTokens</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        String series = (String) template.opsForValue().get(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+username);<br>        template.delete(REMEMBER_ME_KEY+series);<br>        template.delete(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+username);<br>    &#125;<br><br>  <br>  <span class="hljs-comment">//由于PersistentRememberMeToken没实现序列化接口，这里只能用Hash来存储了，所以单独编写一个set和get操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> PersistentRememberMeToken <span class="hljs-title">getToken</span><span class="hljs-params">(String series)</span></span>&#123;<br>        Map&lt;Object, Object&gt; map = template.opsForHash().entries(REMEMBER_ME_KEY+series);<br>        <span class="hljs-keyword">if</span>(map.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PersistentRememberMeToken(<br>                (String) map.get(<span class="hljs-string">&quot;username&quot;</span>),<br>                (String) map.get(<span class="hljs-string">&quot;series&quot;</span>),<br>                (String) map.get(<span class="hljs-string">&quot;tokenValue&quot;</span>),<br>                <span class="hljs-keyword">new</span> Date(Long.parseLong((String) map.get(<span class="hljs-string">&quot;date&quot;</span>))));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setToken</span><span class="hljs-params">(PersistentRememberMeToken token)</span></span>&#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;username&quot;</span>, token.getUsername());<br>        map.put(<span class="hljs-string">&quot;series&quot;</span>, token.getSeries());<br>        map.put(<span class="hljs-string">&quot;tokenValue&quot;</span>, token.getTokenValue());<br>        map.put(<span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;&quot;</span>+token.getDate().getTime());<br>        template.opsForHash().putAll(REMEMBER_ME_KEY+token.getSeries(), map);<br>        template.expire(REMEMBER_ME_KEY+token.getSeries(), <span class="hljs-number">1</span>, TimeUnit.DAYS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着把验证Service实现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;<br>        Account account = mapper.getAccountByUsername(username);<br>        <span class="hljs-keyword">if</span>(account == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;<br>        Account account = mapper.getAccountByUsername(username);<br>        <span class="hljs-keyword">if</span>(account == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> User<br>                .withUsername(username)<br>                .password(account.getPassword())<br>                .roles(account.getRole())<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mapper也安排上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String username;<br>    String password;<br>    String role;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@CacheNamespace(implementation = MybatisRedisCache.class)</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)</span><br>    <span class="hljs-function">Account <span class="hljs-title">getAccountByUsername</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@CacheNamespace(implementation = MybatisRedisCache.class)</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)</span><br>    <span class="hljs-function">Account <span class="hljs-title">getAccountByUsername</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后配置文件配一波：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    http<br>            .authorizeRequests()<br>            .anyRequest().authenticated()<br>            .and()<br>            .formLogin()<br>            .and()<br>            .rememberMe()<br>            .tokenRepository(repository);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    auth<br>            .userDetailsService(service)<br>            .passwordEncoder(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    http<br>            .authorizeRequests()<br>            .anyRequest().authenticated()<br>            .and()<br>            .formLogin()<br>            .and()<br>            .rememberMe()<br>            .tokenRepository(repository);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    auth<br>            .userDetailsService(service)<br>            .passwordEncoder(<span class="hljs-keyword">new</span> BCryptPasswordEncoder());<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，启动服务器验证一下吧。</p><hr><h2 id="三大缓存问题"><a href="#三大缓存问题" class="headerlink" title="三大缓存问题"></a>三大缓存问题</h2><p><strong>注意：</strong>这部分内容作为选学内容。</p><p>虽然我们可以利用缓存来大幅度提升我们程序的数据获取效率，但是使用缓存也存在着一些潜在的问题。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><img src="https://mydlq-club.oss-cn-beijing.aliyuncs.com/images/springboot-cache-redis-1004.png?x-oss-process=style/shuiyin" alt="img"></p><p>当我们去查询一个一定不存在的数据，比如Mybatis在缓存是未命中的情况下需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p><p>这显然是很浪费资源的，我们希望的是，如果这个数据不存在，为什么缓存这一层不直接返回空呢，这时就不必再去查数据库了，但是也有一个问题，缓存不去查数据库怎么知道数据库里面到底有没有这个数据呢？</p><p>这时我们就可以使用布隆过滤器来进行判断。什么是布隆过滤器？（当然不是打辅助的那个布隆，只不过也挺像，辅助布隆也是挡子弹的）</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201903%2F20190321142642446276.png&refer=http%3A%2F%2Fimage.bubuko.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644902390&t=4f0440b0357965ead1fa34fb27513927" alt="点击查看图片来源"></p><p>使用布隆过滤器，能够告诉你某样东西一定不存在或是某样东西可能存在。</p><p>布隆过滤器本质是一个存放二进制位的bit数组，如果我们要添加一个值到布隆过滤器中，我们需要使用N个不同的哈希函数来生成N个哈希值，并对每个生成的哈希值指向的bit位置1，如上图所示，一共添加了三个值abc。</p><p>接着我们给一个d，那么这时就可以进行判断，如果说d计算的N个哈希值的位置上都是1，那么就说明d可能存在；这时候又来了个e，计算后我们发现有一个位置上的值是0，这时就可以直接断定e一定不存在。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><img src="https://mydlq-club.oss-cn-beijing.aliyuncs.com/images/springboot-cache-redis-1005.png?x-oss-process=style/shuiyin" alt="img"></p><p>某个 Key 属于热点数据，访问非常频繁，同一时间很多人都在访问，在这个Key失效的瞬间，大量的请求到来，这时发现缓存中没有数据，就全都直接请求数据库，相当于击穿了缓存屏障，直接攻击整个系统核心。</p><p>这种情况下，最好的解决办法就是不让Key那么快过期，如果一个Key处于高频访问，那么可以适当地延长过期时间。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><img src="https://mydlq-club.oss-cn-beijing.aliyuncs.com/images/springboot-cache-redis-1006.png?x-oss-process=style/shuiyin" alt="img"></p><p>当你的Redis服务器炸了或是大量的Key在同一时间过期，这时相当于缓存直接GG了，那么如果这时又有很多的请求来访问不同的数据，同一时间内缓存服务器就得向数据库大量发起请求来重新建立缓存，很容易把数据库也搞GG。</p><p>解决这种问题最好的办法就是设置高可用，也就是搭建Redis集群，当然也可以采取一些服务熔断降级机制，这些内容我们会在SpringCloud阶段再进行探讨。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/13/4.html/"/>
      <url>/2022/04/13/4.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Git版本控制"><a href="#Git版本控制" class="headerlink" title="Git版本控制"></a>Git版本控制</h1><p><strong>注意：</strong>开始学习之前，确保自己的网络可以畅通的连接Github：<a href="https://github.com,这个是一个国外网站,连起来特别卡,至于用什么方式实现流畅访问,懂的都懂./">https://github.com，这个是一个国外网站，连起来特别卡，至于用什么方式实现流畅访问，懂的都懂。</a></p><p>其实版本控制在我们的生活中无处不在，比如你的期末或是毕业答辩论文，由于你写得不规范或是老师不满意，你的老师可能会让你改了又改，于是就会出现下面这种情况：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20200417%2F1e63ac0f4d8442cb8c9ab1cb73f510c4.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644370473&t=fa8742db0b4f8db635ec003e37bca76c" alt="点击查看源网页"></p><p>我们手里的论文可能会经过多次版本迭代，最终我们会选取一个最好的版本作为最终提交的论文。使用版本控制不仅仅是为了去记录版本迭代历史，更是为了能够随时回退到之前的版本，实现时间回溯。同时，可能我们的论文是多个人一同完成，那么多个人如何去实现同步，如何保证每个人提交的更改都能够正常汇总，如何解决冲突，这些问题都需要一个优秀的版本控制系统来解决。</p><h2 id="走进Git"><a href="#走进Git" class="headerlink" title="走进Git"></a>走进Git</h2><p>我们开发的项目，也需要一个合适的版本控制系统来协助我们更好地管理版本迭代，而Git正是因此而诞生的（有关Git的历史，这里就不多做阐述了，感兴趣的小伙伴可以自行了解，是一位顶级大佬在一怒之下只花了2周时间用C语言开发的，之后的章节还会遇到他）</p><p>首先我们来了解一下Git是如何工作的：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F932856%2F202004%2F932856-20200423143251346-796113044.jpg&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644374894&t=7c2044128f7851ecd92de3c01f0187ca" alt="点击查看源网页"></p><p>可以看到，它大致分为4个板块：</p><ul><li>工作目录：存放我们正在写的代码（当我们新版本开发完成之后，就可以进行新版本的提交）</li><li>暂存区：暂时保存待提交的内容（新版本提交后会存放到本地仓库）</li><li>本地仓库：位于我们电脑上的一个版本控制仓库（存放的就是当前项目各个版本代码的增删信息）</li><li>远程仓库：位于服务器上的版本控制仓库（服务器上的版本信息可以由本地仓库推送上去，也可以从服务器抓取到本地仓库）</li></ul><p>它是一个分布式的控制系统，因此一般情况下我们每个人的电脑上都有一个本地仓库，由大家共同向远程仓库去推送版本迭代信息。</p><p>通过这一系列操作，我们就可以实现每开发完一个版本或是一个功能，就提交一次新版本，这样，我们就可以很好地控制项目的版本迭代，想回退到之前的版本随时都可以回退，想查看新版本添加或是删除了什么代码，随时都可以查看。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>首先请前往Git官网去下载最新的安装包：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>这手把手演示一下如何安装Git环境。</p><p>安装完成后，需要设定用户名和邮箱来区分不同的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">git config --global user.name "Your Name"<br>git config --global user.email "email@example.com"<br></code></pre></td></tr></table></figure><h2 id="基本命令介绍"><a href="#基本命令介绍" class="headerlink" title="基本命令介绍"></a>基本命令介绍</h2><h3 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h3><p>我们可以将任意一个文件夹作为一个本地仓库，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">git init<br></code></pre></td></tr></table></figure><p>输入后，会自动生成一个<code>.git</code>目录，注意这个目录是一个隐藏目录，而当前目录就是我们的工作目录。</p><p>创建成功后，我们可以查看一下当前的一个状态，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">git status<br></code></pre></td></tr></table></figure><p>如果已经成功配置为Git本地仓库，那么输入后可以看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">On branch master<br><br>No commits yet<br></code></pre></td></tr></table></figure><p>这表示我们还没有向仓库中提交任何内容，也就是一个空的状态。</p><h3 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h3><p>接着我们来看看，如何使用git来管理我们文档的版本，我们创建一个文本文档，随便写入一点内容，接着输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">git status<br></code></pre></td></tr></table></figure><p>我们会得到如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">Untracked files:<br>  (use "git add <file>..." to include in what will be committed)<br>hello.txt<br><br>nothing added to commit but untracked files present (use "git add" to track)<br></code></pre></td></tr></table></figure><p>其中Untracked files是未追踪文件的意思，也就是说，如果一个文件处于未追踪状态，那么git不会记录它的变化，始终将其当做一个新创建的文件，这里我们将其添加到暂存区，那么它会自动变为被追踪状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">git add hello.txt #也可以 add . 一次性添加目录下所有的<br></code></pre></td></tr></table></figure><p>再次查看当前状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sh">Changes to be committed:<br>  (use <span class="hljs-string"><code class="language-hljs sh">Changes to be committed:<br>  (use <span class="hljs-string">"git rm --cached <file>..."</span> to unstage)<br>new file:   hello.txt<br></code></pre></td></tr></table></figure><p>现在文件名称的颜色变成了绿色，并且是处于Changes to be committed下面，因此，我们的hello.txt现在已经被添加到暂存区了。</p><p>接着我们来尝试将其提交到Git本地仓库中，注意需要输入提交的描述以便后续查看，比如你这次提交修改了或是新增了哪些内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git commit -m <span class="hljs-string"><code class="language-hljs sh">git commit -m <span class="hljs-string">&#x27;Hello World&#x27;</span><br></code></pre></td></tr></table></figure><p>接着我们可以查看我们的提交记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git <span class="hljs-built_in">log</span><br>git <span class="hljs-built_in"><code class="language-hljs sh">git <span class="hljs-built_in">log</span><br>git <span class="hljs-built_in">log</span> --graph<br></code></pre></td></tr></table></figure><p>我们还可以查看最近一次变更的详细内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git show [也可以加上commit ID查看指定的提交记录]<br></code></pre></td></tr></table></figure><p>再次查看当前状态，已经是清空状态了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><p>接着我们可以尝试修改一下我们的文本文档，由于当前文件已经是被追踪状态，那么git会去跟踪它的变化，如果说文件发生了修改，那么我们再次查看状态会得到下面的结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs sh">Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword"><code class="language-hljs sh">Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>modified:   hello.txt<br></code></pre></td></tr></table></figure><p>也就是说现在此文件是处于已修改状态，我们如果修改好了，就可以提交我们的新版本到本地仓库中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git add .<br>git commit -m <span class="hljs-string"><code class="language-hljs sh">git add .<br>git commit -m <span class="hljs-string">&#x27;Modify Text&#x27;</span><br></code></pre></td></tr></table></figure><p>接着我们来查询一下提交记录，可以看到一共有两次提交记录。</p><p>我们可以创建一个<code>.gitignore</code>文件来确定一个文件忽略列表，如果忽略列表中的文件存在且不是被追踪状态，那么git不会对其进行任何检查：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-comment"># 这样就会匹配所有以txt结尾的文件</span><br><span class="hljs-string">*.txt</span><br><span class="hljs-comment"># 虽然上面排除了所有txt结尾的文件，但是这个不排除</span><br><span class="hljs-type">!666.txt</span><br><span class="hljs-comment"># 也可以直接指定一个文件夹，文件夹下的所有文件将全部忽略</span><br><span class="hljs-string">test/</span><br><span class="hljs-comment"># 目录中所有以txt结尾的文件，但不包括子目录</span><br><span class="hljs-string">xxx/*.txt</span><br><span class="hljs-comment"># 目录中所有以txt结尾的文件，包括子目录</span><br><span class="hljs-string"><code class="language-hljs yaml"><span class="hljs-comment"># 这样就会匹配所有以txt结尾的文件</span><br><span class="hljs-string">*.txt</span><br><span class="hljs-comment"># 虽然上面排除了所有txt结尾的文件，但是这个不排除</span><br><span class="hljs-type">!666.txt</span><br><span class="hljs-comment"># 也可以直接指定一个文件夹，文件夹下的所有文件将全部忽略</span><br><span class="hljs-string">test/</span><br><span class="hljs-comment"># 目录中所有以txt结尾的文件，但不包括子目录</span><br><span class="hljs-string">xxx/*.txt</span><br><span class="hljs-comment"># 目录中所有以txt结尾的文件，包括子目录</span><br><span class="hljs-string">xxx/**/*.txt</span><br></code></pre></td></tr></table></figure><p>创建后，我们来看看是否还会检测到我们忽略的文件。</p><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><p>当我们想要回退到过去的版本时，就可以执行回滚操作，执行后，可以将工作空间的内容恢复到指定提交的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git reset --hard commitID<br></code></pre></td></tr></table></figure><p>执行后，会直接重置为那个时候的状态。再次查看提交日志，我们发现之后的日志全部消失了。</p><p>那么要是现在我又想回去呢？我们可以通过查看所有分支的所有操作记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git reflog<br></code></pre></td></tr></table></figure><p>这样就能找到之前的commitID，再次重置即可。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支就像我们树上的一个树枝一样，它们可能一开始的时候是同一根树枝，但是长着长着就开始分道扬镳了，这就是分支。我们的代码也是这样，可能一开始写基础功能的时候使用的是单个分支，但是某一天我们希望基于这些基础的功能，把我们的项目做成两个不同方向的项目，比如一个方向做Web网站，另一个方向做游戏服务端。</p><p>因此，我们可以在一个主干上分出N个分支，分别对多个分支的代码进行维护。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>我们可以通过以下命令来查看当前仓库中存在的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git branch<br></code></pre></td></tr></table></figure><p>我们发现，默认情况下是有一个master分支的，并且我们使用的也是master分支，一般情况下master分支都是正式版本的更新，而其他分支一般是开发中才频繁更新的。我们接着来基于当前分支创建一个新的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git branch <span class="hljs-built_in">test</span><br><span class="hljs-comment"><code class="language-hljs sh">git branch <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 对应的删除分支是</span><br>git branch -d yyds<br></code></pre></td></tr></table></figure><p>现在我们修改一下文件，提交，再查看一下提交日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git commit -a -m <span class="hljs-string"><code class="language-hljs sh">git commit -a -m <span class="hljs-string">&#x27;branch master commit&#x27;</span><br></code></pre></td></tr></table></figure><p>通过添加-a来自动将未放入暂存区的已修改文件放入暂存区并执行提交操作。查看日志，我们发现现在我们的提交只生效于master分支，而新创建的分支并没有发生修改。</p><p>我们将分支切换到另一个分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git checkout <span class="hljs-built_in"><code class="language-hljs sh">git checkout <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>我们会发现，文件变成了此分支创建的时的状态，也就是说，在不同分支下我们的文件内容是相互隔离的。</p><p>我们现在再来提交一次变更，会发现它只生效在yyds分支上。我们可以看看当前的分支状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git <span class="hljs-built_in"><code class="language-hljs sh">git <span class="hljs-built_in">log</span> --all --graph<br></code></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>我们也可以将两个分支更新的内容最终合并到同一个分支上，我们先切换回主分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git checkout master<br></code></pre></td></tr></table></figure><p>接着使用分支合并命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git merge <span class="hljs-built_in"><code class="language-hljs sh">git merge <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>会得到如下提示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs pgsql">Auto-merging hello.txt<br><span class="hljs-keyword">CONFLICT</span> (content): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> hello.txt<br>Automatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword"><code class="language-hljs pgsql">Auto-merging hello.txt<br><span class="hljs-keyword">CONFLICT</span> (content): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> hello.txt<br>Automatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.<br></code></pre></td></tr></table></figure><p>在合并过程中产生了冲突，因为两个分支都对hello.txt文件进行了修改，那么现在要合并在一起，到底保留谁的hello文件呢？</p><p>我们可以查看一下是哪里发生了冲突：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git diff<br></code></pre></td></tr></table></figure><p>因此，现在我们将master分支的版本回退到修改hello.txt之前或是直接修改为最新版本的内容，这样就不会有冲突了，接着再执行一次合并操作，现在两个分支成功合并为同一个分支。</p><h3 id="变基分支"><a href="#变基分支" class="headerlink" title="变基分支"></a>变基分支</h3><p>除了直接合并分支以外，我们还可以进行变基操作，它跟合并不同，合并是分支回到主干的过程，而变基是直接修改分支开始的位置，比如我们希望将yyds变基到master上，那么yyds会将分支起点移动到master最后一次提交位置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git rebase master<br></code></pre></td></tr></table></figure><p>变基后，yyds分支相当于同步了此前master分支的全部提交。</p><h3 id="优选"><a href="#优选" class="headerlink" title="优选"></a>优选</h3><p>我们还可以选择其将他分支上的提交作用于当前分支上，这种操作称为cherrypick：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git cherry-pick <commit id>:单独合并一个提交<br></code></pre></td></tr></table></figure><p>这里我们在master分支上创建一个新的文件，提交此次更新，接着通过cherry-pick的方式将此次更新作用于test分支上。</p><hr><h2 id="使用IDEA版本控制"><a href="#使用IDEA版本控制" class="headerlink" title="使用IDEA版本控制"></a>使用IDEA版本控制</h2><p>虽然前面我们基本讲解了git的命令行使用方法，但是没有一个图形化界面，始终会感觉到很抽象，所以这里我们使用IDEA来演示，IDEA内部集成了git模块，它可以让我们的git版本管理图形化显示，当然除了IDEA也有一些独立的软件比如：SourceTree（挺好用）</p><p>打开IDEA后，找到版本控模块，我们直接点击创建本地仓库，它会自动将当前项目的根目录作为我们的本地仓库，而我们编写的所有代码和项目目录下其他的文件都可以进行版本控制。</p><p>我们发现所有项目中正在编写的类文件全部变红了，也就是处于未追踪状态，接着我们进行第一次初始化提交，提交之后我们可以在下方看到所有的本地仓库提交记录。</p><p>接着我们来整合一下Web环境，创建新的类之后，IDEA会提示我们是否将文件添加到Git，也就是是否放入暂存区并开启追踪，我们可以直接对比两次代码的相同和不同之处。</p><p>接着我们来演示一下分支创建和分支管理。</p><hr><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库实际上就是位于服务器上的仓库，它能在远端保存我们的版本历史，并且可以实现多人同时合作编写项目，每个人都能够同步他人的版本，能够看到他人的版本提交，相当于将我们的代码放在服务器上进行托管。</p><p>远程仓库有公有和私有的，公有的远程仓库有GitHub、码云、Coding等，他们都是对外开放的，我们注册账号之后就可以使用远程仓库进行版本控制，其中最大的就是GitHub，但是它服务器在国外，我们国内连接可能会有一点卡。私有的一般是GitLab这种自主搭建的远程仓库私服，在公司中比较常用，它只对公司内部开放，不对外开放。</p><p>这里我们以GitHub做讲解，官网：<a href="https://github.com,首先完成用户注册./">https://github.com，首先完成用户注册。</a></p><h3 id="远程账户认证和推送"><a href="#远程账户认证和推送" class="headerlink" title="远程账户认证和推送"></a>远程账户认证和推送</h3><p>接着我们就可以创建一个自定义的远程仓库了。</p><p>创建仓库后，我们可以通过推送来将本地仓库中的内容推送到远程仓库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git remote add 名称 远程仓库地址<br>git push 远程仓库名称 本地分支名称[:远端分支名称]<br></code></pre></td></tr></table></figure><p>注意<code>push</code>后面两个参数，一个是远端名称，还有一个就是本地分支名称，但是如果本地分支名称和远端分支名称一致，那么不用指定远端分支名称，但是如果我们希望推送的分支在远端没有同名的，那么需要额外指定。推送前需要登陆账户，GitHub现在不允许使用用户名密码验证，只允许使用个人AccessToken来验证身份，所以我们需要先去生成一个Token才可以。</p><p>推送后，我们发现远程仓库中的内容已经与我们本地仓库中的内容保持一致了，注意，远程仓库也可以有很多个分支。</p><p>但是这样比较麻烦，我们每次都需要去输入用户名和密码，有没有一劳永逸的方法呢？当然，我们也可以使用SSH来实现一次性校验，我们可以在本地生成一个rsa公钥：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">ssh-keygen -t rsa<br>cat ~/.ssh/github.pub<br></code></pre></td></tr></table></figure><p>接着我们需要在GitHub上上传我们的公钥，当我们再次去访问GitHub时，会自动验证，就无需进行登录了，之后在Linux部分我们会详细讲解SSH的原理。</p><p>接着我们修改一下工作区的内容，提交到本地仓库后，再推送到远程仓库，提交的过程中我们注意观察提交记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git commit -a -m <span class="hljs-string">&#x27;Modify files&#x27;</span><br>git <span class="hljs-built_in">log</span> --all --oneline --graph<br>git push origin master <br>git <span class="hljs-built_in"><code class="language-hljs sh">git commit -a -m <span class="hljs-string">&#x27;Modify files&#x27;</span><br>git <span class="hljs-built_in">log</span> --all --oneline --graph<br>git push origin master <br>git <span class="hljs-built_in">log</span> --all --oneline --graph<br></code></pre></td></tr></table></figure><p>我们可以将远端和本地的分支进行绑定，绑定后就不需要指定分支名称了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git push --set-upstream origin master:master<br>git push origin<br></code></pre></td></tr></table></figure><p>在一个本地仓库对应一个远程仓库的情况下，远程仓库基本上就是纯粹的代码托管了（云盘那种感觉，就纯粹是存你代码的）</p><h3 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h3><p>如果我们已经存在一个远程仓库的情况下，我们需要在远程仓库的代码上继续编写代码，这个时候怎么办呢？</p><p>我们可以使用克隆操作来将远端仓库的内容全部复制到本地：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git <span class="hljs-built_in"><code class="language-hljs sh">git <span class="hljs-built_in">clone</span> 远程仓库地址<br></code></pre></td></tr></table></figure><p>这样本地就能够直接与远程保持同步。</p><h3 id="抓取、拉取和冲突解决"><a href="#抓取、拉取和冲突解决" class="headerlink" title="抓取、拉取和冲突解决"></a>抓取、拉取和冲突解决</h3><p>我们接着来看，如果这个时候，出现多个本地仓库对应一个远程仓库的情况下，比如一个团队里面，N个人都在使用同一个远程仓库，但是他们各自只负责编写和推送自己业务部分的代码，也就是我们常说的协同工作，那么这个时候，我们就需要协调。</p><p>比如程序员A完成了他的模块，那么他就可以提交代码并推送到远程仓库，这时程序员B也要开始写代码了，由于远程仓库有其他程序员的提交记录，因此程序员B的本地仓库和远程仓库不一致，这时就需要有先进行pull操作，获取远程仓库中最新的提交：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh">git fetch 远程仓库 <span class="hljs-comment">#抓取：只获取但不合并远端分支，后面需要我们手动合并才能提交</span><br>git pull 远程仓库 <span class="hljs-comment"><code class="language-hljs sh">git fetch 远程仓库 <span class="hljs-comment">#抓取：只获取但不合并远端分支，后面需要我们手动合并才能提交</span><br>git pull 远程仓库 <span class="hljs-comment">#拉取：获取+合并</span><br></code></pre></td></tr></table></figure><p>在程序员B拉取了最新的版本后，再编写自己的代码然后提交就可以实现多人合作编写项目了，并且在拉取过程中就能将别人提交的内容同步到本地，开发效率大大提升。</p><p>如果工作中存在不协调的地方，比如现在我们本地有两个仓库，一个仓库去修改hello.txt并直接提交，另一个仓库也修改hello.txt并直接提交，会得到如下错误：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs vim">To http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/xx/xxx.git<br> ! [rejected]        master -&gt; master (fetch <span class="hljs-keyword">first</span>)<br>error: failed <span class="hljs-keyword">to</span> push some refs <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;https://github.com/xx/xxx.git&#x27;</span><br>hin<span class="hljs-variable">t:</span> Updates were rejected because the remote contains work that you <span class="hljs-keyword">do</span><br>hin<span class="hljs-variable">t:</span> not have locally. This <span class="hljs-keyword">is</span> usually caused by another repository pushing<br>hin<span class="hljs-variable">t:</span> <span class="hljs-keyword">to</span> the same ref. You may want <span class="hljs-keyword">to</span> <span class="hljs-keyword">first</span> integrate the remote <span class="hljs-keyword">changes</span><br>hin<span class="hljs-variable">t:</span> (<span class="hljs-keyword">e</span>.g., <span class="hljs-string">&#x27;git pull ...&#x27;</span>) before pushing again.<br>hin<span class="hljs-variable">t:</span> See the <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> in <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword"><code class="language-hljs vim">To http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/xx/xxx.git<br> ! [rejected]        master -&gt; master (fetch <span class="hljs-keyword">first</span>)<br>error: failed <span class="hljs-keyword">to</span> push some refs <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;https://github.com/xx/xxx.git&#x27;</span><br>hin<span class="hljs-variable">t:</span> Updates were rejected because the remote contains work that you <span class="hljs-keyword">do</span><br>hin<span class="hljs-variable">t:</span> not have locally. This <span class="hljs-keyword">is</span> usually caused by another repository pushing<br>hin<span class="hljs-variable">t:</span> <span class="hljs-keyword">to</span> the same ref. You may want <span class="hljs-keyword">to</span> <span class="hljs-keyword">first</span> integrate the remote <span class="hljs-keyword">changes</span><br>hin<span class="hljs-variable">t:</span> (<span class="hljs-keyword">e</span>.g., <span class="hljs-string">&#x27;git pull ...&#x27;</span>) before pushing again.<br>hin<span class="hljs-variable">t:</span> See the <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> in <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>一旦一个本地仓库推送了代码，那么另一个本地仓库的推送会被拒绝，原因是当前文件已经被其他的推送给修改了，我们这边相当于是另一个版本，和之前两个分支合并一样，产生了冲突，因此我们只能去解决冲突问题。</p><p>如果远程仓库中的提交和本地仓库中的提交没有去编写同一个文件，那么就可以直接拉取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">git pull 远程仓库<br></code></pre></td></tr></table></figure><p>拉取后会自动进行合并，合并完成之后我们再提交即可。</p><p>但是如果两次提交都修改了同一个文件，那么就会遇到和多分支合并一样的情况，在合并时会产生冲突，这时就需要我们自己去解决冲突了。</p><p>我们可以在IDEA中演示一下，实际开发场景下可能会遇到的问题。</p><hr><p>至此，Git版本控制就讲解到这里，下一章我们会继续认识一个全新的数据库：Redis。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-054d8ff6135b3638aca543eff7424f98_1200x500.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644402012&t=79c30b8002d088850e33bd90492419b2" alt="点击查看源网页"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/13/3.html/"/>
      <url>/2022/04/13/3.html/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot其他框架"><a href="#SpringBoot其他框架" class="headerlink" title="SpringBoot其他框架"></a>SpringBoot其他框架</h1><p>通过了解其他的SpringBoot框架，我们就可以在我们自己的Web服务器上实现更多更高级的功能。</p><h2 id="邮件发送：Mail"><a href="#邮件发送：Mail" class="headerlink" title="邮件发送：Mail"></a>邮件发送：Mail</h2><p>我们在注册很多的网站时，都会遇到邮件或是手机号验证，也就是通过你的邮箱或是手机短信去接受网站发给你的注册验证信息，填写验证码之后，就可以完成注册了，同时，网站也会绑定你的手机号或是邮箱。</p><p>那么，像这样的功能，我们如何实现呢？SpringBoot已经给我们提供了封装好的邮件模块使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><h3 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h3><p>在学习邮件发送之前，我们需要先了解一下什么是电子邮件。</p><p>电子邮件也是一种通信方式，是互联网应用最广的服务。通过网络的电子邮件系统，用户可以以非常低廉的价格（不管发送到哪里，都只需负担网费，实际上就是把信息发送到对方服务器而已）、非常快速的方式，与世界上任何一个地方的电子邮箱用户联系。</p><p>虽说方便倒是方便，虽然是曾经的霸主，不过现在这个时代，QQ微信横行，手机短信和电子邮箱貌似就只剩收验证码这一个功能了。</p><p>要在Internet上提供电子邮件功能，必须有专门的电子邮件服务器。例如现在Internet很多提供邮件服务的厂商：新浪、搜狐、163、QQ邮箱等，他们都有自己的邮件服务器。这些服务器类似于现实生活中的邮局，它主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中。</p><p>所有的用户都可以在电子邮件服务器上申请一个账号用于邮件发送和接收，那么邮件是以什么样的格式发送的呢？实际上和Http一样，邮件发送也有自己的协议，也就是约定邮件数据长啥样以及如何通信。</p><p><img src="https://images2015.cnblogs.com/blog/851491/201612/851491-20161202143243756-1715308358.png" alt="img"></p><p>比较常用的协议有两种：</p><ol><li>SMTP协议（主要用于发送邮件 Simple Mail Transfer Protocol）</li><li>POP3协议（主要用于接收邮件 Post Office Protocol 3）</li></ol><p>整个发送/接收流程大致如下：</p><p><img src="https://img2.baidu.com/it/u=3675146129,445744702&fm=253&fmt=auto&app=138&f=JPG?w=812&h=309" alt="img"></p><p>实际上每个邮箱服务器都有一个smtp发送服务器和pop3接收服务器，比如要从QQ邮箱发送邮件到163邮箱，那么我们只需要通过QQ邮箱客户端告知QQ邮箱的smtp服务器我们需要发送邮件，以及邮件的相关信息，然后QQ邮箱的smtp服务器就会帮助我们发送到163邮箱的pop3服务器上，163邮箱会通过163邮箱客户端告知对应用户收到一封新邮件。</p><p>而我们如果想要实现给别人发送邮件，那么就需要连接到对应电子邮箱的smtp服务器上，并告知其我们要发送邮件。而SpringBoot已经帮助我们将最基本的底层通信全部实现了，我们只需要关心smtp服务器的地址以及我们要发送的邮件长啥样即可。</p><p>这里以163邮箱 <a href="https://mail.163.com/">https://mail.163.com</a> 为例，我们需要在配置文件中告诉SpringBootMail我们的smtp服务器的地址以及你的邮箱账号和密码，首先我们要去设置中开启smtp/pop3服务才可以，开启后会得到一个随机生成的密钥，这个就是我们的密码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>  <span class="hljs-comment"># 163邮箱的地址为smtp.163.com，直接填写即可</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com</span><br>    <span class="hljs-comment"># 你申请的163邮箱</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">javastudy111@163.com</span><br>    <span class="hljs-comment"># 注意密码是在开启smtp/pop3时自动生成的，记得保存一下，不然就找不到了</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string"><code class="language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>  <span class="hljs-comment"># 163邮箱的地址为smtp.163.com，直接填写即可</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com</span><br>    <span class="hljs-comment"># 你申请的163邮箱</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">javastudy111@163.com</span><br>    <span class="hljs-comment"># 注意密码是在开启smtp/pop3时自动生成的，记得保存一下，不然就找不到了</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">AZJTOAWZESLMHTNI</span><br></code></pre></td></tr></table></figure><p>配置完成后，接着我们来进行一下测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootTestApplicationTests</span> </span>&#123;<br><br>  <span class="hljs-comment">//JavaMailSender是专门用于发送邮件的对象，自动配置类已经提供了Bean</span><br>    <span class="hljs-meta">@Autowired</span><br>    JavaMailSender sender;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//SimpleMailMessage是一个比较简易的邮件封装，支持设置一些比较简单内容</span><br>        SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();<br>      <span class="hljs-comment">//设置邮件标题</span><br>        message.setSubject(<span class="hljs-string">&quot;【电子科技大学教务处】关于近期学校对您的处分决定&quot;</span>);<br>      <span class="hljs-comment">//设置邮件内容</span><br>        message.setText(<span class="hljs-string">&quot;XXX同学您好，经监控和教务巡查发现，您近期存在旷课、迟到、早退、上课刷抖音行为，&quot;</span> +<br>                <span class="hljs-string">&quot;现已通知相关辅导员，请手写5000字书面检讨，并在2022年4月1日17点前交到辅导员办公室。&quot;</span>);<br>      <span class="hljs-comment">//设置邮件发送给谁，可以多个，这里就发给你的QQ邮箱</span><br>        message.setTo(<span class="hljs-string">&quot;你的QQ号@qq.com&quot;</span>);<br>      <span class="hljs-comment">//邮件发送者，这里要与配置文件中的保持一致</span><br>        message.setFrom(<span class="hljs-string">&quot;javastudy111@163.com&quot;</span>);<br>      <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootTestApplicationTests</span> </span>&#123;<br><br>  <span class="hljs-comment">//JavaMailSender是专门用于发送邮件的对象，自动配置类已经提供了Bean</span><br>    <span class="hljs-meta">@Autowired</span><br>    JavaMailSender sender;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//SimpleMailMessage是一个比较简易的邮件封装，支持设置一些比较简单内容</span><br>        SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();<br>      <span class="hljs-comment">//设置邮件标题</span><br>        message.setSubject(<span class="hljs-string">&quot;【电子科技大学教务处】关于近期学校对您的处分决定&quot;</span>);<br>      <span class="hljs-comment">//设置邮件内容</span><br>        message.setText(<span class="hljs-string">&quot;XXX同学您好，经监控和教务巡查发现，您近期存在旷课、迟到、早退、上课刷抖音行为，&quot;</span> +<br>                <span class="hljs-string">&quot;现已通知相关辅导员，请手写5000字书面检讨，并在2022年4月1日17点前交到辅导员办公室。&quot;</span>);<br>      <span class="hljs-comment">//设置邮件发送给谁，可以多个，这里就发给你的QQ邮箱</span><br>        message.setTo(<span class="hljs-string">&quot;你的QQ号@qq.com&quot;</span>);<br>      <span class="hljs-comment">//邮件发送者，这里要与配置文件中的保持一致</span><br>        message.setFrom(<span class="hljs-string">&quot;javastudy111@163.com&quot;</span>);<br>      <span class="hljs-comment">//OK，万事俱备只欠发送</span><br>        sender.send(message);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要添加附件等更多功能，可以使用MimeMessageHelper来帮助我们完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;<br>  <span class="hljs-comment">//创建一个MimeMessage</span><br>    MimeMessage message = sender.createMimeMessage();<br>  <span class="hljs-comment">//使用MimeMessageHelper来帮我们修改MimeMessage中的信息</span><br>    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(message, <span class="hljs-keyword">true</span>);<br>    helper.setSubject(<span class="hljs-string">&quot;Test&quot;</span>);<br>    helper.setText(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    helper.setTo(<span class="hljs-string">&quot;你的QQ号@qq.com&quot;</span>);<br>    helper.setFrom(<span class="hljs-string">&quot;javastudy111@163.com&quot;</span>);<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;<br>  <span class="hljs-comment">//创建一个MimeMessage</span><br>    MimeMessage message = sender.createMimeMessage();<br>  <span class="hljs-comment">//使用MimeMessageHelper来帮我们修改MimeMessage中的信息</span><br>    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(message, <span class="hljs-keyword">true</span>);<br>    helper.setSubject(<span class="hljs-string">&quot;Test&quot;</span>);<br>    helper.setText(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    helper.setTo(<span class="hljs-string">&quot;你的QQ号@qq.com&quot;</span>);<br>    helper.setFrom(<span class="hljs-string">&quot;javastudy111@163.com&quot;</span>);<br>  <span class="hljs-comment">//发送修改好的MimeMessage</span><br>    sender.send(message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邮件注册"><a href="#邮件注册" class="headerlink" title="邮件注册"></a>邮件注册</h3><p>既然我们已经了解了邮件发送，那么我们接着来看如何在我们的项目中实现邮件验证。</p><p>首先明确验证流程：请求验证码 -&gt; 生成验证码（临时有效，注意设定过期时间） -&gt; 用户输入验证码并填写注册信息 -&gt; 验证通过注册成功！</p><hr><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2Fv2-6f0b9bb234b2534ec295ff195bad183a_1440w.jpg%3Fsource%3D172ae18b&refer=http%3A%2F%2Fpic1.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645108924&t=d40aa5dc6be398725b4ff21ef5895454" alt="点击查看图片来源"></p><h2 id="持久层框架：JPA"><a href="#持久层框架：JPA" class="headerlink" title="持久层框架：JPA"></a>持久层框架：JPA</h2><ul><li>用了Mybatis之后，你看那个JDBC，真是太逊了。</li><li>这么说，你的项目很勇哦？</li><li>开玩笑，我的写代码超勇的好不好。</li><li>阿伟，你可曾幻想过有一天你的项目里不再有SQL语句？</li><li>不再有SQL语句？那我怎么和数据库交互啊？</li><li>我看你是完全不懂哦</li><li>懂，懂什么啊？</li><li>你想懂？来，到我项目里来，我给你看点好康的。</li><li>好康？是什么新框架哦？</li><li>什么新框架，比新框架还刺激，还可以让你的项目登duang郎哦。</li><li>哇，杰哥，你项目里面都没SQL语句诶，这是用的什么框架啊？</li></ul><p>在我们之前编写的项目中，我们不难发现，实际上大部分的数据库交互操作，到最后都只会做一个事情，那就是把数据库中的数据映射为Java中的对象。比如我们要通过用户名去查找对应的用户，或是通过ID查找对应的学生信息，在使用Mybatis时，我们只需要编写正确的SQL语句就可以直接将获取的数据映射为对应的Java对象，通过调用Mapper中的方法就能直接获得实体类，这样就方便我们在Java中数据库表中的相关信息了。</p><p>但是以上这些操作都有一个共性，那就是它们都是通过某种条件去进行查询，而最后的查询结果，都是一个实体类，所以你会发现你写的很多SQL语句都是一个套路<code>select * from xxx where xxx=xxx</code>，那么能否有一种框架，帮我们把这些相同的套路给封装起来，直接把这类相似的SQL语句给屏蔽掉，不再由我们编写，而是让框架自己去组合拼接。</p><h3 id="认识SpringDataJPA"><a href="#认识SpringDataJPA" class="headerlink" title="认识SpringDataJPA"></a>认识SpringDataJPA</h3><p>首先我们来看一个国外的统计：</p><p>![image-20220119140326867](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220119140326867.png)</p><p>不对吧，为什么Mybatis这么好用，这么强大，却只有10%的人喜欢呢？然而事实就是，在国外JPA几乎占据了主导地位，而Mybatis并不像国内那样受待见，所以你会发现，JPA都有SpringBoot的官方直接提供的starter，而Mybatis没有。</p><p>至于为啥SSM阶段不讲这个，而是放到现在来讲也是因为，在微服务场景下它的优势才能更多的发挥出来。</p><p>那么，什么是JPA？</p><p>JPA（Java Persistence API）和JDBC类似，也是官方定义的一组接口，但是它相比传统的JDBC，它是为了实现ORM而生的，即Object-Relationl Mapping，它的作用是在关系型数据库和对象之间形成一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了。</p><p>在之前，我们使用JDBC或是Mybatis来操作数据，通过直接编写对应的SQL语句来实现数据访问，但是我们发现实际上我们在Java中大部分操作数据库的情况都是读取数据并封装为一个实体类，因此，为什么不直接将实体类直接对应到一个数据库表呢？也就是说，一张表里面有什么属性，那么我们的对象就有什么属性，所有属性跟数据库里面的字段一一对应，而读取数据时，只需要读取一行的数据并封装为我们定义好的实体类既可以，而具体的SQL语句执行，完全可以交给框架根据我们定义的映射关系去生成，不再由我们去编写，因为这些SQL实际上都是千篇一律的。</p><p>而实现JPA规范的框架一般最常用的就是<code>Hibernate</code>，它是一个重量级框架，学习难度相比Mybatis也更高一些，而SpringDataJPA也是采用Hibernate框架作为底层实现，并对其加以封装。</p><p>官网：<a href="https://spring.io/projects/spring-data-jpa">https://spring.io/projects/spring-data-jpa</a></p><h3 id="使用JPA"><a href="#使用JPA" class="headerlink" title="使用JPA"></a>使用JPA</h3><p>同样的，我们只需要导入stater依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>接着我们可以直接创建一个类，比如账户类，我们只需要把一个账号对应的属性全部定义好即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们可以通过注解形式，在属性上添加数据库映射关系，这样就能够让JPA知道我们的实体类对应的数据库表长啥样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span>   <span class="hljs-comment">//表示这个类是一个实体类</span><br><span class="hljs-meta">@Table(name = &quot;users&quot;)</span>    <span class="hljs-comment">//对应的数据库中表名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>   <span class="hljs-comment">//生成策略，这里配置为自增</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span>    <span class="hljs-comment">//对应表中id这一列</span><br>    <span class="hljs-meta">@Id</span>     <span class="hljs-comment">//此属性为主键</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;username&quot;)</span>   <span class="hljs-comment">//对应表中username这一列</span><br>    String username;<br><br>    <span class="hljs-meta">@Column(name = &quot;password&quot;)</span>   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span>   <span class="hljs-comment">//表示这个类是一个实体类</span><br><span class="hljs-meta">@Table(name = &quot;users&quot;)</span>    <span class="hljs-comment">//对应的数据库中表名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>   <span class="hljs-comment">//生成策略，这里配置为自增</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span>    <span class="hljs-comment">//对应表中id这一列</span><br>    <span class="hljs-meta">@Id</span>     <span class="hljs-comment">//此属性为主键</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;username&quot;)</span>   <span class="hljs-comment">//对应表中username这一列</span><br>    String username;<br><br>    <span class="hljs-meta">@Column(name = &quot;password&quot;)</span>   <span class="hljs-comment">//对应表中password这一列</span><br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来修改一下配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jpa:</span><br><span class="hljs-comment">#开启SQL语句执行日志信息</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">hibernate:</span><br>    <span class="hljs-comment">#配置为自动创建</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string"><code class="language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jpa:</span><br><span class="hljs-comment">#开启SQL语句执行日志信息</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">hibernate:</span><br>    <span class="hljs-comment">#配置为自动创建</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">create</span><br></code></pre></td></tr></table></figure><p><code>ddl-auto</code>属性用于设置自动表定义，可以实现自动在数据库中为我们创建一个表，表的结构会根据我们定义的实体类决定，它有4种</p><ul><li>create 启动时删数据库中的表，然后创建，退出时不删除数据表 </li><li>create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错 </li><li>update 如果启动时表格式不一致则更新表，原有数据保留 </li><li>validate 项目启动表结构进行校验 如果不一致则报错</li></ul><p>我们可以在日志中发现，在启动时执行了如下SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">Hibernate: <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users (id <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment, password <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), username <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), <span class="hljs-keyword">primary</span> key (id)) engine<span class="hljs-operator"><code class="language-hljs sql">Hibernate: <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users (id <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment, password <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), username <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), <span class="hljs-keyword">primary</span> key (id)) engine<span class="hljs-operator">=</span>InnoDB<br></code></pre></td></tr></table></figure><p>而我们的数据库中对应的表已经创建好了。</p><p>我们接着来看如何访问我们的表，我们需要创建一个Repository实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Account</span>, <span class="hljs-title"><code class="language-hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Account</span>, <span class="hljs-title">Integer</span>> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>注意JpaRepository有两个泛型，前者是具体操作的对象实体，也就是对应的表，后者是ID的类型，接口中已经定义了比较常用的数据库操作。编写接口继承即可，我们可以直接注入此接口获得实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaTestApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    AccountRepository repository;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//直接根据ID查找</span><br>        repository.findById(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaTestApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    AccountRepository repository;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//直接根据ID查找</span><br>        repository.findById(<span class="hljs-number">1</span>).ifPresent(System.out::println);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行后，成功得到查询结果。我们接着来测试增删操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAccount</span><span class="hljs-params">()</span></span>&#123;<br>    Account account = <span class="hljs-keyword">new</span> Account();<br>    account.setUsername(<span class="hljs-string">&quot;Admin&quot;</span>);<br>    account.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>    account = repository.save(account);  <span class="hljs-comment">//返回的结果会包含自动生成的主键值</span><br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAccount</span><span class="hljs-params">()</span></span>&#123;<br>    Account account = <span class="hljs-keyword">new</span> Account();<br>    account.setUsername(<span class="hljs-string">&quot;Admin&quot;</span>);<br>    account.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>    account = repository.save(account);  <span class="hljs-comment">//返回的结果会包含自动生成的主键值</span><br>    System.out.println(<span class="hljs-string">"插入时，自动生成的主键ID为："</span>+account.getId());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAccount</span><span class="hljs-params">()</span></span>&#123;<br>    repository.deleteById(<span class="hljs-number">2</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAccount</span><span class="hljs-params">()</span></span>&#123;<br>    repository.deleteById(<span class="hljs-number">2</span>);   <span class="hljs-comment">//根据ID删除对应记录</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pageAccount</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findAll(PageRequest.of(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)).forEach(System.out::println);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pageAccount</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findAll(PageRequest.of(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)).forEach(System.out::println);  <span class="hljs-comment">//直接分页</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，使用了JPA之后，整个项目的代码中没有出现任何的SQL语句，可以说是非常方便了，JPA依靠我们提供的注解信息自动完成了所有信息的映射和关联。</p><p>相比Mybatis，JPA几乎就是一个全自动的ORM框架，而Mybatis则顶多算是半自动ORM框架。</p><h3 id="方法名称拼接自定义SQL"><a href="#方法名称拼接自定义SQL" class="headerlink" title="方法名称拼接自定义SQL"></a>方法名称拼接自定义SQL</h3><p>虽然接口预置的方法使用起来非常方便，但是如果我们需要进行条件查询等操作或是一些判断，就需要自定义一些方法来实现，同样的，我们不需要编写SQL语句，而是通过方法名称的拼接来实现条件判断，这里列出了所有支持的条件判断名称：</p><table><thead><tr><th><code>Distinct</code></th><th><code>findDistinctByLastnameAndFirstname</code></th><th><code>select distinct … where x.lastname = ?1 and x.firstname = ?2</code></th></tr></thead><tbody><tr><td><code>And</code></td><td><code>findByLastnameAndFirstname</code></td><td><code>… where x.lastname = ?1 and x.firstname = ?2</code></td></tr><tr><td><code>Or</code></td><td><code>findByLastnameOrFirstname</code></td><td><code>… where x.lastname = ?1 or x.firstname = ?2</code></td></tr><tr><td><code>Is</code>，<code>Equals</code></td><td><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></td><td><code>… where x.firstname = ?1</code></td></tr><tr><td><code>Between</code></td><td><code>findByStartDateBetween</code></td><td><code>… where x.startDate between ?1 and ?2</code></td></tr><tr><td><code>LessThan</code></td><td><code>findByAgeLessThan</code></td><td><code>… where x.age &lt; ?1</code></td></tr><tr><td><code>LessThanEqual</code></td><td><code>findByAgeLessThanEqual</code></td><td><code>… where x.age &lt;= ?1</code></td></tr><tr><td><code>GreaterThan</code></td><td><code>findByAgeGreaterThan</code></td><td><code>… where x.age &gt; ?1</code></td></tr><tr><td><code>GreaterThanEqual</code></td><td><code>findByAgeGreaterThanEqual</code></td><td><code>… where x.age &gt;= ?1</code></td></tr><tr><td><code>After</code></td><td><code>findByStartDateAfter</code></td><td><code>… where x.startDate &gt; ?1</code></td></tr><tr><td><code>Before</code></td><td><code>findByStartDateBefore</code></td><td><code>… where x.startDate &lt; ?1</code></td></tr><tr><td><code>IsNull</code>，<code>Null</code></td><td><code>findByAge(Is)Null</code></td><td><code>… where x.age is null</code></td></tr><tr><td><code>IsNotNull</code>，<code>NotNull</code></td><td><code>findByAge(Is)NotNull</code></td><td><code>… where x.age not null</code></td></tr><tr><td><code>Like</code></td><td><code>findByFirstnameLike</code></td><td><code>… where x.firstname like ?1</code></td></tr><tr><td><code>NotLike</code></td><td><code>findByFirstnameNotLike</code></td><td><code>… where x.firstname not like ?1</code></td></tr><tr><td><code>StartingWith</code></td><td><code>findByFirstnameStartingWith</code></td><td><code>… where x.firstname like ?1</code>（参数与附加<code>%</code>绑定）</td></tr><tr><td><code>EndingWith</code></td><td><code>findByFirstnameEndingWith</code></td><td><code>… where x.firstname like ?1</code>（参数与前缀<code>%</code>绑定）</td></tr><tr><td><code>Containing</code></td><td><code>findByFirstnameContaining</code></td><td><code>… where x.firstname like ?1</code>（参数绑定以<code>%</code>包装）</td></tr><tr><td><code>OrderBy</code></td><td><code>findByAgeOrderByLastnameDesc</code></td><td><code>… where x.age = ?1 order by x.lastname desc</code></td></tr><tr><td><code>Not</code></td><td><code>findByLastnameNot</code></td><td><code>… where x.lastname &lt;&gt; ?1</code></td></tr><tr><td><code>In</code></td><td><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></td><td><code>… where x.age in ?1</code></td></tr><tr><td><code>NotIn</code></td><td><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></td><td><code>… where x.age not in ?1</code></td></tr><tr><td><code>True</code></td><td><code>findByActiveTrue()</code></td><td><code>… where x.active = true</code></td></tr><tr><td><code>False</code></td><td><code>findByActiveFalse()</code></td><td><code>… where x.active = false</code></td></tr><tr><td><code>IgnoreCase</code></td><td><code>findByFirstnameIgnoreCase</code></td><td><code>… where UPPER(x.firstname) = UPPER(?1)</code></td></tr></tbody></table><p>比如我们想要实现根据用户名模糊匹配查找用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Account</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br><span class="hljs-comment">//按照表中的规则进行名称拼接，不用刻意去记，IDEA会有提示</span><br>    <span class="hljs-function">List&lt;Account&gt; <span class="hljs-title">findAllByUsernameLike</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Account</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br><span class="hljs-comment">//按照表中的规则进行名称拼接，不用刻意去记，IDEA会有提示</span><br>    <span class="hljs-function">List&lt;Account&gt; <span class="hljs-title">findAllByUsernameLike</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findAllByUsernameLike(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findAllByUsernameLike(<span class="hljs-string">"%T%"</span>).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>又比如我们想同时根据用户名和ID一起查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Account</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br><br>    <span class="hljs-function">Account <span class="hljs-title">findByIdAndUsername</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String username)</span></span>;<br>  <span class="hljs-comment">//可以使用Optional类进行包装，Optional&lt;Account&gt; findByIdAndUsername(int id, String username);</span><br>    <br>    <span class="hljs-function">List&lt;Account&gt; <span class="hljs-title">findAllByUsernameLike</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Account</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br><br>    <span class="hljs-function">Account <span class="hljs-title">findByIdAndUsername</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String username)</span></span>;<br>  <span class="hljs-comment">//可以使用Optional类进行包装，Optional&lt;Account&gt; findByIdAndUsername(int id, String username);</span><br>    <br>    <span class="hljs-function">List&lt;Account&gt; <span class="hljs-title">findAllByUsernameLike</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(repository.findByIdAndUsername(<span class="hljs-number">1</span>, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(repository.findByIdAndUsername(<span class="hljs-number">1</span>, <span class="hljs-string">"Test"</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们想判断数据库中是否存在某个ID的用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Account</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br><br>    <span class="hljs-function">Account <span class="hljs-title">findByIdAndUsername</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String username)</span></span>;<br><br>    <span class="hljs-function">List&lt;Account&gt; <span class="hljs-title">findAllByUsernameLike</span><span class="hljs-params">(String str)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">existsAccountById</span><span class="hljs-params">(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Account</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br><br>    <span class="hljs-function">Account <span class="hljs-title">findByIdAndUsername</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String username)</span></span>;<br><br>    <span class="hljs-function">List&lt;Account&gt; <span class="hljs-title">findAllByUsernameLike</span><span class="hljs-params">(String str)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">existsAccountById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(repository.existsAccountByUsername(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(repository.existsAccountByUsername(<span class="hljs-string">"Test"</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>注意自定义条件操作的方法名称一定要遵循规则，不然会出现异常：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs stylus">Caused by: org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.repository</span><span class="hljs-selector-class">.query</span><span class="hljs-selector-class">.QueryCreationException</span>: Could not create query <span class="hljs-keyword"><code class="language-hljs stylus">Caused by: org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.repository</span><span class="hljs-selector-class">.query</span><span class="hljs-selector-class">.QueryCreationException</span>: Could not create query <span class="hljs-keyword">for</span> public abstract  ...<br></code></pre></td></tr></table></figure><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>在实际开发中，比较常见的场景还有关联查询，也就是我们会在表中添加一个外键字段，而此外键字段又指向了另一个表中的数据，当我们查询数据时，可能会需要将关联数据也一并获取，比如我们想要查询某个用户的详细信息，一般用户简略信息会单独存放一个表，而用户详细信息会单独存放在另一个表中。当然，除了用户详细信息之外，可能在某些电商平台还会有用户的购买记录、用户的购物车，交流社区中的用户帖子、用户评论等，这些都是需要根据用户信息进行关联查询的内容。</p><p><img src="https://img1.baidu.com/it/u=292198351,4011695440&fm=253&fmt=auto&app=138&f=JPEG?w=404&h=436" alt="img"></p><p>我们知道，在JPA中，每张表实际上就是一个实体类的映射，而表之间的关联关系，也可以看作对象之间的依赖关系，比如用户表中包含了用户详细信息的ID字段作为外键，那么实际上就是用户表实体中包括了用户详细信息实体对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users_detail&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountDetail</span> </span>&#123;<br><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;address&quot;)</span><br>    String address;<br><br>    <span class="hljs-meta">@Column(name = &quot;email&quot;)</span><br>    String email;<br><br>    <span class="hljs-meta">@Column(name = &quot;phone&quot;)</span><br>    String phone;<br><br>    <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users_detail&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountDetail</span> </span>&#123;<br><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;address&quot;)</span><br>    String address;<br><br>    <span class="hljs-meta">@Column(name = &quot;email&quot;)</span><br>    String email;<br><br>    <span class="hljs-meta">@Column(name = &quot;phone&quot;)</span><br>    String phone;<br><br>    <span class="hljs-meta">@Column(name = "real_name")</span><br>    String realName;<br>&#125;<br></code></pre></td></tr></table></figure><p>而用户信息和用户详细信息之间形成了一对一的关系，那么这时我们就可以直接在类中指定这种关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;username&quot;)</span><br>    String username;<br><br>    <span class="hljs-meta">@Column(name = &quot;password&quot;)</span><br>    String password;<br><br>    <span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span>   <span class="hljs-comment">//指定存储外键的字段名称</span><br>    <span class="hljs-meta">@OneToOne</span>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;username&quot;)</span><br>    String username;<br><br>    <span class="hljs-meta">@Column(name = &quot;password&quot;)</span><br>    String password;<br><br>    <span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span>   <span class="hljs-comment">//指定存储外键的字段名称</span><br>    <span class="hljs-meta">@OneToOne</span>    <span class="hljs-comment">//声明为一对一关系</span><br>    AccountDetail detail;<br>&#125;<br></code></pre></td></tr></table></figure><p>在修改实体类信息后，我们发现在启动时也进行了更新，日志如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sql">Hibernate: <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> users <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> detail_id <span class="hljs-type">integer</span><br>Hibernate: <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users_detail (id <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment, address <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), phone <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), real_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), <span class="hljs-keyword">primary</span> key (id)) engine<span class="hljs-operator">=</span>InnoDB<br>Hibernate: <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> users <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK7gb021edkxf3mdv5bs75ni6jd <span class="hljs-keyword">foreign</span> key (detail_id) <span class="hljs-keyword"><code class="language-hljs sql">Hibernate: <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> users <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> detail_id <span class="hljs-type">integer</span><br>Hibernate: <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users_detail (id <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment, address <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), phone <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), real_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), <span class="hljs-keyword">primary</span> key (id)) engine<span class="hljs-operator">=</span>InnoDB<br>Hibernate: <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> users <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK7gb021edkxf3mdv5bs75ni6jd <span class="hljs-keyword">foreign</span> key (detail_id) <span class="hljs-keyword">references</span> users_detail (id)<br></code></pre></td></tr></table></figure><p>是不是感觉非常方便！都懒得去手动改表结构了。</p><p>接着我们往用户详细信息中添加一些数据，一会我们可以直接进行查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pageAccount</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findById(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pageAccount</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>查询后，可以发现，得到如下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs apache"><span class="hljs-attribute">Hibernate</span>: select account<span class="hljs-number">0</span>_.id as id<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.detail_id as detail_i<span class="hljs-number">4</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.password as password<span class="hljs-number">2</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.username as username<span class="hljs-number">3</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, accountdet<span class="hljs-number">1</span>_.id as id<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_, accountdet<span class="hljs-number">1</span>_.address as address<span class="hljs-number">2</span>_<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_, accountdet<span class="hljs-number">1</span>_.email as email<span class="hljs-number">3</span>_<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_, accountdet<span class="hljs-number">1</span>_.phone as phone<span class="hljs-number">4</span>_<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_, accountdet<span class="hljs-number">1</span>_.real_name as real_nam<span class="hljs-number">5</span>_<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_ from users account<span class="hljs-number">0</span>_ left outer join users_detail accountdet<span class="hljs-number">1</span>_ <span class="hljs-literal">on</span> account<span class="hljs-number">0</span>_.detail_id=accountdet<span class="hljs-number">1</span>_.id where account<span class="hljs-number">0</span>_.id=?<br><span class="hljs-attribute">Account</span>(id=<span class="hljs-number">1</span>, username=Test, password=<span class="hljs-number">123456</span>, detail=AccountDetail(id=<span class="hljs-number">1</span>, address=四川省成都市青羊区, email=<span class="hljs-number">8371289</span>@qq.com, phone=<span class="hljs-number"><code class="language-hljs apache"><span class="hljs-attribute">Hibernate</span>: select account<span class="hljs-number">0</span>_.id as id<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.detail_id as detail_i<span class="hljs-number">4</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.password as password<span class="hljs-number">2</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.username as username<span class="hljs-number">3</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, accountdet<span class="hljs-number">1</span>_.id as id<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_, accountdet<span class="hljs-number">1</span>_.address as address<span class="hljs-number">2</span>_<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_, accountdet<span class="hljs-number">1</span>_.email as email<span class="hljs-number">3</span>_<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_, accountdet<span class="hljs-number">1</span>_.phone as phone<span class="hljs-number">4</span>_<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_, accountdet<span class="hljs-number">1</span>_.real_name as real_nam<span class="hljs-number">5</span>_<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_ from users account<span class="hljs-number">0</span>_ left outer join users_detail accountdet<span class="hljs-number">1</span>_ <span class="hljs-literal">on</span> account<span class="hljs-number">0</span>_.detail_id=accountdet<span class="hljs-number">1</span>_.id where account<span class="hljs-number">0</span>_.id=?<br><span class="hljs-attribute">Account</span>(id=<span class="hljs-number">1</span>, username=Test, password=<span class="hljs-number">123456</span>, detail=AccountDetail(id=<span class="hljs-number">1</span>, address=四川省成都市青羊区, email=<span class="hljs-number">8371289</span>@qq.com, phone=<span class="hljs-number">1234567890</span>, realName=本伟))<br></code></pre></td></tr></table></figure><p>也就是，在建立关系之后，我们查询Account对象时，会自动将关联数据的结果也一并进行查询。</p><p>那要是我们只想要Account的数据，不想要用户详细信息数据怎么办呢？我希望在我要用的时候再获取详细信息，这样可以节省一些网络开销，我们可以设置懒加载，这样只有在需要时才会向数据库获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span><br><span class="hljs-meta">@OneToOne(fetch = FetchType.LAZY)</span>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span><br><span class="hljs-meta">@OneToOne(fetch = FetchType.LAZY)</span>    <span class="hljs-comment">//将获取类型改为LAZY</span><br>AccountDetail detail;<br></code></pre></td></tr></table></figure><p>接着我们测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Transactional</span>   <span class="hljs-comment">//懒加载属性需要在事务环境下获取，因为repository方法调用完后Session会立即关闭</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pageAccount</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(account -&gt; &#123;<br>        System.out.println(account.getUsername());   <span class="hljs-comment">//获取用户名</span><br>        System.out.println(account.getDetail());  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@Transactional</span>   <span class="hljs-comment">//懒加载属性需要在事务环境下获取，因为repository方法调用完后Session会立即关闭</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pageAccount</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(account -&gt; &#123;<br>        System.out.println(account.getUsername());   <span class="hljs-comment">//获取用户名</span><br>        System.out.println(account.getDetail());  <span class="hljs-comment">//获取详细信息（懒加载）</span><br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看看控制台输出了什么：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs apache"><span class="hljs-attribute">Hibernate</span>: select account<span class="hljs-number">0</span>_.id as id<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.detail_id as detail_i<span class="hljs-number">4</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.password as password<span class="hljs-number">2</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.username as username<span class="hljs-number">3</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_ from users account<span class="hljs-number">0</span>_ where account<span class="hljs-number">0</span>_.id=?<br><span class="hljs-attribute">Test</span><br><span class="hljs-attribute">Hibernate</span>: select accountdet<span class="hljs-number">0</span>_.id as id<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_, accountdet<span class="hljs-number">0</span>_.address as address<span class="hljs-number">2</span>_<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_, accountdet<span class="hljs-number">0</span>_.email as email<span class="hljs-number">3</span>_<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_, accountdet<span class="hljs-number">0</span>_.phone as phone<span class="hljs-number">4</span>_<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_, accountdet<span class="hljs-number">0</span>_.real_name as real_nam<span class="hljs-number">5</span>_<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_ from users_detail accountdet<span class="hljs-number">0</span>_ where accountdet<span class="hljs-number">0</span>_.id=?<br><span class="hljs-attribute">AccountDetail</span>(id=<span class="hljs-number">1</span>, address=四川省成都市青羊区, email=<span class="hljs-number">8371289</span>@qq.com, phone=<span class="hljs-number"><code class="language-hljs apache"><span class="hljs-attribute">Hibernate</span>: select account<span class="hljs-number">0</span>_.id as id<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.detail_id as detail_i<span class="hljs-number">4</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.password as password<span class="hljs-number">2</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_, account<span class="hljs-number">0</span>_.username as username<span class="hljs-number">3</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_ from users account<span class="hljs-number">0</span>_ where account<span class="hljs-number">0</span>_.id=?<br><span class="hljs-attribute">Test</span><br><span class="hljs-attribute">Hibernate</span>: select accountdet<span class="hljs-number">0</span>_.id as id<span class="hljs-number">1</span>_<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_, accountdet<span class="hljs-number">0</span>_.address as address<span class="hljs-number">2</span>_<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_, accountdet<span class="hljs-number">0</span>_.email as email<span class="hljs-number">3</span>_<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_, accountdet<span class="hljs-number">0</span>_.phone as phone<span class="hljs-number">4</span>_<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_, accountdet<span class="hljs-number">0</span>_.real_name as real_nam<span class="hljs-number">5</span>_<span class="hljs-number">1</span>_<span class="hljs-number">0</span>_ from users_detail accountdet<span class="hljs-number">0</span>_ where accountdet<span class="hljs-number">0</span>_.id=?<br><span class="hljs-attribute">AccountDetail</span>(id=<span class="hljs-number">1</span>, address=四川省成都市青羊区, email=<span class="hljs-number">8371289</span>@qq.com, phone=<span class="hljs-number">1234567890</span>, realName=卢本)<br></code></pre></td></tr></table></figure><p>可以看到，获取用户名之前，并没有去查询用户的详细信息，而是当我们获取详细信息时才进行查询并返回AccountDetail对象。</p><p>那么我们是否也可以在添加数据时，利用实体类之间的关联信息，一次性添加两张表的数据呢？可以，但是我们需要稍微修改一下级联关联操作设定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span><br><span class="hljs-meta">@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)</span> <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span><br><span class="hljs-meta">@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)</span> <span class="hljs-comment">//设置关联操作为ALL</span><br>AccountDetail detail;<br></code></pre></td></tr></table></figure><ul><li>ALL：所有操作都进行关联操作</li><li>PERSIST：插入操作时才进行关联操作</li><li>REMOVE：删除操作时才进行关联操作</li><li>MERGE：修改操作时才进行关联操作</li></ul><p>可以多个并存，接着我们来进行一下测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAccount</span><span class="hljs-params">()</span></span>&#123;<br>    Account account = <span class="hljs-keyword">new</span> Account();<br>    account.setUsername(<span class="hljs-string">&quot;Nike&quot;</span>);<br>    account.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>    AccountDetail detail = <span class="hljs-keyword">new</span> AccountDetail();<br>    detail.setAddress(<span class="hljs-string">&quot;重庆市渝中区解放碑&quot;</span>);<br>    detail.setPhone(<span class="hljs-string">&quot;1234567890&quot;</span>);<br>    detail.setEmail(<span class="hljs-string">&quot;73281937@qq.com&quot;</span>);<br>    detail.setRealName(<span class="hljs-string">&quot;张三&quot;</span>);<br>  account.setDetail(detail);<br>    account = repository.save(account);<br>    System.out.println(<span class="hljs-string">&quot;插入时，自动生成的主键ID为：&quot;</span>+account.getId()+<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAccount</span><span class="hljs-params">()</span></span>&#123;<br>    Account account = <span class="hljs-keyword">new</span> Account();<br>    account.setUsername(<span class="hljs-string">&quot;Nike&quot;</span>);<br>    account.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>    AccountDetail detail = <span class="hljs-keyword">new</span> AccountDetail();<br>    detail.setAddress(<span class="hljs-string">&quot;重庆市渝中区解放碑&quot;</span>);<br>    detail.setPhone(<span class="hljs-string">&quot;1234567890&quot;</span>);<br>    detail.setEmail(<span class="hljs-string">&quot;73281937@qq.com&quot;</span>);<br>    detail.setRealName(<span class="hljs-string">&quot;张三&quot;</span>);<br>  account.setDetail(detail);<br>    account = repository.save(account);<br>    System.out.println(<span class="hljs-string">&quot;插入时，自动生成的主键ID为：&quot;</span>+account.getId()+<span class="hljs-string">"，外键ID为："</span>+account.getDetail().getId());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到日志结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sql">Hibernate: <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users_detail (address, email, phone, real_name) <span class="hljs-keyword">values</span> (?, ?, ?, ?)<br>Hibernate: <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users (detail_id, password, username) <span class="hljs-keyword">values</span> (?, ?, ?)<br>插入时，自动生成的主键ID为：<span class="hljs-number">6</span>，外键ID为：<span class="hljs-number"><code class="language-hljs sql">Hibernate: <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users_detail (address, email, phone, real_name) <span class="hljs-keyword">values</span> (?, ?, ?, ?)<br>Hibernate: <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users (detail_id, password, username) <span class="hljs-keyword">values</span> (?, ?, ?)<br>插入时，自动生成的主键ID为：<span class="hljs-number">6</span>，外键ID为：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>结束后会发现数据库中两张表都同时存在数据。</p><p>接着我们来看一对多关联，比如每个用户的成绩信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;uid&quot;)</span>  <span class="hljs-comment">//注意这里的name指的是Score表中的uid字段对应的就是当前的主键，会将uid外键设置为当前的主键</span><br><span class="hljs-meta">@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)</span>   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;uid&quot;)</span>  <span class="hljs-comment">//注意这里的name指的是Score表中的uid字段对应的就是当前的主键，会将uid外键设置为当前的主键</span><br><span class="hljs-meta">@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)</span>   <span class="hljs-comment">//在移除Account时，一并移除所有的成绩信息，依然使用懒加载</span><br>List<Score> scoreList;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users_score&quot;)</span>   <span class="hljs-comment">//成绩表，注意只存成绩，不存学科信息，学科信息id做外键</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span> </span>&#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-meta">@OneToOne</span>   <span class="hljs-comment">//一对一对应到学科上</span><br>    <span class="hljs-meta">@JoinColumn(name = &quot;cid&quot;)</span><br>    Subject subject;<br><br>    <span class="hljs-meta">@Column(name = &quot;socre&quot;)</span><br>    <span class="hljs-keyword">double</span> score;<br><br>    <span class="hljs-meta">@Column(name = &quot;uid&quot;)</span><br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users_score&quot;)</span>   <span class="hljs-comment">//成绩表，注意只存成绩，不存学科信息，学科信息id做外键</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span> </span>&#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-meta">@OneToOne</span>   <span class="hljs-comment">//一对一对应到学科上</span><br>    <span class="hljs-meta">@JoinColumn(name = &quot;cid&quot;)</span><br>    Subject subject;<br><br>    <span class="hljs-meta">@Column(name = &quot;socre&quot;)</span><br>    <span class="hljs-keyword">double</span> score;<br><br>    <span class="hljs-meta">@Column(name = &quot;uid&quot;)</span><br>    <span class="hljs-keyword">int</span> uid;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;subjects&quot;)</span>   <span class="hljs-comment">//学科信息表</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;cid&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">int</span> cid;<br><br>    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span><br>    String name;<br><br>    <span class="hljs-meta">@Column(name = &quot;teacher&quot;)</span><br>    String teacher;<br><br>    <span class="hljs-meta">@Column(name = &quot;time&quot;)</span><br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;subjects&quot;)</span>   <span class="hljs-comment">//学科信息表</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;cid&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">int</span> cid;<br><br>    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span><br>    String name;<br><br>    <span class="hljs-meta">@Column(name = &quot;teacher&quot;)</span><br>    String teacher;<br><br>    <span class="hljs-meta">@Column(name = &quot;time&quot;)</span><br>    <span class="hljs-keyword">int</span> time;<br>&#125;<br></code></pre></td></tr></table></figure><p>在数据库中填写相应数据，接着我们就可以查询用户的成绩信息了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findById(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(account -> &#123;<br>        account.getScoreList().forEach(System.out::println);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>成功得到用户所有的成绩信息，包括得分和学科信息。</p><p>同样的，我们还可以将对应成绩中的教师信息单独分出一张表存储，并建立多对一的关系，因为多门课程可能由同一个老师教授（千万别搞晕了，一定要理清楚关联关系，同时也是考验你的基础扎不扎实）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@ManyToOne(fetch = FetchType.LAZY)</span><br><span class="hljs-meta">@JoinColumn(name = &quot;tid&quot;)</span>   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@ManyToOne(fetch = FetchType.LAZY)</span><br><span class="hljs-meta">@JoinColumn(name = &quot;tid&quot;)</span>   <span class="hljs-comment">//存储教师ID的字段，和一对一是一样的，也会当前表中创个外键</span><br>Teacher teacher;<br></code></pre></td></tr></table></figure><p>接着就是教师实体类了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;teachers&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span><br>    String name;<br><br>    <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;teachers&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span><br>    String name;<br><br>    <span class="hljs-meta">@Column(name = "sex")</span><br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们再进行一下测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findById(<span class="hljs-number">3</span>).ifPresent(account -&gt; &#123;<br>        account.getScoreList().forEach(score -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;课程名称：&quot;</span>+score.getSubject().getName());<br>            System.out.println(<span class="hljs-string">&quot;得分：&quot;</span>+score.getScore());<br>            System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    repository.findById(<span class="hljs-number">3</span>).ifPresent(account -&gt; &#123;<br>        account.getScoreList().forEach(score -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;课程名称：&quot;</span>+score.getSubject().getName());<br>            System.out.println(<span class="hljs-string">&quot;得分：&quot;</span>+score.getScore());<br>            System.out.println(<span class="hljs-string">"任课教师："</span>+score.getSubject().getTeacher().getName());<br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>成功得到多对一的教师信息。</p><p>最后我们再来看最复杂的情况，现在我们一门课程可以由多个老师教授，而一个老师也可以教授多个课程，那么这种情况就是很明显的多对多场景，现在又该如何定义呢？我们可以像之前一样，插入一张中间表表示教授关系，这个表中专门存储哪个老师教哪个科目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@ManyToMany(fetch = FetchType.LAZY)</span>   <span class="hljs-comment">//多对多场景</span><br><span class="hljs-meta">@JoinTable(name = &quot;teach_relation&quot;,     //多对多中间关联表</span><br><span class="hljs-meta">        joinColumns = @JoinColumn(name = &quot;cid&quot;),    //当前实体主键在关联表中的字段名称</span><br><span class="hljs-meta">        inverseJoinColumns = @JoinColumn(name = &quot;tid&quot;)   //教师实体主键在关联表中的字段名称</span><br><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@ManyToMany(fetch = FetchType.LAZY)</span>   <span class="hljs-comment">//多对多场景</span><br><span class="hljs-meta">@JoinTable(name = &quot;teach_relation&quot;,     //多对多中间关联表</span><br><span class="hljs-meta">        joinColumns = @JoinColumn(name = &quot;cid&quot;),    //当前实体主键在关联表中的字段名称</span><br><span class="hljs-meta">        inverseJoinColumns = @JoinColumn(name = &quot;tid&quot;)   //教师实体主键在关联表中的字段名称</span><br><span class="hljs-meta">)</span><br>List<Teacher> teacher;<br></code></pre></td></tr></table></figure><p>接着，JPA会自动创建一张中间表，并自动设置外键，我们就可以将多对多关联信息编写在其中了。</p><h3 id="JPQL自定义SQL语句"><a href="#JPQL自定义SQL语句" class="headerlink" title="JPQL自定义SQL语句"></a>JPQL自定义SQL语句</h3><p>虽然SpringDataJPA能够简化大部分数据获取场景，但是难免会有一些特殊的场景，需要使用复杂查询才能够去完成，这时你又会发现，如果要实现，只能用回Mybatis了，因为我们需要自己手动编写SQL语句，过度依赖SpringDataJPA会使得SQL语句不可控。</p><p>使用JPA，我们也可以像Mybatis那样，直接编写SQL语句，不过它是JPQL语言，与原生SQL语句很类似，但是它是面向对象的，当然我们也可以编写原生SQL语句。</p><p>比如我们要更新用户表中指定ID用户的密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Account</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-comment">//DML操作需要事务环境，可以不在这里声明，但是调用时一定要处于事务环境下</span><br>    <span class="hljs-meta">@Modifying</span>     <span class="hljs-comment">//表示这是一个DML操作</span><br>    <span class="hljs-meta">@Query(&quot;update Account set password = ?2 where id = ?1&quot;)</span> <span class="hljs-comment">//这里操作的是一个实体类对应的表，参数使用?代表，后面接第n个参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updatePasswordById</span><span class="hljs-params">(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Account</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-comment">//DML操作需要事务环境，可以不在这里声明，但是调用时一定要处于事务环境下</span><br>    <span class="hljs-meta">@Modifying</span>     <span class="hljs-comment">//表示这是一个DML操作</span><br>    <span class="hljs-meta">@Query(&quot;update Account set password = ?2 where id = ?1&quot;)</span> <span class="hljs-comment">//这里操作的是一个实体类对应的表，参数使用?代表，后面接第n个参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updatePasswordById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String newPassword)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">()</span></span>&#123;<br>    repository.updatePasswordById(<span class="hljs-number">1</span>, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">()</span></span>&#123;<br>    repository.updatePasswordById(<span class="hljs-number">1</span>, <span class="hljs-string">"654321"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我想使用原生SQL来实现根据用户名称修改密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Modifying</span><br><span class="hljs-meta">@Query(value = &quot;update users set password = :pwd where username = :name&quot;, nativeQuery = true)</span> <span class="hljs-comment">//使用原生SQL，和Mybatis一样，这里使用 :名称 表示参数，当然也可以继续用上面那种方式。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updatePasswordByUsername</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String username,   //我们可以使用<span class="hljs-meta">@Param</span>指定名称</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Modifying</span><br><span class="hljs-meta">@Query(value = &quot;update users set password = :pwd where username = :name&quot;, nativeQuery = true)</span> <span class="hljs-comment">//使用原生SQL，和Mybatis一样，这里使用 :名称 表示参数，当然也可以继续用上面那种方式。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updatePasswordByUsername</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String username,   //我们可以使用<span class="hljs-meta">@Param</span>指定名称</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-meta">@Param("pwd")</span> String newPassword)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">()</span></span>&#123;<br>    repository.updatePasswordByUsername(<span class="hljs-string">&quot;Admin&quot;</span>, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">()</span></span>&#123;<br>    repository.updatePasswordByUsername(<span class="hljs-string">&quot;Admin&quot;</span>, <span class="hljs-string">"654321"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过编写原生SQL，在一定程度上弥补了SQL不可控的问题。</p><p>虽然JPA能够为我们带来非常便捷的开发体验，但是正式因为太便捷了，保姆级的体验有时也会适得其反，可能项目开发到后期特别庞大时，就只能从底层SQL语句开始进行优化，而由于JPA尽可能地在屏蔽我们对SQL语句的编写，所以后期优化是个大问题，并且Hibernate相对于Mybatis来说，更加重量级。不过，在微服务的时代，单体项目一般不会太大，而JPA的劣势并没有太明显地体现出来。</p><p>有关Mybatis和JPA的对比，可以参考：<a href="https://blog.csdn.net/u010253246/article/details/105731204">https://blog.csdn.net/u010253246/article/details/105731204</a></p><hr><h2 id="Extra-前后端分离跨域处理"><a href="#Extra-前后端分离跨域处理" class="headerlink" title="Extra. 前后端分离跨域处理"></a>Extra. 前后端分离跨域处理</h2><p>我们的项目已经处于前后端分离状态了，那么前后端分离状态和我们之前的状态有什么区别的呢？</p><ul><li><strong>不分离：</strong>前端页面看到的都是由后端控制，由后端渲染页面或重定向，后端需要控制前端的展示，前端与后端的耦合度很高。比如我们之前都是使用后端来执行重定向操作或是使用Thymeleaf来填充数据，而最终返回的是整个渲染好的页。</li></ul><p><img src="https://img2018.cnblogs.com/blog/1394466/201809/1394466-20180916231510365-285933655.png" alt="img"></p><ul><li><strong>分离：</strong>后端仅返回前端所需的数据，不再渲染HTML页面，不再控制前端的效果。至于前端用户看到什么效果，从后端请求的数据如何加载到前端中，都由前端通过JS等进行动态数据填充和渲染。这样后端只返回JSON数据，前端处理JSON数据并展示，这样前后端的职责就非常明确了。</li></ul><p><img src="https://img2018.cnblogs.com/blog/1394466/201809/1394466-20180916231716242-1862208927.png" alt="img"></p><p>实现前后端分离有两种方案，一种是直接放入SpringBoot的资源文件夹下，但是这样实际上还是在依靠SpringBoot内嵌的Tomcat服务器进行页面和静态资源的发送，我们现在就是这种方案。</p><p>另一种方案就是直接将所有的页面和静态资源单独放到代理服务器上（如Nginx），这样我们后端服务器就不必再处理静态资源和页面了，专心返回数据即可，而前端页面就需要访问另一个服务器来获取，虽然逻辑和明确，但是这样会出现跨域问题，实际上就是我们之前所说的跨站请求伪造，为了防止这种不安全的行为发生，所以对异步请求会进行一定的限制。</p><p>这里，我们将前端页面和后端页面直接分离进行测试，在登陆时得到如下错误：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs pgsql"><span class="hljs-keyword">Access</span> <span class="hljs-keyword">to</span> XMLHttpRequest at <span class="hljs-string">&#x27;http://localhost:8080/api/auth/login&#x27;</span> <span class="hljs-keyword">from</span> origin <span class="hljs-string">&#x27;http://localhost:63342&#x27;</span> has been blocked <span class="hljs-keyword">by</span> CORS <span class="hljs-keyword">policy</span>: <span class="hljs-keyword">No</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-keyword">header</span> <span class="hljs-keyword">is</span> present <span class="hljs-keyword"><code class="language-hljs pgsql"><span class="hljs-keyword">Access</span> <span class="hljs-keyword">to</span> XMLHttpRequest at <span class="hljs-string">&#x27;http://localhost:8080/api/auth/login&#x27;</span> <span class="hljs-keyword">from</span> origin <span class="hljs-string">&#x27;http://localhost:63342&#x27;</span> has been blocked <span class="hljs-keyword">by</span> CORS <span class="hljs-keyword">policy</span>: <span class="hljs-keyword">No</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-keyword">header</span> <span class="hljs-keyword">is</span> present <span class="hljs-keyword">on</span> the requested resource.<br></code></pre></td></tr></table></figure><p>可以很清楚地看到，在Ajax发送异步请求时，我们的请求被阻止，原因是在响应头中没有包含<code>Access-Control-Allow-Origin</code>，也就表示，如果服务端允许跨域请求，那么会在响应头中添加一个<code>Access-Control-Allow-Origin</code>字段，如果不允许跨域，就像现在这样。那么，什么才算是跨域呢：</p><ol><li>请求协议<code>如http、https</code>不同</li><li>请求的地址/域名不同</li><li>端口不同</li></ol><p>因为我们现在相当于前端页面访问的是静态资源服务器，而后端数据是由我们的SpringBoot项目提供，它们是两个不同的服务器，所以在垮服务器请求资源时，会被判断为存在安全风险。</p><p>但是现在，由于我们前后端是分离状态，我们希望的是能够实现跨域请求，这时我们就需要添加一个过滤器来处理跨域问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//创建CorsConfiguration对象后添加配置</span><br>    CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();<br>    <span class="hljs-comment">//设置放行哪些原始域，这里直接设置为所有</span><br>    config.addAllowedOriginPattern(<span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-comment">//你可以单独设置放行哪些原始域 config.addAllowedOrigin(&quot;http://localhost:2222&quot;);</span><br>    <span class="hljs-comment">//放行哪些原始请求头部信息</span><br>    config.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-comment">//放行哪些请求方式，*代表所有</span><br>    config.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-comment">//是否允许发送Cookie，必须要开启，因为我们的JSESSIONID需要在Cookie中携带</span><br>    config.setAllowCredentials(<span class="hljs-keyword">true</span>);<br>    <span class="hljs-comment">//映射路径</span><br>    UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();<br>    corsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, config);<br>    <span class="hljs-comment">//返回CorsFilter</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//创建CorsConfiguration对象后添加配置</span><br>    CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();<br>    <span class="hljs-comment">//设置放行哪些原始域，这里直接设置为所有</span><br>    config.addAllowedOriginPattern(<span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-comment">//你可以单独设置放行哪些原始域 config.addAllowedOrigin(&quot;http://localhost:2222&quot;);</span><br>    <span class="hljs-comment">//放行哪些原始请求头部信息</span><br>    config.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-comment">//放行哪些请求方式，*代表所有</span><br>    config.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-comment">//是否允许发送Cookie，必须要开启，因为我们的JSESSIONID需要在Cookie中携带</span><br>    config.setAllowCredentials(<span class="hljs-keyword">true</span>);<br>    <span class="hljs-comment">//映射路径</span><br>    UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();<br>    corsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, config);<br>    <span class="hljs-comment">//返回CorsFilter</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(corsConfigurationSource);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们的SpringBoot项目就支持跨域访问了，接着我们再来尝试进行登陆，可以发现已经能够正常访问了，并且响应头中包含了以下信息：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs oxygene">Vary: Access-Control-Request-<span class="hljs-function"><span class="hljs-keyword">Method</span></span><br><span class="hljs-function"><span class="hljs-title">Vary</span>:</span> Access-Control-Request-Headers<br>Access-Control-Allow-Origin: http:<span class="hljs-comment">//localhost:63342</span><br>Access-Control-Expose-Headers: *<br>Access-Control-Allow-Credentials: <span class="hljs-keyword"><code class="language-hljs oxygene">Vary: Access-Control-Request-<span class="hljs-function"><span class="hljs-keyword">Method</span></span><br><span class="hljs-function"><span class="hljs-title">Vary</span>:</span> Access-Control-Request-Headers<br>Access-Control-Allow-Origin: http:<span class="hljs-comment">//localhost:63342</span><br>Access-Control-Expose-Headers: *<br>Access-Control-Allow-Credentials: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>可以看到我们当前访问的原始域已经被放行了。</p><p>但是还有一个问题，我们的Ajax请求中没有携带Cookie信息（这个按理说属于前端知识了）这里我们稍微改一下，不然我们的请求无法确认身份：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, success</span>)</span>&#123;<br>    $.ajax(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;get&quot;</span>,<br>        <span class="hljs-attr">url</span>: url,<br>        <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>        <span class="hljs-attr">xhrFields</span>: &#123;<br>            <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>        &#125;,<br>        <span class="hljs-attr">success</span>: success<br>    &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>(<span class="hljs-params">url, data, success</span>)</span>&#123;<br>    $.ajax(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;post&quot;</span>,<br>        <span class="hljs-attr">url</span>: url,<br>        <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">data</span>: data,<br>        <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>        <span class="hljs-attr">xhrFields</span>: &#123;<br>            <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>        &#125;,<br>        <span class="hljs-attr"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, success</span>)</span>&#123;<br>    $.ajax(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;get&quot;</span>,<br>        <span class="hljs-attr">url</span>: url,<br>        <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>        <span class="hljs-attr">xhrFields</span>: &#123;<br>            <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>        &#125;,<br>        <span class="hljs-attr">success</span>: success<br>    &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>(<span class="hljs-params">url, data, success</span>)</span>&#123;<br>    $.ajax(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;post&quot;</span>,<br>        <span class="hljs-attr">url</span>: url,<br>        <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">data</span>: data,<br>        <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>        <span class="hljs-attr">xhrFields</span>: &#123;<br>            <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>        &#125;,<br>        <span class="hljs-attr">success</span>: success<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>添加两个封装好的方法，并且将<code>withCredentials</code>开启，这样在发送异步请求时，就会携带Cookie信息了。</p><p> 在学习完成Linux之后，我们会讲解如何在Linux服务器上部署Nginx反向代理服务器。</p><hr><h2 id="接口管理：Swagger"><a href="#接口管理：Swagger" class="headerlink" title="接口管理：Swagger"></a>接口管理：Swagger</h2><p>在前后端分离项目中，前端人员需要知道我们后端会提供什么数据，根据后端提供的数据来进行前端页面渲染（在之前我们也演示过）这个时候，我们就需要编写一个API文档，以便前端人员随时查阅。</p><p>但是这样的一个文档，我们也不可能单独写一个项目去进行维护，并且随着我们的后端项目不断更新，文档也需要跟随更新，这显然是很麻烦的一件事情，那么有没有一种比较好的解决方案呢？</p><p>当然有，那就是丝袜哥：Swagger</p><h3 id="走进Swagger"><a href="#走进Swagger" class="headerlink" title="走进Swagger"></a>走进Swagger</h3><p>Swagger的主要功能如下：</p><ul><li>支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。</li><li>提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。</li></ul><p>结合Spring框架（Spring-fox），Swagger可以很轻松地利用注解以及扫描机制，来快速生成在线文档，以实现当我们项目启动之后，前端开发人员就可以打开Swagger提供的前端页面，查看和测试接口。依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>SpringBoot 2.6以上版本修改了路径匹配规则，但是Swagger3还不支持，这里换回之前的，不然启动直接报错：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">mvc:</span><br><span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string"><code class="language-hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">mvc:</span><br><span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ant_path_matcher</span><br></code></pre></td></tr></table></figure><p>项目启动后，我们可以直接打开：<a href="http://localhost:8080/swagger-ui/index.html%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%88%E8%A6%81%E6%98%AF%E8%A7%89%E5%BE%97%E4%B8%91%EF%BC%8CUI%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%8D%A2%E7%9A%84%EF%BC%8C%E6%94%AF%E6%8C%81%E7%AC%AC%E4%B8%89%E6%96%B9%EF%BC%89%E4%BC%9A%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E7%9A%84API%E6%96%87%E6%A1%A3%EF%BC%8C%E5%8C%85%E6%8B%AC%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%81%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AD%89%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%AF%B9API%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%96%B9%E4%BE%BF%E3%80%82">http://localhost:8080/swagger-ui/index.html，这个页面（要是觉得丑，UI是可以换的，支持第三方）会显示所有的API文档，包括接口的路径、支持的方法、接口的描述等，并且我们可以直接对API接口进行测试，非常方便。</a></p><p>我们可以创建一个配置类去配置页面的相关信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30).apiInfo(<br>                <span class="hljs-keyword">new</span> ApiInfoBuilder()<br>                        .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;你的名字&quot;</span>, <span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>, <span class="hljs-string">&quot;javastudy111*@163.com&quot;</span>))<br>                        .title(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30).apiInfo(<br>                <span class="hljs-keyword">new</span> ApiInfoBuilder()<br>                        .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;你的名字&quot;</span>, <span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>, <span class="hljs-string">&quot;javastudy111*@163.com&quot;</span>))<br>                        .title(<span class="hljs-string">"图书管理系统 - 在线API接口文档"</span>)<br>                        .build()<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口信息配置"><a href="#接口信息配置" class="headerlink" title="接口信息配置"></a>接口信息配置</h3><p>虽然Swagger的UI界面已经可以很好地展示后端提供的接口信息了，但是非常的混乱，我们来看看如何配置接口的一些描述信息。</p><p>首先我们的页面中完全不需要显示ErrorController相关的API，所以我们配置一下选择哪些Controller才会生成API信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>&#123;<br>    ApiInfo info = <span class="hljs-keyword">new</span> ApiInfoBuilder()<br>            .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;你的名字&quot;</span>, <span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>, <span class="hljs-string">&quot;javastudy111@163.com&quot;</span>))<br>            .title(<span class="hljs-string">&quot;图书管理系统 - 在线API接口文档&quot;</span>)<br>            .description(<span class="hljs-string">&quot;这是一个图书管理系统的后端API文档，欢迎前端人员查阅！&quot;</span>)<br>            .build();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30)<br>            .apiInfo(info)<br>            .select()       <span class="hljs-comment">//对项目中的所有API接口进行选择</span><br>            .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>&#123;<br>    ApiInfo info = <span class="hljs-keyword">new</span> ApiInfoBuilder()<br>            .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;你的名字&quot;</span>, <span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>, <span class="hljs-string">&quot;javastudy111@163.com&quot;</span>))<br>            .title(<span class="hljs-string">&quot;图书管理系统 - 在线API接口文档&quot;</span>)<br>            .description(<span class="hljs-string">&quot;这是一个图书管理系统的后端API文档，欢迎前端人员查阅！&quot;</span>)<br>            .build();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30)<br>            .apiInfo(info)<br>            .select()       <span class="hljs-comment">//对项目中的所有API接口进行选择</span><br>            .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.example.controller"</span>))<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看看如何为一个Controller编写API描述信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Api(tags = &quot;账户验证接口&quot;, description = &quot;包括用户登录、注册、验证码请求等操作。&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/auth&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-meta">@Api(tags = &quot;账户验证接口&quot;, description = &quot;包括用户登录、注册、验证码请求等操作。&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/auth&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthApiController</span> </span>&#123;<br></code></pre></td></tr></table></figure><p>我们可以直接在类名称上面添加<code>@Api</code>注解，并填写相关信息，来为当前的Controller设置描述信息。</p><p>接着我们可以为所有的请求映射配置描述信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@ApiResponses(&#123;</span><br><span class="hljs-meta">        @ApiResponse(code = 200, message = &quot;邮件发送成功&quot;),  </span><br><span class="hljs-meta">        @ApiResponse(code = 500, message = &quot;邮件发送失败&quot;)   //不同返回状态码描述</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@ApiOperation(&quot;请求邮件验证码&quot;)</span>   <span class="hljs-comment">//接口描述</span><br><span class="hljs-meta">@GetMapping(&quot;/verify-code&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestBean&lt;Void&gt; <span class="hljs-title">verifyCode</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;邮箱地址&quot;)</span>   //请求参数的描述</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@ApiResponses(&#123;</span><br><span class="hljs-meta">        @ApiResponse(code = 200, message = &quot;邮件发送成功&quot;),  </span><br><span class="hljs-meta">        @ApiResponse(code = 500, message = &quot;邮件发送失败&quot;)   //不同返回状态码描述</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@ApiOperation(&quot;请求邮件验证码&quot;)</span>   <span class="hljs-comment">//接口描述</span><br><span class="hljs-meta">@GetMapping(&quot;/verify-code&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestBean&lt;Void&gt; <span class="hljs-title">verifyCode</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;邮箱地址&quot;)</span>   //请求参数的描述</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-meta">@RequestParam("email")</span> String email)</span></span>&#123;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@ApiIgnore</span>     <span class="hljs-comment">//忽略此请求映射</span><br><span class="hljs-meta">@PostMapping(&quot;/login-success&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestBean&lt;Void&gt; <span class="hljs-title">loginSuccess</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestBean&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@ApiIgnore</span>     <span class="hljs-comment">//忽略此请求映射</span><br><span class="hljs-meta">@PostMapping(&quot;/login-success&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestBean&lt;Void&gt; <span class="hljs-title">loginSuccess</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestBean&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string">"登陆成功"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以为实体类配置相关的描述信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ApiModel(description = &quot;响应实体封装类&quot;)</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestBean</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;状态码&quot;)</span><br>    <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;状态码描述&quot;)</span><br>    String reason;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;数据实体&quot;)</span><br>    T data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RestBean</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String reason)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ApiModel(description = &quot;响应实体封装类&quot;)</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestBean</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;状态码&quot;)</span><br>    <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;状态码描述&quot;)</span><br>    String reason;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;数据实体&quot;)</span><br>    T data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RestBean</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String reason)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.reason = reason;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就可以在文档中查看实体类简介以及各个属性的介绍了。</p><p>最后我们再配置一下多环境：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>></span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>application*.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application-$&#123;environment&#125;.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>application*.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application-$&#123;environment&#125;.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>></span><br></code></pre></td></tr></table></figure><p>首先在Maven中添加两个环境，接着我们配置一下不同环境的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs yaml">  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">hibernate:</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><br><span class="hljs-attr">springfox:</span><br>  <span class="hljs-attr">documentation:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal"><code class="language-hljs yaml">  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">hibernate:</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><br><span class="hljs-attr">springfox:</span><br>  <span class="hljs-attr">documentation:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在生产环境下，我们选择不开启Swagger文档以及JPA的数据库操作日志，这样我们就可以根据情况选择两套环境了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/13/2.html/"/>
      <url>/2022/04/13/2.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20171116%2F4f98ec55839b434cba335319b5ebf963.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645350734&t=099b0e4fb640617498cc40939e7e2070" alt="点击查看图片来源"></p><h1 id="Linux操作系统与项目部署"><a href="#Linux操作系统与项目部署" class="headerlink" title="Linux操作系统与项目部署"></a>Linux操作系统与项目部署</h1><p><strong>注意：</strong>本版块会涉及到<code>操作系统</code>相关知识。</p><p>现在，几乎所有智能设备都有一个自己的操作系统，比如我们的家用个人电脑，基本都是预装Windows操作系统，我们的手机也有Android和iOS操作系统，还有程序员比较青睐的MacBook，预装MacOS操作系统，甚至连Macbook的Touchbar都有一个自己的小型操作系统。</p><blockquote><p>操作系统是管理计算机硬件与软件资源的计算机程序，操作系统可以对计算机系统的各项资源板块开展调度工作，运用计算机操作系统可以减少人工资源分配的工作强度。</p></blockquote><p>在我们的电脑没有操作系统的情况下，它就是一堆电子元器件组合而成的机器，就像我们有了一具完整的身体，但是现在缺少的是一个大脑，来控制我们的身体做出各种动作和行为，而安装了操作系统，就像为电脑注入了灵魂，操作系统会帮助我们对所有的硬件进行调度和管理。</p><p>比如我们现在最常用的Windows操作系统，我们可以在系统中做各种各样的事情，包括游戏、看片、学习、编程等，而所有的程序正是基于操作系统之上运行的，操作系统帮助我们与底层硬件进行交互，而在程序中我们只需要告诉操作系统我们需要做什么就可以了，操作系统知道该如何使用和调度底层的硬件，来完成我们程序中指定的任务。</p><p>（如果你在自己电脑上安装过Windows操作系统，甚至自己打过驱动程序，或是使用安装过Linux任意发行版本，那么本章学习起来会比较轻松）</p><h2 id="发展简史"><a href="#发展简史" class="headerlink" title="发展简史"></a>发展简史</h2><p>这是整个SpringBoot阶段的最后部分了，为了不让学习那么枯燥，我们先来讲点小故事。</p><p>在1965年，当时还处于批处理操作系统的时代，但是它只能同时供一个用户使用，而当时人们正希望能够开发一种交互式的、具有多道程序处理能力的分时操作系统。于是，贝尔实验室、美国麻省理工学院和通用电气公司联合发起了一项名为 Multics 的工程计划，而目的也是希望能够开发出这样的一个操作系统，但是最终由于各种原因以失败告终。</p><p>以肯•汤普森为首的贝尔实验室研究人员吸取了 Multics 工程计划失败的经验教训，于 1969 年实现了分时操作系统的雏形，在1970 年该操作系统正式取名为<strong>UNIX</strong>，它是一个强大的多用户、多任务操作系统，支持多种处理器架构，1973 年，也就是C语言问世不久后，UNIX操作系统的绝大部分源代码都用C语言进行了重写。</p><p>从这之后，大量的UNIX发行版本涌现（基于Unix进行完善的系统）比如 FreeBSD 就是美国加利福尼亚大学伯克利分校开发的 UNIX 版本，它由来自世界各地的志愿者开发和维护，为不同架构的计算机系统提供了不同程度的支持。</p><p> 而后来1984年苹果公司发布的的MacOS（在Macintosh电脑上搭载）操作系统，正是在 FreeBSD 基础之上开发的全新操作系统，这是首次计算机正式跨进图形化时代，具有里程碑的意义。</p><p><img src="https://www.webdesignerdepot.com/cdn-origin/uploads/2009/03/mac-os-1.gif" alt="Mac OS"></p><p>同年，乔布斯非常高兴地将自家的图形化MacOS界面展示给微软创始人比尔盖茨，并且希望微软可以为MacOS开发一些软件。比尔盖茨一看，woc，这玩意牛逼啊，咱们自己也给安排一个。于是，在1985年，微软仿造MacOS并基于MS-DOS操作系统，开发出了名为Windows的操作系统：</p><p><img src="https://pics5.baidu.com/feed/b7003af33a87e950dd561c8ef220e945faf2b4ab.jpeg?token=b2063459ad19e976ed42754e5f9caea8" alt="img"></p><p>Windows操作系统的问世，无疑是对MacOS的一次打击，因为MacOS只能搭载在Mac上，但是售价实在太贵，并且软件生态也不尽人意，同时代的Windows却能够安装到各种各样的DIY电脑上，称其为PC，尤其是后来的Windows95，几乎是封神的存在，各种各样基于Windows的软件、游戏层出不穷，以至于到今天为止，MacOS的市场占有率依然远低于Windows，不过Apple这十几年一直在注重自家软件生态的发展，总体来说在办公领域体验感其实和Windows差不多，甚至可能还更好，但是打游戏，别想了。</p><p>说了这么多，Linux呢，怎么一句都没提它呢？最牛逼的当然放最后说（不是</p><p>Unix虽然强大但是有着昂贵的授权费用，并且不开放源代码，于是有人发起了GNU运动（GNU IS NOT UNIX，带有那么一丝嘲讽），模仿 Unix 的界面和使用方式，从头做一个开源的版本。在1987年荷兰有个大学教授安德鲁写了一个Minix，类似于Unix，专用于教学。当Minix流传开来之后，世界各地的黑客们纷纷开始使用并改进，希望把改进的东西合并到Minix中，但是安德鲁觉得他的系统是用于教学的，不能破坏纯净性，于是拒绝了。</p><p>在1991年，林纳斯.托瓦兹（Linus Torvalds）认为Minix不够开放，自己又写了一个全新的开源操作系统，它希望这个系统由全世界的爱好者一同参与开发，并且不收费，于是Linux内核就被公开发布到互联网上。一经发布，便引起了社会强烈的反响，在大家的努力下，于1994年Linux的1.0版本正式发布。结合当时的GNU运动，最终合在一起称为了GNU/Linux，以一只企鹅Tux作为吉祥物。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%3A%2F%2Fdingyue.ws.126.net%2F2021%2F0914%2F1833179ap00qzeyx5000cc000go009qg.png%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&refer=http%3A%2F%2Fnimg.ws.126.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645451358&t=082f4539e97a1a3c9dc8002847e9ad5a" alt="点击查看图片来源"></p><p>没错，Git也是林纳斯.托瓦兹只花了2周时间开发的。不过林纳斯非常讨厌C++，他认为C++只会让一个项目变得混乱。</p><p>从此以后，各式各样的基于Linux发行版就开始出现：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fqnam.smzdm.com%2F202002%2F08%2F5e3e59003360f5288.jpg_e680.jpg&refer=http%3A%2F%2Fqnam.smzdm.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645451543&t=f2471b52851d92920194d2ef2acbab6f" alt="点击查看图片来源"></p><p>这些发行版都是在Linux内核的基础之上，添加了大量的额外功能，包括开发环境、图形化桌面、包管理等。包括我们的安卓系统，也是基于Linux之上的，而我们要重点介绍的就是基于Debian之上的Ubuntu操作系统。</p><p>最后，2022年了，我们再来看一下各大操作系统的市场占有率：</p><ul><li>Windows11/10/7：80%</li><li>MacOS：11%</li><li>Linux：5%</li><li>其他：4%</li></ul><p>Windows无疑是现在最广泛的操作系统，尤其是Windows XP，是多少00后的青春，很多游戏都是基于Windows平台。当然，如果你已经厌倦了游戏，一心只读圣贤书的话，那么还是建议直接使用任意Linux桌面版或是Mac，因为它们能够为你提供极致和纯粹的开发体验（貌似之前华为也出过Linux笔记本？）</p><hr><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.iasptk.com%2Fwp-content%2Fuploads%2Fsites%2F12%2F2017%2F03%2FUbuntu-02804350.jpg&refer=http%3A%2F%2Fwww.iasptk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645453389&t=d7908bc10978585c9ce374cc8013ff64" alt="点击查看图片来源"></p><h2 id="安装Ubuntu系统"><a href="#安装Ubuntu系统" class="headerlink" title="安装Ubuntu系统"></a>安装Ubuntu系统</h2><p>这里我们就以安装虚拟机的方式在我们的电脑上安装Linux操作系统，我们选用Ubuntu作为教程，如果有经济实力，可以在腾讯云、阿里云之类的服务商购买一台云服务器，并选择预装Ubuntu系统；如果你还想搞嵌入式开发之类的工作，可以购买一台树莓派服务器，也可以在上面安装Ubuntu系统，相当于一台迷你主机。在你已经有云服务器的情况下，可以直接跳过虚拟机安装教学。</p><p>官网下载：<a href="https://cn.ubuntu.com/download/server/step1">https://cn.ubuntu.com/download/server/step1</a></p><p>注意是下载服务器版本，不是桌面版本。</p><h3 id="在虚拟机中安装"><a href="#在虚拟机中安装" class="headerlink" title="在虚拟机中安装"></a>在虚拟机中安装</h3><p>这里我们使用VMware进行安装，VMware是一个虚拟化应用程序，它可以在我们当前运行的操作系统之上，创建一个虚线的主机，相当于创建了一台电脑，而我们就可以在这台电脑上安装各种各样的操作系统，并且我们可以自由为其分配CPU核心和内存以及硬盘容量（如果你接触过云计算相关内容，应该会对虚拟化技术有所了解）</p><p>官网下载：<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a></p><p>安装完成后，会出现一个类似于CMD的命令窗口，而我们就是通过输入命令来操作我们的操作系统。</p><h3 id="使用SSH远程连接"><a href="#使用SSH远程连接" class="headerlink" title="使用SSH远程连接"></a>使用SSH远程连接</h3><p>如果你使用的是树莓派或是云服务器，那么你会得到一个公网的IP地址，以及默认的用户名和密码，由于服务器安装的Ubuntu并不是在我们的电脑上运行的，那么我们怎么去远程操作呢？</p><p>比如我们要远程操作一台Windows电脑，直接使用远程桌面连接即可，但是Ubuntu上来就是命令行，这种情况下要实现远程连接就只能使用SSH终端。</p><p>SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p><p>云服务器上安装的Ubuntu默认都是自带了OpenSSH服务端的，我们可以直接连接，如果你的Ubuntu服务器上没有安装OpenSSH服务器端，那么可以输入命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs shell">sudo apt install openssh-server<br><span class="hljs-meta">#</span><span class="bash"><code class="language-hljs shell">sudo apt install openssh-server<br><span class="hljs-meta">#</span><span class="bash">输入后还需要你输入当前用户的密码才可以执行，至于为什么我们后面会说</span><br></code></pre></td></tr></table></figure><p>这里我们使用XShell来进行SSH登陆，官网：<a href="https://www.netsarang.com/zh/free-for-home-school/">https://www.netsarang.com/zh/free-for-home-school/</a></p><h3 id="文件系统介绍"><a href="#文件系统介绍" class="headerlink" title="文件系统介绍"></a>文件系统介绍</h3><p>在Windows下，我们的整个硬盘实际上可以被分为多个磁盘驱动器：</p><p><img src="https://img-blog.csdnimg.cn/20190415191752939.png" alt="在这里插入图片描述"></p><p>我们一般习惯将软件装到D盘，文件数据存在E盘，系统和一些环境安装在C盘，根据不同的盘符进行划分，并且每个盘都有各自的存储容量大小。而在Linux中，没有这个概念，所有的文件都是位于根目录下的：</p><p><img src="https://upload-images.jianshu.io/upload_images/17163728-8d41eb59e5cfb7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/904" alt="img"></p><p>我们可以看到根目录下有很多个文件夹，它们都有着各自的划分：</p><ul><li>/bin 可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等实际上都是一些小的应用程序</li><li>/home 普通用户的主目录，对应Windows下的C:/Users/用户名/</li><li>/root root用户的主目录（root用户是具有最高权限的用户，之后会讲）</li><li>/boot 内核文件的引导目录, 放置 linux 系统启动时用到的一些文件</li><li>/sbing 超级用户使用的指令文件</li><li>/tmp 临时文件目录，一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</li><li>/dev 设备文件目录，在Linux中万物皆文件，实际上你插入的U盘等设备都会在dev目录下生成一个文件，我们可以很方便地通过文件IO方式去操作外设，对嵌入式开发极为友好。</li><li>/lib 共享库，系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。</li><li>/usr 第三方 程序目录</li><li>/etc 配置程序目录，系统配置文件存放的目录</li><li>/var 可变文件，放置系统执行过程中经常变化的文件</li><li>/opt 用户使用目录，给主机额外安装软件所摆放的目录。</li></ul><p>我们可以直接输入命令来查看目录下的所有文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><span class="hljs-meta">#</span><span class="bash">只显示文件名称，且不显示隐藏文件</span><br>ls<br><span class="hljs-meta">#</span><span class="bash"><code class="language-hljs shell"><span class="hljs-meta">#</span><span class="bash">只显示文件名称，且不显示隐藏文件</span><br>ls<br><span class="hljs-meta">#</span><span class="bash">显示隐藏文件以及文件详细信息</span><br>ll<br></code></pre></td></tr></table></figure><p>那么我们如何才能像Windows那样方便的管理Linux中的文件呢？我们可以使用FTP管理工具，默认情况下Ubuntu是安装了SFTP服务器的。</p><p>这里我们使用Xftp来进行管理，官网：<a href="https://www.netsarang.com/zh/free-for-home-school/">https://www.netsarang.com/zh/free-for-home-school/</a></p><hr><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><p>我们整个Linux阶段的学习主要是以实操为主，大量的命令需要大量的使用才能记得更牢固。</p><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统的用户，都必须申请一个账号，然后以这个账号的身份进入系统。比如我们之前就是使用我们在创建服务器时申请的初始用户test，通过输入用户名和密码登录到系统中，之后才能使用各种命令进行操作。其实用户机制和我们的Windows比较类似。一般的普通用户只能做一些比较基本的操作，并且只能在自己的目录（如/home/test）中进行文件的创建和删除操作。</p><p>我们可以看到，当前状态信息分为三段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">test@ubuntu-server:~$<br></code></pre></td></tr></table></figure><p>格式为：用户名@服务器名称:当前所处的目录$，其中~代表用户目录，如果不是用户目录，会显示当前的绝对路径地址。我们也可以使用<code>pwd</code>命令来直接查看当前所处的目录。</p><p>在Linux中默认存在一个超级用户root，而此用户拥有最高执行权限，它能够修改任何的内容，甚至可以删除整个Linux内核，正常情况下不会使用root用户进行登陆，只有在特殊情况下才会使用root用户来进行一些操作，root用户非常危险，哪怕一个小小的命令都能够毁掉整个Linux系统，比如<code>rm -rf /*</code>，感兴趣的话我们可以放在最后来演示（在以前老是听说安卓手机root，实际上就是获取安卓系统底层Linux系统的root权限，以实现修改系统文件的目的）</p><p>我们可以使用<code>sudo -s</code>并输入当前用户的密码切换到root用户，可以看到出现了一些变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">test@ubuntu-server:~$<br><br>root@ubuntu-server:/home/test#<br></code></pre></td></tr></table></figure><p>我们发现<code>$</code>符号变成了<code>#</code>符号，注意此符号表示当前的用户权限等级，并且test也变为了root，在此用户下，我们可以随意修改test用户文件夹以外的内容，而test用户下则无法修改。如果需要退出root用户，直接输入<code>exit</code>即可。</p><p>接着我们来看一下，如何进行用户的管理操作，进行用户管理，包括添加用户和删除用户都需要root权限才可以执行，但是现在我们是test用户，我们可以在命令前面添加<code>sudo</code>来暂时以管理员身份执行此命令，比如说我们现在想要添加一个新的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">sudo useradd study<br></code></pre></td></tr></table></figure><p>其中<code>study</code>就是我们想要创建的新用户，<code>useradd</code>命令就是创建新用户的命令，同样的，删除用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">sudo userdel study<br></code></pre></td></tr></table></figure><p>Linux中的命令一般都可以携带一些参数来以更多特地的方式执行，我们可以在创建用户时，添加一些额外的参数来进行更多高级操作：</p><ul><li>-d&lt;登录目录&gt; 　指定用户登录时的起始目录。</li><li>-g&lt;群组&gt; 　指定用户所属的群组。</li><li>-G&lt;群组&gt; 　指定用户所属的附加群组。</li><li>-m 　自动建立用户的登入目录。</li><li>-M 　不要自动建立用户的登入目录。</li><li>-s  指定Shell，一般指定为/bin/bash</li></ul><p>如果还想查看更多命令，可以直接使用<code>man</code>来查看命令的详细参数列表，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">man useradd<br></code></pre></td></tr></table></figure><p>比如我们现在需要在用户创建时顺便创建用户的文件夹，并指定shell（任意一种命令解释程序，用于处理我们输入的命令）为bash：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">sudo useradd study -m -s /bin/bash<br></code></pre></td></tr></table></figure><p>可以看到已经自动在home目录下创建了study文件夹（这里..表示上一级目录，.表示当前目录）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">test@ubuntu-server:~$ ls ..<br>study  test<br></code></pre></td></tr></table></figure><p>用户创建完成之后，我们可以为此用户设定密码（如果不指定用户，那么会设置当前用户的密码）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">sudo passwd study<br></code></pre></td></tr></table></figure><p>输入密码之后，我们可以使用命令来切换用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">test@ubuntu-server:~$ su - study<br>Password: <br>study@ubuntu-server:~$ <br></code></pre></td></tr></table></figure><p>可以看到，切换用户后名称已经修改为study了，我们使用<code>exit</code>即可退出当前用户回到test。</p><p>输入<code>who</code>可以查看当前登录账号（注意是登录的账号）输入<code>whoami</code>可以查看当前的操作账号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">test@ubuntu-server:~$ su study<br>Password: <br>study@ubuntu-server:/home/test$ cd ~<br>study@ubuntu-server:~$ who<br>test     pts/0        2022-01-24 03:57 (192.168.10.3)<br>study@ubuntu-server:~$ whoami<br>study<br>study@ubuntu-server:~$ <br></code></pre></td></tr></table></figure><p>接着我们来看用户组，每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。我们可以输入<code>groups</code>来查看当前用户所有的用户组：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ groups<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ groups<br><span class="hljs-built_in">test</span> adm cdrom sudo dip plugdev lxd<br></code></pre></td></tr></table></figure><p>我们可以输入<code>id</code>来查看用户所属的用户相关信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ id<br>uid=1000(<span class="hljs-built_in">test</span>) gid=1000(<span class="hljs-built_in">test</span>) groups=1000(<span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ id<br>uid=1000(<span class="hljs-built_in">test</span>) gid=1000(<span class="hljs-built_in">test</span>) groups=1000(<span class="hljs-built_in">test</span>),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)<br></code></pre></td></tr></table></figure><p>我们可以看到test用户默认情况下主要用户组为同名的test用户组，并且还属于一些其他的用户组，其中sudo用户组就表示可以执行<code>sudo</code>命令，我们发现我们创建的study用户没有sudo的执行权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sh">study@ubuntu-server:~$ sudo -s<br>[sudo] password <span class="hljs-keyword">for</span> study: <br>study is not <span class="hljs-keyword"><code class="language-hljs sh">study@ubuntu-server:~$ sudo -s<br>[sudo] password <span class="hljs-keyword">for</span> study: <br>study is not <span class="hljs-keyword">in</span> the sudoers file.  This incident will be reported.<br></code></pre></td></tr></table></figure><p>正是因为没有加入到sudo用户组，这里我们来尝试将其添加到sudo用户组：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ id study<br>uid=1001(study) gid=1001(study) groups=1001(study)<br></code></pre></td></tr></table></figure><p>使用<code>usermod</code>命令来对用户的相关设置进行修改，参数与useradd大致相同：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo usermod study -G sudo<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo usermod study -G sudo<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ id study<br>uid=1001(study) gid=1001(study) groups=1001(study),27(sudo)<br></code></pre></td></tr></table></figure><p>接着切换到study用户就可以使用sudo命令了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs sh">To run a <span class="hljs-built_in">command</span> as administrator (user <span class="hljs-string">&quot;root&quot;</span>), use <span class="hljs-string">&quot;sudo &lt;command&gt;&quot;</span>.<br>See <span class="hljs-string">&quot;man sudo_root&quot;</span> <span class="hljs-keyword">for</span> details.<br><br>study@ubuntu-server:/home/<span class="hljs-built_in">test</span>$ sudo -s<br>[sudo] password <span class="hljs-keyword">for</span> study: <br>root@ubuntu-server:/home/<span class="hljs-built_in">test</span><span class="hljs-comment"><code class="language-hljs sh">To run a <span class="hljs-built_in">command</span> as administrator (user <span class="hljs-string">&quot;root&quot;</span>), use <span class="hljs-string">&quot;sudo &lt;command&gt;&quot;</span>.<br>See <span class="hljs-string">&quot;man sudo_root&quot;</span> <span class="hljs-keyword">for</span> details.<br><br>study@ubuntu-server:/home/<span class="hljs-built_in">test</span>$ sudo -s<br>[sudo] password <span class="hljs-keyword">for</span> study: <br>root@ubuntu-server:/home/<span class="hljs-built_in">test</span><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p>实际上，我们的用户信息是存储在配置文件中的，我们之前说了，配置文件一般都放在etc目录下，而用户和用户组相关的配置文件，存放在<code>/etc/passwd</code>和<code>/etc/group</code>中，我们可以使用cat命令将文件内容打印到控制台：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><span class="hljs-built_in"><code class="language-hljs bash"><span class="hljs-built_in">test</span>@ubuntu-server:~$ cat /etc/passwd<br>root:x:0:0:root:/root:/bin/bash<br>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin<br>bin:x:2:2:bin:/bin:/usr/sbin/nologin<br>sys:x:3:3:sys:/dev:/usr/sbin/nologin<br>sync:x:4:65534:sync:/bin:/bin/sync<br></code></pre></td></tr></table></figure><p>格式为：<code>注册名:口令:用户标识号:组标识号:用户名:用户主目录:命令解释程序 </code>，而我们的密码则存放在<code>/etc/shadow</code>中，是以加密形式存储的，并且需要root权限才能查看。</p><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>接着我们来看一下Linux系统中一些比较常用的命令。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件是最基本的内容，我们可以使用ls命令列出当前目录中所有的文件，参数-a表示包含所有的隐藏文件，-l表示列出详细信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls -al<br>total 44<br>drwxr-xr-x 4 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 24 08:55 .<br>drwxr-xr-x 4 root root 4096 Jan 24 04:24 ..<br>-rw------- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 2124 Jan 24 04:29 .bash_history<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>  220 Feb 25  2020 .bash_logout<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 3771 Feb 25  2020 .bashrc<br>drwx------ 2 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 21 15:48 .cache<br>drwx------ 3 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 23 14:49 .config<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>  807 Feb 25  2020 .profile<br>-rw------- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>   34 Jan 24 04:17 .python_history<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>    0 Jan 21 15:52 .sudo_as_admin_successful<br>-rw------- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls -al<br>total 44<br>drwxr-xr-x 4 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 24 08:55 .<br>drwxr-xr-x 4 root root 4096 Jan 24 04:24 ..<br>-rw------- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 2124 Jan 24 04:29 .bash_history<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>  220 Feb 25  2020 .bash_logout<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 3771 Feb 25  2020 .bashrc<br>drwx------ 2 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 21 15:48 .cache<br>drwx------ 3 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 23 14:49 .config<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>  807 Feb 25  2020 .profile<br>-rw------- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>   34 Jan 24 04:17 .python_history<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>    0 Jan 21 15:52 .sudo_as_admin_successful<br>-rw------- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 7201 Jan 24 08:55 .viminfo<br></code></pre></td></tr></table></figure><p>可以看到当前目录下的整个文件列表，那么这些信息各种代表什么意思呢，尤其是最前面那一栏类似于<code>drwxr-xr-x</code>的字符串。</p><p>它表示文件的属性，其中第1个字符表示此文件的类型：<code>-</code>表示普通文件，<code>l</code>为链接文件，<code>d</code>表示目录（文件夹），<code>c</code>表示字符设备、<code>b</code>表示块设备，还有<code>p</code>有名管道、<code>f</code>堆栈文件、<code>s</code>套接字等，这些一般都是用于进程之间通信使用的。</p><p>第2-4个字符表示文件的拥有者（User）对该文件的权限，第5-7个字符表示文件所属用户组（Group）内用户对该文件的权限，最后8-10个字符表示其他用户（Other）对该文件的权限。其中<code>r</code>为读权限、<code>w</code>为写权限、<code>x</code>为执行权限，为了方便记忆，直接记UGO就行了。</p><p>比如<code>drwxr-xr-x</code>就表示这是一个目录，文件的拥有者可以在目录中读、写和执行，而同一用户组的其他用户只能读和执行，其他用户也是一样。</p><p>第二栏数据可以看到是一列数字，它表示文件创建的链接文件（快捷方式）数量，一般只有1表示只有当前文件，我们也可以尝试创建一个链接文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ ln .bash_logout kk<br></code></pre></td></tr></table></figure><p>创建后，会生成一个名为kk的文件，我们对此文件的操作相当于直接操作.bash_logout，跟Windows中的快捷方式比较类似，了解一下即可。再次执行<code>ll</code>命令，可以看到.bash_logout的链接数变成了2。</p><p>第三栏数据为该文件或是目录的拥有者。</p><p>第四栏数据表示所属的组。</p><p>第五栏数据表示文件大小，以字节为单位。</p><p>第六栏数据为文件的最后一次修改时间</p><p>最后一栏就是文件名称了，就不多说了，再次提及..表示上级目录，.表示当前目录，最前面有一个.开头的文件为隐藏文件。可以看到上级目录（也就是/home目录）所有者为root，并且非root用户无法进行写操作，只能执行读操作，而当前目录以及目录下所有文件则属于test用户，test用户可以随意进行修改。</p><p>在了解了Linux的文件查看之后再去看Windows的文件管理，会觉得Windows的太拉了：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg0.pconline.com.cn%2Fpconline%2F2107%2F02%2F14306786_05_thumb.jpg&refer=http%3A%2F%2Fimg0.pconline.com.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645608268&t=75ea125c46cb38b22268156794b986d4" alt="img"></p><p>那么，如果我们希望对文件的属性进行修改，比如我们现在希望将某个文件的写权限给关闭，可以使用<code>chmod</code>命令来进行文件属性修改，我们先创建一个test文件，使用<code>touch</code>命令来创建文件，使用<code>mkdir</code>命令来创建目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">test@ubuntu-server:~$ touch test<br>test@ubuntu-server:~$ ll test<br>-rw-rw-r-- 1 test test 0 Jan 24 09:32 test<br></code></pre></td></tr></table></figure><p>可以看到文件创建之后的默认权限为可读可写，接着我们来将其修改为只读，chmod的使用方法如下：</p><ul><li>chmod (u/g/o/a)(+/-)(r/w/x) 文件名称</li></ul><p>我们可以从ugo中选择或是直接a表示所有，+和-表示添加和删除权限，最后rwx不用我说了吧</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ chmod a-w <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ll <span class="hljs-built_in">test</span><br>-r--r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 0 Jan 24 09:32 <span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ chmod a-w <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ll <span class="hljs-built_in">test</span><br>-r--r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 0 Jan 24 09:32 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>除了这种方式之外，我们也可以使用数字来代替，比如现在我要给前两个添加读权限，那么：</p><p>约定：r=4，w=2，x=1，需要什么权限就让对应权限的数字相加，一个数字表示一个rwx的权限状态，比如我们想修改为<code>-rw-rw-r--</code>，那么对应的数字就是<code>664</code>，对应的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ chmod 664 <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ll <span class="hljs-built_in">test</span><br>-rw-rw-r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 0 Jan 24 09:32 <span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ chmod 664 <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ll <span class="hljs-built_in">test</span><br>-rw-rw-r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 0 Jan 24 09:32 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>如果我们想修改文件的拥有者或是所属组，可以使用<code>chown</code>和<code>chgrp</code>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo chown root <span class="hljs-built_in">test</span> <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls -l<br>total 0<br>-rw-rw-r-- 1 root <span class="hljs-built_in">test</span> 0 Jan 24 10:43 <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo chgrp root <span class="hljs-built_in">test</span> <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls -l<br>total 0<br>-rw-rw-r-- 1 root root 0 Jan 24 10:43 <span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo chown root <span class="hljs-built_in">test</span> <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls -l<br>total 0<br>-rw-rw-r-- 1 root <span class="hljs-built_in">test</span> 0 Jan 24 10:43 <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo chgrp root <span class="hljs-built_in">test</span> <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls -l<br>total 0<br>-rw-rw-r-- 1 root root 0 Jan 24 10:43 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>再次操作该文件，会发现没权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ chmod 777 <span class="hljs-built_in">test</span> <br>chmod: changing permissions of <span class="hljs-string"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ chmod 777 <span class="hljs-built_in">test</span> <br>chmod: changing permissions of <span class="hljs-string">&#x27;test&#x27;</span>: Operation not permitted<br></code></pre></td></tr></table></figure><p>接着我们来看文件的复制、移动和删除，这里我们先创建一个新的目录并进入到此目录用于操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ mkdir study<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> study<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ mkdir study<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> study<br><span class="hljs-built_in">test</span>@ubuntu-server:~/study$<br></code></pre></td></tr></table></figure><p>首先我们演示文件的复制操作，文件的复制使用<code>cp</code>命令，比如现在我们想把上一级目录中的test文件复制到当前目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~/study$ cp ../<span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~/study$ ls<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~/study$ cp ../<span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~/study$ ls<br><span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>那么如果我们想要将一整个目录进行复制呢？我们需要添加一个<code>-r</code>参数表示将目录中的文件递归复制：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~/study$ <span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ cp -r study study_copied<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls -l<br>total 8<br>drwxrwxr-x 2 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 24 10:16 study<br>drwxrwxr-x 2 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 24 10:20 study_copied<br>-rw-rw-r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>    0 Jan 24 09:32 <span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~/study$ <span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ cp -r study study_copied<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls -l<br>total 8<br>drwxrwxr-x 2 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 24 10:16 study<br>drwxrwxr-x 2 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 24 10:20 study_copied<br>-rw-rw-r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>    0 Jan 24 09:32 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>可以看到我们的整个目录中所有的文件也一起被复制了。</p><p>接着我们来看看移动操作，相当于是直接将一个文件转移到另一个目录中了，我们再创建一个目录用于文件的移动，并将test文件移动到此目录中，我们使用<code>mv</code>命令进行文件的移动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ mkdir study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ mv <span class="hljs-built_in">test</span> study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>study  study2  study_copied<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ ls<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ mkdir study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ mv <span class="hljs-built_in">test</span> study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>study  study2  study_copied<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ ls<br><span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>现在我们想要移动个目录到另一个目录中，比如我们想将study目录移动到study2目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ mv study study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>study2  study_copied<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ ls<br>study  <span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ mv study study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>study2  study_copied<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ ls<br>study  <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><code>mv</code>命令不仅能实现文件的移动，还可以实现对文件重命名操作，比如我们想将文件test重命名为yyds，那么直接将其进行移动操作即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ ls<br>study  <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ mv <span class="hljs-built_in">test</span> yyds<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ ls<br>study  <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ mv <span class="hljs-built_in">test</span> yyds<br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ ls<br>study  yyds<br></code></pre></td></tr></table></figure><p>最后就是删除命令了，使用<code>rm</code>进行删除操作，比如现在我们想删除study2目录（注意需要添加-r参数表示递归删除文件夹中的内容）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ rm -r study2<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ rm -r study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>study_copied<br></code></pre></td></tr></table></figure><p>而最常提到的<code>rm -rf /*</code>正是删除根目录下所有的文件（非常危险的操作），-f表示忽略不存在的文件，不进行任何提示，*是一个通配符，表示任意文件。这里我们演示一下删除所有.txt结尾的文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ touch 1.txt 2.txt 3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>1.txt  2.txt  3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ rm *.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ touch 1.txt 2.txt 3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>1.txt  2.txt  3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ rm *.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <br></code></pre></td></tr></table></figure><p>最后我们再来看文件的搜索，我们使用find命令来进行搜索，比如我想搜索/etc目录下名为passwd的文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs gradle">test@ubuntu-server:~$ sudo <span class="hljs-keyword">find</span> /etc -name passwd<br>[sudo] password <span class="hljs-keyword">for</span> test: <br><span class="hljs-regexp">/etc/</span>pam.d/passwd<br><span class="hljs-regexp"><code class="language-hljs gradle">test@ubuntu-server:~$ sudo <span class="hljs-keyword">find</span> /etc -name passwd<br>[sudo] password <span class="hljs-keyword">for</span> test: <br><span class="hljs-regexp">/etc/</span>pam.d/passwd<br><span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><p>它还支持通配符，比如搜索以s开头的文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs gradle">test@ubuntu-server:~$ sudo <span class="hljs-keyword">find</span> /etc -name s*<br><span class="hljs-regexp">/etc/</span>subuid<br><span class="hljs-regexp">/etc/</span>screenrc<br><span class="hljs-regexp">/etc/</span>sensors3.conf<br><span class="hljs-regexp">/etc/</span>sysctl.conf<br><span class="hljs-regexp">/etc/</span>sudoers<br><span class="hljs-regexp">/etc/</span>shadow<br><span class="hljs-regexp">/etc/</span>skel<br><span class="hljs-regexp">/etc/</span>pam.d/su<br><span class="hljs-regexp">/etc/</span>pam.d/sshd<br><span class="hljs-regexp"><code class="language-hljs gradle">test@ubuntu-server:~$ sudo <span class="hljs-keyword">find</span> /etc -name s*<br><span class="hljs-regexp">/etc/</span>subuid<br><span class="hljs-regexp">/etc/</span>screenrc<br><span class="hljs-regexp">/etc/</span>sensors3.conf<br><span class="hljs-regexp">/etc/</span>sysctl.conf<br><span class="hljs-regexp">/etc/</span>sudoers<br><span class="hljs-regexp">/etc/</span>shadow<br><span class="hljs-regexp">/etc/</span>skel<br><span class="hljs-regexp">/etc/</span>pam.d/su<br><span class="hljs-regexp">/etc/</span>pam.d/sshd<br><span class="hljs-regexp">/etc/</span>pam.d/sudo<br>...<br></code></pre></td></tr></table></figure><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p>接着我们来查看一些系统管理相关的命令，比如我们Windows中的任务管理器，我们可以使用<code>top</code>命令来打开：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre class=" language-hljs tap">top - 10:48:46 up  5:52, <span class="hljs-number"> 1 </span>user,  load average: 0.00, 0.00, 0.00<br>Tasks:<span class="hljs-number"> 191 </span>total,  <span class="hljs-number"> 2 </span>running,<span class="hljs-number"> 189 </span>sleeping,  <span class="hljs-number"> 0 </span>stopped,  <span class="hljs-number"> 0 </span>zombie<br>%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>MiB Mem :   3919.1 total,   2704.2 free,    215.0 used,    999.9 buff/cache<br>MiB Swap:   3923.0 total,   3923.0 free,      0.0 used.   3521.4 avail Mem <br><br>    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                       <br> <span class="hljs-number"> 10528 </span>test     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>  <span class="hljs-number"> 8944 </span> <span class="hljs-number"> 3072 </span> <span class="hljs-number"> 2652 </span>R   0.7   0.1   0:00.07 top                           <br>  <span class="hljs-number"> 9847 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.3   0.0   0:00.87 kworker/0:0-events            <br>     <span class="hljs-number"> 1 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span><span class="hljs-number"> 102760 </span><span class="hljs-number"> 10456 </span> <span class="hljs-number"> 7120 </span>S   0.0   0.3   0:02.02 systemd                       <br>     <span class="hljs-number"> 2 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.01 kthreadd                      <br>     <span class="hljs-number"> 3 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 rcu_gp                        <br>     <span class="hljs-number"> 4 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 rcu_par_gp                    <br>     <span class="hljs-number"> 6 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 kworker/0:0H-kblockd          <br>     <span class="hljs-number"> 8 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 mm_percpu_wq                  <br>     <span class="hljs-number"> 9 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.15 ksoftirqd/0                   <br>    <span class="hljs-number"> 10 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>R   0.0   0.0   0:01.49 rcu_sched                     <br>    <span class="hljs-number"> 11 </span>root      rt  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.24 migration/0                   <br>    <span class="hljs-number"> 12 </span>root     -51  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 idle_inject/0                 <br>    <span class="hljs-number"> 14 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 cpuhp/0                       <br>    <span class="hljs-number"> 15 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 cpuhp/1                       <br>    <span class="hljs-number"> 16 </span>root     -51  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 idle_inject/1                 <br>    <span class="hljs-number"> 17 </span>root      rt  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.30 migration/1                   <br>    <span class="hljs-number"> 18 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.07 ksoftirqd/1                   <br>    <span class="hljs-number"> 20 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"><code class="language-hljs tap">top - 10:48:46 up  5:52, <span class="hljs-number"> 1 </span>user,  load average: 0.00, 0.00, 0.00<br>Tasks:<span class="hljs-number"> 191 </span>total,  <span class="hljs-number"> 2 </span>running,<span class="hljs-number"> 189 </span>sleeping,  <span class="hljs-number"> 0 </span>stopped,  <span class="hljs-number"> 0 </span>zombie<br>%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>MiB Mem :   3919.1 total,   2704.2 free,    215.0 used,    999.9 buff/cache<br>MiB Swap:   3923.0 total,   3923.0 free,      0.0 used.   3521.4 avail Mem <br><br>    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                       <br> <span class="hljs-number"> 10528 </span>test     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>  <span class="hljs-number"> 8944 </span> <span class="hljs-number"> 3072 </span> <span class="hljs-number"> 2652 </span>R   0.7   0.1   0:00.07 top                           <br>  <span class="hljs-number"> 9847 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.3   0.0   0:00.87 kworker/0:0-events            <br>     <span class="hljs-number"> 1 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span><span class="hljs-number"> 102760 </span><span class="hljs-number"> 10456 </span> <span class="hljs-number"> 7120 </span>S   0.0   0.3   0:02.02 systemd                       <br>     <span class="hljs-number"> 2 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.01 kthreadd                      <br>     <span class="hljs-number"> 3 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 rcu_gp                        <br>     <span class="hljs-number"> 4 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 rcu_par_gp                    <br>     <span class="hljs-number"> 6 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 kworker/0:0H-kblockd          <br>     <span class="hljs-number"> 8 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 mm_percpu_wq                  <br>     <span class="hljs-number"> 9 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.15 ksoftirqd/0                   <br>    <span class="hljs-number"> 10 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>R   0.0   0.0   0:01.49 rcu_sched                     <br>    <span class="hljs-number"> 11 </span>root      rt  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.24 migration/0                   <br>    <span class="hljs-number"> 12 </span>root     -51  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 idle_inject/0                 <br>    <span class="hljs-number"> 14 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 cpuhp/0                       <br>    <span class="hljs-number"> 15 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 cpuhp/1                       <br>    <span class="hljs-number"> 16 </span>root     -51  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 idle_inject/1                 <br>    <span class="hljs-number"> 17 </span>root      rt  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.30 migration/1                   <br>    <span class="hljs-number"> 18 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.07 ksoftirqd/1                   <br>    <span class="hljs-number"> 20 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 kworker/1:0H-kblockd  <br></code></pre></td></tr></table></figure><p>可以很清楚地看到当前CPU的使用情况以及内存的占用情况。</p><p>按下数字键1，可以展示所有CPU核心的使用情况：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs vim">%Cpu0  :  <span class="hljs-number">0.0</span> us,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">sy</span>,  <span class="hljs-number">0.0</span> ni,<span class="hljs-number">100.0</span> id,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">wa</span>,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">hi</span>,  <span class="hljs-number">0.0</span> si,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">st</span><br>%Cpu1  :  <span class="hljs-number">0.0</span> us,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">sy</span>,  <span class="hljs-number">0.0</span> ni,<span class="hljs-number">100.0</span> id,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">wa</span>,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">hi</span>,  <span class="hljs-number">0.0</span> si,  <span class="hljs-number">0.0</span> <span class="hljs-keyword"><code class="language-hljs vim">%Cpu0  :  <span class="hljs-number">0.0</span> us,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">sy</span>,  <span class="hljs-number">0.0</span> ni,<span class="hljs-number">100.0</span> id,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">wa</span>,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">hi</span>,  <span class="hljs-number">0.0</span> si,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">st</span><br>%Cpu1  :  <span class="hljs-number">0.0</span> us,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">sy</span>,  <span class="hljs-number">0.0</span> ni,<span class="hljs-number">100.0</span> id,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">wa</span>,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">hi</span>,  <span class="hljs-number">0.0</span> si,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">st</span><br></code></pre></td></tr></table></figure><p>按下f键可以设置以哪一列进行排序或是显示那些参数：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs vim">Fields Management <span class="hljs-keyword">for</span> window <span class="hljs-number">1</span>:Def, whose current <span class="hljs-keyword">sort</span> field <span class="hljs-keyword">is</span> %MEM<br>   Navigate with Up/Dn, Right selects <span class="hljs-keyword">for</span> <span class="hljs-keyword">move</span> then <span class="hljs-symbol">&lt;Enter&gt;</span> <span class="hljs-built_in">or</span> Left commits,<br>   <span class="hljs-string">&#x27;d&#x27;</span> <span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;Space&gt;</span> toggles <span class="hljs-keyword">display</span>, <span class="hljs-string">&#x27;s&#x27;</span> sets <span class="hljs-keyword">sort</span>.  Use <span class="hljs-string">&#x27;q&#x27;</span> <span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;Esc&gt;</span> <span class="hljs-keyword"><code class="language-hljs vim">Fields Management <span class="hljs-keyword">for</span> window <span class="hljs-number">1</span>:Def, whose current <span class="hljs-keyword">sort</span> field <span class="hljs-keyword">is</span> %MEM<br>   Navigate with Up/Dn, Right selects <span class="hljs-keyword">for</span> <span class="hljs-keyword">move</span> then <span class="hljs-symbol">&lt;Enter&gt;</span> <span class="hljs-built_in">or</span> Left commits,<br>   <span class="hljs-string">&#x27;d&#x27;</span> <span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;Space&gt;</span> toggles <span class="hljs-keyword">display</span>, <span class="hljs-string">&#x27;s&#x27;</span> sets <span class="hljs-keyword">sort</span>.  Use <span class="hljs-string">&#x27;q&#x27;</span> <span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;Esc&gt;</span> <span class="hljs-keyword">to</span> end!<br></code></pre></td></tr></table></figure><p>按下q键即可退出监控界面。</p><p>我们可以直接输入free命令来查看当前系统的内存使用情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs apache"><span class="hljs-attribute">test</span>@ubuntu-server:~$ free -m<br>              <span class="hljs-attribute">total</span>        used        free      shared  buff/cache   available<br><span class="hljs-attribute">Mem</span>:           <span class="hljs-number">3919</span>         <span class="hljs-number">212</span>        <span class="hljs-number">2706</span>           <span class="hljs-number">1</span>         <span class="hljs-number">999</span>        <span class="hljs-number">3523</span><br><span class="hljs-attribute">Swap</span>:          <span class="hljs-number">3922</span>           <span class="hljs-number">0</span>        <span class="hljs-number"><code class="language-hljs apache"><span class="hljs-attribute">test</span>@ubuntu-server:~$ free -m<br>              <span class="hljs-attribute">total</span>        used        free      shared  buff/cache   available<br><span class="hljs-attribute">Mem</span>:           <span class="hljs-number">3919</span>         <span class="hljs-number">212</span>        <span class="hljs-number">2706</span>           <span class="hljs-number">1</span>         <span class="hljs-number">999</span>        <span class="hljs-number">3523</span><br><span class="hljs-attribute">Swap</span>:          <span class="hljs-number">3922</span>           <span class="hljs-number">0</span>        <span class="hljs-number">3922</span><br></code></pre></td></tr></table></figure><p>其中-m表示以M为单位，也可以-g表示以G为单位，默认是kb为单位。</p><p>最后就是磁盘容量，我们可以使用<code>lsblk</code>来查看所有块设备的信息，其中就包括我们的硬盘、光驱等：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs tap">test@ubuntu-server:~$ lsblk<br>NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>loop0                       7:0   <span class="hljs-number"> 0 </span>48.9M <span class="hljs-number"> 1 </span>loop /snap/core18/2127<br>loop1                       7:1   <span class="hljs-number"> 0 </span>28.1M <span class="hljs-number"> 1 </span>loop /snap/snapd/12707<br>loop2                       7:2   <span class="hljs-number"> 0 </span>  62M <span class="hljs-number"> 1 </span>loop /snap/lxd/21032<br>sr0                        11:0   <span class="hljs-number"> 1 </span>1024M <span class="hljs-number"> 0 </span>rom  <br>nvme0n1                   259:0   <span class="hljs-number"> 0 </span>  20G <span class="hljs-number"> 0 </span>disk <br>├─nvme0n1p1               259:1   <span class="hljs-number"> 0 </span> 512M <span class="hljs-number"> 0 </span>part /boot/efi<br>├─nvme0n1p2               259:2   <span class="hljs-number"> 0 </span>   1G <span class="hljs-number"> 0 </span>part /boot<br>└─nvme0n1p3               259:3   <span class="hljs-number"> 0 </span>18.5G <span class="hljs-number"> 0 </span>part <br>  └─ubuntu--vg-ubuntu--lv 253:0   <span class="hljs-number"> 0 </span>18.5G <span class="hljs-number"><code class="language-hljs tap">test@ubuntu-server:~$ lsblk<br>NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>loop0                       7:0   <span class="hljs-number"> 0 </span>48.9M <span class="hljs-number"> 1 </span>loop /snap/core18/2127<br>loop1                       7:1   <span class="hljs-number"> 0 </span>28.1M <span class="hljs-number"> 1 </span>loop /snap/snapd/12707<br>loop2                       7:2   <span class="hljs-number"> 0 </span>  62M <span class="hljs-number"> 1 </span>loop /snap/lxd/21032<br>sr0                        11:0   <span class="hljs-number"> 1 </span>1024M <span class="hljs-number"> 0 </span>rom  <br>nvme0n1                   259:0   <span class="hljs-number"> 0 </span>  20G <span class="hljs-number"> 0 </span>disk <br>├─nvme0n1p1               259:1   <span class="hljs-number"> 0 </span> 512M <span class="hljs-number"> 0 </span>part /boot/efi<br>├─nvme0n1p2               259:2   <span class="hljs-number"> 0 </span>   1G <span class="hljs-number"> 0 </span>part /boot<br>└─nvme0n1p3               259:3   <span class="hljs-number"> 0 </span>18.5G <span class="hljs-number"> 0 </span>part <br>  └─ubuntu--vg-ubuntu--lv 253:0   <span class="hljs-number"> 0 </span>18.5G <span class="hljs-number"> 0 </span>lvm  /<br></code></pre></td></tr></table></figure><p>可以看到nvme开头的就是我们的硬盘（这个因人而异，可能你们的是sda，磁盘类型不同名称就不同）可以看到<code>nvme0n1  </code>容量为20G，并且512M用作存放EFI文件，1G存放启动文件，剩余容量就是存放系统文件和我们的用户目录。</p><p>这里要提到一个挂载的概念：</p><blockquote><p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</p></blockquote><p>比如我们的主硬盘，挂载点就被设定为<code>/</code>根目录，而我们所有保存的文件都会存储在硬盘中，如果你有U盘（最好将U盘的文件格式改为ExFat，可以直接在Windows中进行格式化，然后随便放入一些文件即可）之类的东西，我们可以演示一下对U盘进行挂载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo fdisk -l<br>...<br>Disk /dev/sda: 60 GiB, 64424509440 bytes, 125829120 sectors<br>Disk model: USB DISK        <br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel <span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo fdisk -l<br>...<br>Disk /dev/sda: 60 GiB, 64424509440 bytes, 125829120 sectors<br>Disk model: USB DISK        <br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel <span class="hljs-built_in">type</span>: dos<br>Disk identifier: 0x4a416279<br><br>Device     Boot     Start       End   Sectors  Size Id Type<br>/dev/sda1  *       614400 125214719 124600320 59.4G  7 HPFS/NTFS/exFAT<br>/dev/sda2       125214720 125825022    610303  298M  6 FAT16<br></code></pre></td></tr></table></figure><p>将U盘插入电脑，选择连接到Linux，输入<code>sudo fdisk -l</code>命令来查看硬盘实体情况，可以看到有一个USB DISK设备，注意观察一下是不是和自己的U盘容量一致，可以看到设备名称为<code>/dev/sda1</code>。</p><p>接着我们设备挂载到一个目录下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ mkdir u-test<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo mount /dev/sda1 u-test/<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> u-test/<br><span class="hljs-built_in">test</span>@ubuntu-server:~/u-test$ ls<br> CGI<br> cn_windows_10_enterprise_ltsc_2019_x64_dvd_9c09ff24.iso<br> cn_windows_7_professional_x64_dvd_x15-65791.iso<br> cn_windows_8.1_enterprise_with_update_x64_dvd_6050374.iso<br> cn_windows_8.1_professional_vl_with_update_x64_dvd_4050293.iso<br> cn_windows_server_2019_updated_july_2020_x64_dvd_2c9b67da.iso<br><span class="hljs-string"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ mkdir u-test<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo mount /dev/sda1 u-test/<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> u-test/<br><span class="hljs-built_in">test</span>@ubuntu-server:~/u-test$ ls<br> CGI<br> cn_windows_10_enterprise_ltsc_2019_x64_dvd_9c09ff24.iso<br> cn_windows_7_professional_x64_dvd_x15-65791.iso<br> cn_windows_8.1_enterprise_with_update_x64_dvd_6050374.iso<br> cn_windows_8.1_professional_vl_with_update_x64_dvd_4050293.iso<br> cn_windows_server_2019_updated_july_2020_x64_dvd_2c9b67da.iso<br><span class="hljs-string">&#x27;System Volume Information&#x27;</span><br> zh-cn_windows_10_consumer_editions_version_21h1_updated_sep_2021_x64_dvd_991b822f.iso<br> zh-cn_windows_11_consumer_editions_x64_dvd_904f13e4.iso<br></code></pre></td></tr></table></figure><p>最后进入到此目录中，就能看到你U盘中的文件了，如果你不想使用U盘了，可以直接取消挂载：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs jboss-cli">test@ubuntu-server:~<span class="hljs-string">/u-test</span>$ <span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br>test@ubuntu-server:~$ sudo umount <span class="hljs-string"><code class="language-hljs jboss-cli">test@ubuntu-server:~<span class="hljs-string">/u-test</span>$ <span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br>test@ubuntu-server:~$ sudo umount <span class="hljs-string">/dev/sda1</span><br></code></pre></td></tr></table></figure><p>最后我们可以通过<code>df</code>命令查看当前磁盘使用情况：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs tap">test@ubuntu-server:~$ df -m<br>Filesystem                        1M-blocks  Used Available Use% Mounted on<br>udev                                  <span class="hljs-number"> 1900 </span>   <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 1900 </span>  0% /dev<br>tmpfs                                  <span class="hljs-number"> 392 </span>   <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 391 </span>  1% /run<br>/dev/mapper/ubuntu--vg-ubuntu--lv    <span class="hljs-number"> 18515 </span><span class="hljs-number"> 6544 </span>   <span class="hljs-number"> 11009 </span> 38% /<br>tmpfs                                 <span class="hljs-number"> 1960 </span>   <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 1960 </span>  0% /dev/shm<br>tmpfs                                    <span class="hljs-number"> 5 </span>   <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 5 </span>  0% /run/lock<br>tmpfs                                 <span class="hljs-number"> 1960 </span>   <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 1960 </span>  0% /sys/fs/cgroup<br>/dev/nvme0n1p2                         <span class="hljs-number"> 976 </span> <span class="hljs-number"> 109 </span>     <span class="hljs-number"> 800 </span> 12% /boot<br>/dev/nvme0n1p1                         <span class="hljs-number"> 511 </span>   <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 508 </span>  1% /boot/efi<br>/dev/loop0                              <span class="hljs-number"> 49 </span>  <span class="hljs-number"> 49 </span>       <span class="hljs-number"> 0 </span>100% /snap/core18/2127<br>/dev/loop1                              <span class="hljs-number"> 29 </span>  <span class="hljs-number"> 29 </span>       <span class="hljs-number"> 0 </span>100% /snap/snapd/12707<br>/dev/loop2                              <span class="hljs-number"> 62 </span>  <span class="hljs-number"> 62 </span>       <span class="hljs-number"> 0 </span>100% /snap/lxd/21032<br>tmpfs                                  <span class="hljs-number"> 392 </span>   <span class="hljs-number"> 0 </span>     <span class="hljs-number"><code class="language-hljs tap">test@ubuntu-server:~$ df -m<br>Filesystem                        1M-blocks  Used Available Use% Mounted on<br>udev                                  <span class="hljs-number"> 1900 </span>   <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 1900 </span>  0% /dev<br>tmpfs                                  <span class="hljs-number"> 392 </span>   <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 391 </span>  1% /run<br>/dev/mapper/ubuntu--vg-ubuntu--lv    <span class="hljs-number"> 18515 </span><span class="hljs-number"> 6544 </span>   <span class="hljs-number"> 11009 </span> 38% /<br>tmpfs                                 <span class="hljs-number"> 1960 </span>   <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 1960 </span>  0% /dev/shm<br>tmpfs                                    <span class="hljs-number"> 5 </span>   <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 5 </span>  0% /run/lock<br>tmpfs                                 <span class="hljs-number"> 1960 </span>   <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 1960 </span>  0% /sys/fs/cgroup<br>/dev/nvme0n1p2                         <span class="hljs-number"> 976 </span> <span class="hljs-number"> 109 </span>     <span class="hljs-number"> 800 </span> 12% /boot<br>/dev/nvme0n1p1                         <span class="hljs-number"> 511 </span>   <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 508 </span>  1% /boot/efi<br>/dev/loop0                              <span class="hljs-number"> 49 </span>  <span class="hljs-number"> 49 </span>       <span class="hljs-number"> 0 </span>100% /snap/core18/2127<br>/dev/loop1                              <span class="hljs-number"> 29 </span>  <span class="hljs-number"> 29 </span>       <span class="hljs-number"> 0 </span>100% /snap/snapd/12707<br>/dev/loop2                              <span class="hljs-number"> 62 </span>  <span class="hljs-number"> 62 </span>       <span class="hljs-number"> 0 </span>100% /snap/lxd/21032<br>tmpfs                                  <span class="hljs-number"> 392 </span>   <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 392 </span>  0% /run/user/1000<br></code></pre></td></tr></table></figure><p>输入<code>ps</code>可以查看当前运行的一些进程，其实和top有点类似，但是没有监控功能，只能显示当前的。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs apache"><span class="hljs-attribute">test</span>@ubuntu-server:~$ ps<br>    <span class="hljs-attribute">PID</span> TTY          TIME CMD<br>  <span class="hljs-attribute">11438</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> bash<br>  <span class="hljs-attribute">11453</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number"><code class="language-hljs apache"><span class="hljs-attribute">test</span>@ubuntu-server:~$ ps<br>    <span class="hljs-attribute">PID</span> TTY          TIME CMD<br>  <span class="hljs-attribute">11438</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> bash<br>  <span class="hljs-attribute">11453</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> ps<br></code></pre></td></tr></table></figure><p>添加-ef查看所有的进程：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs tap">test@ubuntu-server:~$ ps -ef<br>UID          PID    PPID  C STIME TTY          TIME CMD<br>root          <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:02 /sbin/init<br>root          <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [kthreadd]<br>root          <span class="hljs-number"> 3 </span>     <span class="hljs-number"> 2 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [rcu_gp]<br>root          <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 2 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [rcu_par_gp]<br>root          <span class="hljs-number"> 6 </span>     <span class="hljs-number"> 2 </span><span class="hljs-number"><code class="language-hljs tap">test@ubuntu-server:~$ ps -ef<br>UID          PID    PPID  C STIME TTY          TIME CMD<br>root          <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:02 /sbin/init<br>root          <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [kthreadd]<br>root          <span class="hljs-number"> 3 </span>     <span class="hljs-number"> 2 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [rcu_gp]<br>root          <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 2 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [rcu_par_gp]<br>root          <span class="hljs-number"> 6 </span>     <span class="hljs-number"> 2 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [kworker/0:0H-kblockd]<br>...<br></code></pre></td></tr></table></figure><p>我们可以找到对应的进程ID（PID），使用kill命令将其强制终止：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs apache"><span class="hljs-attribute">test</span>@ubuntu-server:~$ ps<br>    <span class="hljs-attribute">PID</span> TTY          TIME CMD<br>  <span class="hljs-attribute">11438</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> bash<br>  <span class="hljs-attribute">11455</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> ps<br><span class="hljs-attribute">test</span>@ubuntu-server:~$ kill -<span class="hljs-number">9</span> <span class="hljs-number">11438</span><br><span class="hljs-attribute">Connection</span> to <span class="hljs-number"><code class="language-hljs apache"><span class="hljs-attribute">test</span>@ubuntu-server:~$ ps<br>    <span class="hljs-attribute">PID</span> TTY          TIME CMD<br>  <span class="hljs-attribute">11438</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> bash<br>  <span class="hljs-attribute">11455</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> ps<br><span class="hljs-attribute">test</span>@ubuntu-server:~$ kill -<span class="hljs-number">9</span> <span class="hljs-number">11438</span><br><span class="hljs-attribute">Connection</span> to <span class="hljs-number">192.168.10.6</span> closed.<br></code></pre></td></tr></table></figure><p>比如我们可以将当前会话的bash给杀死，那么会导致我们的连接直接断开，其中-9是一个信号，表示杀死进程：</p><ul><li>1 (HUP)：重新加载进程。</li><li>9 (KILL)：杀死一个进程。</li><li>15 (TERM)：正常停止一个进程。</li></ul><p>最后如果我们想要正常关机，只需要输入shutdown即可，系统会创建一个关机计划，并在指定时间关机，或是添加now表示立即关机：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs autoit">test<span class="hljs-symbol">@ubuntu</span>-server:~$ sudo <span class="hljs-built_in">shutdown</span><br>[sudo] password <span class="hljs-keyword">for</span> test: <br><span class="hljs-built_in">Shutdown</span> scheduled <span class="hljs-keyword">for</span> Mon <span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">46</span>:<span class="hljs-number">18</span> UTC, use <span class="hljs-string">&#x27;shutdown -c&#x27;</span> <span class="hljs-keyword">to</span> cancel.<br>test<span class="hljs-symbol">@ubuntu</span>-server:~$ sudo <span class="hljs-built_in">shutdown</span> now<br>Connection <span class="hljs-keyword">to</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.6</span> closed by remote host.<br>Connection <span class="hljs-keyword">to</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number"><code class="language-hljs autoit">test<span class="hljs-symbol">@ubuntu</span>-server:~$ sudo <span class="hljs-built_in">shutdown</span><br>[sudo] password <span class="hljs-keyword">for</span> test: <br><span class="hljs-built_in">Shutdown</span> scheduled <span class="hljs-keyword">for</span> Mon <span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">46</span>:<span class="hljs-number">18</span> UTC, use <span class="hljs-string">&#x27;shutdown -c&#x27;</span> <span class="hljs-keyword">to</span> cancel.<br>test<span class="hljs-symbol">@ubuntu</span>-server:~$ sudo <span class="hljs-built_in">shutdown</span> now<br>Connection <span class="hljs-keyword">to</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.6</span> closed by remote host.<br>Connection <span class="hljs-keyword">to</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.6</span> closed.<br></code></pre></td></tr></table></figure><h3 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h3><p>比较常用的压缩和解压也是重点，我们在Windows中经常需要下载一些压缩包，并且将压缩包解压才能获得里面的文件，而Linux中也支持文件的压缩和解压。</p><p>这里我们使用<code>tar</code>命令来完成文件亚索和解压操作，在Linux中比较常用的是gzip格式，后缀名一般为.gz，tar命令的参数-c表示对文件进行压缩，创建新的压缩文件，-x表示进行解压操作，-z表示以gzip格式进行操作，-v可以在处理过程中输出一些日志信息，-f表示对普通文件进行操作，这里我们创建三个文件并对这三个文件进行打包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zcvf test.tar.gz *.txt<br>1.txt<br>2.txt<br>3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>1.txt  2.txt  3.txt  test.tar.gz<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zcvf test.tar.gz *.txt<br>1.txt<br>2.txt<br>3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>1.txt  2.txt  3.txt  test.tar.gz<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <br></code></pre></td></tr></table></figure><p>接着我们删除刚刚三个文件，再执行解压操作，得到压缩包中文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ rm *.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>test.tar.gz<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zxvf test.tar.gz <br>1.txt<br>2.txt<br>3.txt<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ rm *.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>test.tar.gz<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zxvf test.tar.gz <br>1.txt<br>2.txt<br>3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>1.txt  2.txt  3.txt  test.tar.gz<br></code></pre></td></tr></table></figure><p>同样的，我们也可以对一个文件夹进行打包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ mv *.txt <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zcvf test.tar.gz <span class="hljs-built_in">test</span>/<br><span class="hljs-built_in">test</span>/<br><span class="hljs-built_in">test</span>/1.txt<br><span class="hljs-built_in">test</span>/2.txt<br><span class="hljs-built_in">test</span>/3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ rm -r <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>test.tar.gz <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zxvf test.tar.gz <br><span class="hljs-built_in">test</span>/<br><span class="hljs-built_in">test</span>/1.txt<br><span class="hljs-built_in">test</span>/2.txt<br><span class="hljs-built_in">test</span>/3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br><span class="hljs-built_in">test</span>  test.tar.gz<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls <span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ mv *.txt <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zcvf test.tar.gz <span class="hljs-built_in">test</span>/<br><span class="hljs-built_in">test</span>/<br><span class="hljs-built_in">test</span>/1.txt<br><span class="hljs-built_in">test</span>/2.txt<br><span class="hljs-built_in">test</span>/3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ rm -r <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br>test.tar.gz <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zxvf test.tar.gz <br><span class="hljs-built_in">test</span>/<br><span class="hljs-built_in">test</span>/1.txt<br><span class="hljs-built_in">test</span>/2.txt<br><span class="hljs-built_in">test</span>/3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls<br><span class="hljs-built_in">test</span>  test.tar.gz<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ls <span class="hljs-built_in">test</span><br>1.txt  2.txt  3.txt<br></code></pre></td></tr></table></figure><p>到此，Linux的一些基本命令就讲解为止。</p><hr><h2 id="vim文本编辑器"><a href="#vim文本编辑器" class="headerlink" title="vim文本编辑器"></a>vim文本编辑器</h2><p>和Windows中的记事本一样，Linux中也有文本编辑器，叫做Vi编辑器，Ubuntu中内置了Vi编辑器的升级版Vim，我们这里就讲解Vim编辑器的使用。</p><p>我们可以直接输入<code>vim 文件名称</code>来使用Vim编辑器对文本文件进行编辑：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ vim hello.txt<br></code></pre></td></tr></table></figure><p>进入编辑器之后，我们发现界面变成了：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs haml"><code class="language-hljs haml">~                                                                                                                                                                                         <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>"hello.txt" [New File]                                                            0,0-1         All<br></code></pre></td></tr></table></figure><p>这时我们直接输入内容是无法完成的，因为默认进入之后为<code>命令模式</code>，Vim编辑器默认有三种模式：</p><p><img src="http://c.biancheng.net/uploads/allimg/180914/1-1P9141F35R32.jpg" alt="img"></p><ul><li>命令模式：此模式下可以输入任意的命令进行操作，所有的输入都被看做是命令输入，而不是文本编辑输入。</li><li>编辑模式：此模式下输入的任何内容都会以文本编辑方式写入到文件中，就像我们直接在Windows的记事本中写内容一样。</li><li>末行模式：此模式下用于输入一些复杂命令，会在最后一行进行复杂命令的输入。</li></ul><p>在命令模式下，我们可以直接按下键盘上的<code>i</code>，此命令表示进行插入操作，会自动切换到编辑模式，这时可以看到最下方变为：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs haml">~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>-<span class="ruby">- INSERT --                                                                      <span class="hljs-number">1</span>,<span class="hljs-number"><code class="language-hljs haml">~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>-<span class="ruby">- INSERT --                                                                      <span class="hljs-number">1</span>,<span class="hljs-number">1</span>           All</span><br></code></pre></td></tr></table></figure><p>而这时我们所有的输入内容都可以直接写到文件中了，如果我们想回到命令模式，按下<code>Esc</code>键即可。</p><p>除了<code>i</code>以外，我们也可以按下<code>a</code>表示从当前光标所在位置之后继续写，与<code>i</code>不同的是，<code>i</code>会在光标之前继续写，<code>o</code>会直接跳到下一行，而<code>A</code>表示在当前行的最后继续写入，<code>I</code>表示在当前行的最前面继续写入。</p><p>这里我们随便粘贴一段文本信息进去（不要用Ctrl+V，Linux中没这操作，XShell右键点粘贴）：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs applescript">I was hard <span class="hljs-keyword">on</span> people sometimes, probably harder than I needed <span class="hljs-keyword">to</span> be. <br>I remember <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> when Reed was six years old, coming home, <span class="hljs-keyword">and</span> I had just fired somebody <span class="hljs-keyword">that</span> <span class="hljs-built_in">day</span>.<br>And I imagined what <span class="hljs-keyword">it</span> was like <span class="hljs-keyword">for</span> <span class="hljs-keyword">that</span> person <span class="hljs-keyword">to</span> <span class="hljs-keyword">tell</span> his family <span class="hljs-keyword">and</span> his young son <span class="hljs-keyword">that</span> he had lost his job. <br>It was hard. <br>But　somebody’s got <span class="hljs-keyword">to</span> do <span class="hljs-keyword">it</span>. <br>I figured <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> was always <span class="hljs-keyword">my</span> job <span class="hljs-keyword">to</span> make sure <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> team was excellent, <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span> I didn’t do <span class="hljs-keyword">it</span>, nobody was going <span class="hljs-keyword">to</span> do <span class="hljs-keyword">it</span>.<br>You always have <span class="hljs-keyword">to</span> keep pushing <span class="hljs-keyword">to</span> innovate.<br>Dylan could have sung protest songs forever <span class="hljs-keyword">and</span> probably made a lot <span class="hljs-keyword">of</span> money, <span class="hljs-keyword">but</span> he didn’t. <br>He had <span class="hljs-keyword">to</span> move <span class="hljs-keyword">on</span>, <span class="hljs-keyword">and</span> when he did, <span class="hljs-keyword">by</span> going electric <span class="hljs-keyword">in</span> <span class="hljs-number">1965</span>, he alienated a lot <span class="hljs-keyword"><code class="language-hljs applescript">I was hard <span class="hljs-keyword">on</span> people sometimes, probably harder than I needed <span class="hljs-keyword">to</span> be. <br>I remember <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> when Reed was six years old, coming home, <span class="hljs-keyword">and</span> I had just fired somebody <span class="hljs-keyword">that</span> <span class="hljs-built_in">day</span>.<br>And I imagined what <span class="hljs-keyword">it</span> was like <span class="hljs-keyword">for</span> <span class="hljs-keyword">that</span> person <span class="hljs-keyword">to</span> <span class="hljs-keyword">tell</span> his family <span class="hljs-keyword">and</span> his young son <span class="hljs-keyword">that</span> he had lost his job. <br>It was hard. <br>But　somebody’s got <span class="hljs-keyword">to</span> do <span class="hljs-keyword">it</span>. <br>I figured <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> was always <span class="hljs-keyword">my</span> job <span class="hljs-keyword">to</span> make sure <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> team was excellent, <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span> I didn’t do <span class="hljs-keyword">it</span>, nobody was going <span class="hljs-keyword">to</span> do <span class="hljs-keyword">it</span>.<br>You always have <span class="hljs-keyword">to</span> keep pushing <span class="hljs-keyword">to</span> innovate.<br>Dylan could have sung protest songs forever <span class="hljs-keyword">and</span> probably made a lot <span class="hljs-keyword">of</span> money, <span class="hljs-keyword">but</span> he didn’t. <br>He had <span class="hljs-keyword">to</span> move <span class="hljs-keyword">on</span>, <span class="hljs-keyword">and</span> when he did, <span class="hljs-keyword">by</span> going electric <span class="hljs-keyword">in</span> <span class="hljs-number">1965</span>, he alienated a lot <span class="hljs-keyword">of</span> people.<br></code></pre></td></tr></table></figure><p>在我们编辑完成之后，需要进入到末行模式进行文件的保存并退出，按下<code>:</code>进入末行模式，再输入wq即可保存退出。</p><p>接着我们来看一些比较常用的命令，首先是命令模式下的光标移动命令：</p><ul><li>^   直接调到本行最前面</li><li>$   直接跳到本行最后面</li><li>gg  直接跳到第一行</li><li>[N]G    跳转到第N行</li><li>[N]方向键    向一个方向跳转N个字符</li></ul><p>在末行模式下，常用的复杂命令有：</p><ul><li>:set number    开启行号</li><li>:w    保存</li><li>:wq或:x    保存并关闭</li><li>:q    关闭</li><li>:q!    强制关闭</li></ul><p>我们可以输入<code>/</code>或是<code>?</code>在末行模式中使用搜索功能，比如我们要搜索单词<code>it</code>：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs applescript">/<span class="hljs-keyword"><code class="language-hljs applescript">/<span class="hljs-keyword">it</span>  <br></code></pre></td></tr></table></figure><p>接着会在文本中出现高亮，按<code>n</code>跳转到下一个搜索结果，?是从后向前搜索，/是从前向后搜索。</p><p>它还支持替换功能，但是使用起来稍微比较复杂，语法如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs awk">:[addr]s<span class="hljs-regexp"><code class="language-hljs awk">:[addr]s<span class="hljs-regexp">/源字符串/</span>目的字符串/[option]<br></code></pre></td></tr></table></figure><p>addr表示第几行或是一个范围，option表示操作类型：</p><ul><li>g: globe,表示全局替换</li><li>c: confirm,表示进行确认</li><li>p: 表示替代结果逐行显示(Ctrl + L恢复屏幕)</li><li>i:  ignore,不区分大小写</li></ul><p>比如我们要将当前行中的<code>it</code>全部替换为<code>he</code>，那么可以这样写：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs elixir"><span class="hljs-symbol"><code class="language-hljs elixir"><span class="hljs-symbol">:s/it/he/g</span><br></code></pre></td></tr></table></figure><p>实际上除了以上三种模式外，还有一种模式叫做可视化模式，按下键盘上的<code>v</code>即可进入，它能够支持选取一段文本，选取后，我们可以对指定段落的文本内容快速进行复制、剪切、删除、插入等操作，非常方便。在此模式下，我们可以通过上下左右键进行选取，以进入可视化模式时的位置作为基本位置，通过移动另一端来进行选取。</p><p>我们可以使用以下命令来对选中区域进行各种操作：</p><ul><li>y   复制选中区域</li><li>d/x   剪切（删除）选中区域</li><li>p  粘贴</li><li>u  撤销上一步</li></ul><p>当然，这些命令在命令模式下也可以使用，但是可视化模式下使用更适合一些。</p><hr><h2 id="环境安装和项目部署"><a href="#环境安装和项目部署" class="headerlink" title="环境安装和项目部署"></a>环境安装和项目部署</h2><p>在学习完了Linux操作系统的一些基本操作之后，我们接着来看如何进行项目的环境安装和部署，包括安装JDK、Nginx服务器，以及上传我们的SpringBoot项目并运行。</p><p>我们可以直接使用apt进行软件的安装，它是一个高级的安装包管理工具，我们可以直接寻找对应的软件进行安装，无需再去官网进行下载，非常方便，软件仓库中默认已经帮助我们存放了大量实用软件的安装包，只需要一个安装命令就可以进行安装了。</p><p>实际上Ubuntu系统已经为我们自带了一些环境了，比如Python3：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs awk">test@ubuntu-server:~$ python3<br>Python <span class="hljs-number">3.8</span>.<span class="hljs-number">10</span> (default, Nov <span class="hljs-number">26</span> <span class="hljs-number">2021</span>, <span class="hljs-number">20</span>:<span class="hljs-number">14</span>:<span class="hljs-number">08</span>) <br>[GCC <span class="hljs-number">9.3</span>.<span class="hljs-number">0</span>] on linux<br>Type <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span> or <span class="hljs-string">&quot;license&quot;</span> <span class="hljs-keyword">for</span> more information.<br>&gt;&gt;&gt; print(<span class="hljs-string">&quot;HelloWorld！&quot;</span>)<br>HelloWorld！<br>&gt;&gt;&gt; <span class="hljs-keyword"><code class="language-hljs awk">test@ubuntu-server:~$ python3<br>Python <span class="hljs-number">3.8</span>.<span class="hljs-number">10</span> (default, Nov <span class="hljs-number">26</span> <span class="hljs-number">2021</span>, <span class="hljs-number">20</span>:<span class="hljs-number">14</span>:<span class="hljs-number">08</span>) <br>[GCC <span class="hljs-number">9.3</span>.<span class="hljs-number">0</span>] on linux<br>Type <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span> or <span class="hljs-string">&quot;license&quot;</span> <span class="hljs-keyword">for</span> more information.<br>&gt;&gt;&gt; print(<span class="hljs-string">&quot;HelloWorld！&quot;</span>)<br>HelloWorld！<br>&gt;&gt;&gt; <span class="hljs-keyword">exit</span>()<br></code></pre></td></tr></table></figure><p>C语言的编译工具GCC可以通过APT进行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">sudo apt install gcc<br></code></pre></td></tr></table></figure><p>安装后，可以编写一个简单的C语言程序并且编译为可执行文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string"><code class="language-hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!\n"</span>);<br>&#125;  <br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ vim hello.c<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ gcc hello.c -o hello<br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ vim hello.c<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ gcc hello.c -o hello<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ./hello <br>Hello World!<br></code></pre></td></tr></table></figure><p>而JDK实际上安装也非常简单，通过APT即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo apt install openjdk-8-j<br>openjdk-8-jdk           openjdk-8-jre           openjdk-8-jre-zero      <br>openjdk-8-jdk-headless  openjdk-8-jre-headless  <br><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo apt install openjdk-8-j<br>openjdk-8-jdk           openjdk-8-jre           openjdk-8-jre-zero      <br>openjdk-8-jdk-headless  openjdk-8-jre-headless  <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>接着我们来测试一下编译和运行，首先编写一个Java程序：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs elixir">test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable"><code class="language-hljs elixir">test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable">$ </span>vim Main.java<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span>&#123;</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123;<br>                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string"><code class="language-hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span>&#123;</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123;<br>                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Hello World！"</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs ruby">test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable">$ </span>javac Main.java <br>test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable">$ </span>ls<br>Main.<span class="hljs-keyword">class</span>  Main.java<br>test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable"><code class="language-hljs ruby">test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable">$ </span>javac Main.java <br>test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable">$ </span>ls<br>Main.<span class="hljs-keyword">class</span>  Main.java<br>test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable">$ </span>java Main <br>Hello World！<br></code></pre></td></tr></table></figure><p>接着我们来部署一下Redis服务器：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs cmake"><span class="hljs-keyword">test</span>@ubuntu-server:~$ sudo apt <span class="hljs-keyword"><code class="language-hljs cmake"><span class="hljs-keyword">test</span>@ubuntu-server:~$ sudo apt <span class="hljs-keyword">install</span> redis<br></code></pre></td></tr></table></figure><p>安装完成后，可以直接使用<code>redis-cli</code>命令打开Redis客户端连接本地的服务器：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs accesslog">test@ubuntu-server:~$ redis-cli<br><span class="hljs-number"><code class="language-hljs accesslog">test@ubuntu-server:~$ redis-cli<br><span class="hljs-number">127.0.0.1:6379</span>> keys *<br>(empty list or set)<br></code></pre></td></tr></table></figure><p>使用和之前Windows下没有区别。</p><p>接着我们安装一下MySQL服务器，同样的，直接使用apt即可：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs apache"><span class="hljs-attribute">sudo</span> apt install mysql-server-<span class="hljs-number">8</span>.<span class="hljs-number"><code class="language-hljs apache"><span class="hljs-attribute">sudo</span> apt install mysql-server-<span class="hljs-number">8</span>.<span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p>我们直接直接登录MySQL服务器，注意要在root权限下使用，这样就不用输入密码了：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs smali">sudo mysql -u root -p<br>Enter password: <br>Welcome to the MySQ<span class="hljs-class">L monitor.  Commands end with ;</span><span class="hljs-built_in"> or </span>\g.<br>Your MySQL connection id is 11<br>Server version: 8.0.27-0ubuntu0.20.04.1 (Ubuntu)<br><br>Copyright (c) 2000, 2021, Oracle<span class="hljs-built_in"> and/or </span>its affiliates.<br><br>Oracle is a registered trademark of Oracle Corporation<span class="hljs-built_in"> and/or </span>its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#x27;help;&#x27;<span class="hljs-built_in"><code class="language-hljs smali">sudo mysql -u root -p<br>Enter password: <br>Welcome to the MySQ<span class="hljs-class">L monitor.  Commands end with ;</span><span class="hljs-built_in"> or </span>\g.<br>Your MySQL connection id is 11<br>Server version: 8.0.27-0ubuntu0.20.04.1 (Ubuntu)<br><br>Copyright (c) 2000, 2021, Oracle<span class="hljs-built_in"> and/or </span>its affiliates.<br><br>Oracle is a registered trademark of Oracle Corporation<span class="hljs-built_in"> and/or </span>its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#x27;help;&#x27;<span class="hljs-built_in"> or </span>&#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.<br><br>mysql> exit<br></code></pre></td></tr></table></figure><p>可以发现实际上就是我们之前在Windows的CMD中使用的样子，接着我们就创建一个生产环境下使用的数据库：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs gherkin">mysql&gt; create database book_manage;<br>mysql&gt; show databases;<br>+--------------------+<br>|<span class="hljs-string"> Database           </span>|<br>+--------------------+<br>|<span class="hljs-string"> book_manage        </span>|<br>|<span class="hljs-string"> information_schema </span>|<br>|<span class="hljs-string"> mysql              </span>|<br>|<span class="hljs-string"> performance_schema </span>|<br>|<span class="hljs-string"><code class="language-hljs gherkin">mysql&gt; create database book_manage;<br>mysql&gt; show databases;<br>+--------------------+<br>|<span class="hljs-string"> Database           </span>|<br>+--------------------+<br>|<span class="hljs-string"> book_manage        </span>|<br>|<span class="hljs-string"> information_schema </span>|<br>|<span class="hljs-string"> mysql              </span>|<br>|<span class="hljs-string"> performance_schema </span>|<br>|<span class="hljs-string"> sys                </span>|<br>+--------------------+<br>5 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>接着我们创建一个用户来使用这个数据，一会我们就可以将SpringBoot配置文件进行修改并直接放到此服务器上进行部署。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs pgsql">mysql&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> test identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql&gt; <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> book_manage.* <span class="hljs-keyword">to</span> test;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number"><code class="language-hljs pgsql">mysql&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> test identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql&gt; <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> book_manage.* <span class="hljs-keyword">to</span> test;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>如果觉得这样很麻烦不是可视化的，可以使用Navicat连接进行操作，注意开启一下MySQL的外网访问。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre class=" language-hljs smali">test@ubuntu-server:~$ mysql -u test -p<br>Enter password: <br>Welcome to the MySQ<span class="hljs-class">L monitor.  Commands end with ;</span><span class="hljs-built_in"> or </span>\g.<br>Your MySQL connection id is 13<br>Server version: 8.0.27-0ubuntu0.20.04.1 (Ubuntu)<br><br>Copyright (c) 2000, 2021, Oracle<span class="hljs-built_in"> and/or </span>its affiliates.<br><br>Oracle is a registered trademark of Oracle Corporation<span class="hljs-built_in"> and/or </span>its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#x27;help;&#x27;<span class="hljs-built_in"><code class="language-hljs smali">test@ubuntu-server:~$ mysql -u test -p<br>Enter password: <br>Welcome to the MySQ<span class="hljs-class">L monitor.  Commands end with ;</span><span class="hljs-built_in"> or </span>\g.<br>Your MySQL connection id is 13<br>Server version: 8.0.27-0ubuntu0.20.04.1 (Ubuntu)<br><br>Copyright (c) 2000, 2021, Oracle<span class="hljs-built_in"> and/or </span>its affiliates.<br><br>Oracle is a registered trademark of Oracle Corporation<span class="hljs-built_in"> and/or </span>its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#x27;help;&#x27;<span class="hljs-built_in"> or </span>&#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.<br><br>mysql> show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| book_manage        |<br>| information_schema |<br>+--------------------+<br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>使用test用户登录之后，查看数据库列表，有book_manage就OK了。</p><p>最后我们修改一下SpringBoot项目的生产环境配置即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">javastudy111@163.com</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">TKPGLAPDSWKGJOWK</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/book_manage</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">hibernate:</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><br><span class="hljs-attr">springfox:</span><br>  <span class="hljs-attr">documentation:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal"><code class="language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">javastudy111@163.com</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">TKPGLAPDSWKGJOWK</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/book_manage</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">hibernate:</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><br><span class="hljs-attr">springfox:</span><br>  <span class="hljs-attr">documentation:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>然后启动我们的项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><span class="hljs-built_in"><code class="language-hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ java -jar springboot-project-0.0.1-SNAPSHOT.jar <br></code></pre></td></tr></table></figure><p>现在我们将前端页面的API访问地址修改为我们的SpringBoot服务器地址，即可正常使用了。</p><p>我们也可以将我们的静态资源使用Nginx服务器进行代理：</p><blockquote><p>Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 在高连接并发的情况下，Nginx是Apache服务器不错的替代品。</p></blockquote><p>Nginx非常强大，它能够通提供非常方便的反向代理服务，并且支持负载均衡，不过我们这里用一下反向代理就可以了，实际上就是代理我们的前端页面，然后我们访问Nginx服务器即可访问到静态资源，这样我们前后端都放在了服务器上（你也可以搞两台服务器，一台挂静态资源一台挂SpringBoot服务器，实现真正意义上的分离，有条件的还能上个域名和证书啥的）。</p><p>安装如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs cmake"><span class="hljs-keyword">test</span>@ubuntu-server:~$ sudo apt <span class="hljs-keyword"><code class="language-hljs cmake"><span class="hljs-keyword">test</span>@ubuntu-server:~$ sudo apt <span class="hljs-keyword">install</span> nginx<br></code></pre></td></tr></table></figure><p>安装完成后，我们可以直接访问：<a href="http://192.168.10.4/%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%87%BA%E7%8E%B0Nginx%E9%A1%B5%E9%9D%A2%E8%A1%A8%E7%A4%BA%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%EF%BC%81">http://192.168.10.4/，能够出现Nginx页面表示安装成功！</a></p><p>接着我们将静态资源上传到Linux服务器中，然后对Nginx进行反向代理配置：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs stata"><span class="hljs-keyword">test</span>@ubuntu-server:~$ <span class="hljs-keyword">cd</span> /etc/nginx/<br><span class="hljs-keyword">test</span>@ubuntu-server:/etc/nginx$ <span class="hljs-keyword">ls</span><br><span class="hljs-keyword">conf</span>.<span class="hljs-keyword">d</span>koi-utf     modules-available  proxy_paramssites-enabled  <span class="hljs-keyword">win</span>-utf<br>fastcgi.<span class="hljs-keyword">conf</span>koi-<span class="hljs-keyword">win</span>     modules-enabled    scgi_paramssnippets<br>fastcgi_paramsmime.types  nginx.<span class="hljs-keyword">conf</span>       sites-availableuwsgi_params<br><span class="hljs-keyword">test</span>@ubuntu-server:/etc/nginx$ sudo vim nginx.<span class="hljs-keyword"><code class="language-hljs stata"><span class="hljs-keyword">test</span>@ubuntu-server:~$ <span class="hljs-keyword">cd</span> /etc/nginx/<br><span class="hljs-keyword">test</span>@ubuntu-server:/etc/nginx$ <span class="hljs-keyword">ls</span><br><span class="hljs-keyword">conf</span>.<span class="hljs-keyword">d</span>koi-utf     modules-available  proxy_paramssites-enabled  <span class="hljs-keyword">win</span>-utf<br>fastcgi.<span class="hljs-keyword">conf</span>koi-<span class="hljs-keyword">win</span>     modules-enabled    scgi_paramssnippets<br>fastcgi_paramsmime.types  nginx.<span class="hljs-keyword">conf</span>       sites-availableuwsgi_params<br><span class="hljs-keyword">test</span>@ubuntu-server:/etc/nginx$ sudo vim nginx.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs nginx"><span class="hljs-section">server</span> &#123;<br>                <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>                <span class="hljs-attribute">server_name</span>  <span class="hljs-number">192.168.10.4</span>;<br>                <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin *;<br>                <span class="hljs-attribute">location</span> / &#123;<br>                        <span class="hljs-attribute">root</span> /home/test/static;<br>                        <span class="hljs-attribute">charset</span> utf-<span class="hljs-number">8</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string"><code class="language-hljs nginx"><span class="hljs-section">server</span> &#123;<br>                <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>                <span class="hljs-attribute">server_name</span>  <span class="hljs-number">192.168.10.4</span>;<br>                <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin *;<br>                <span class="hljs-attribute">location</span> / &#123;<br>                        <span class="hljs-attribute">root</span> /home/test/static;<br>                        <span class="hljs-attribute">charset</span> utf-<span class="hljs-number">8</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;Content-Type,*&#x27;</span>;<br>                &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>然后就可以直接访问到我们的前端页面了，这时再开启SpringBoot服务器即可，可以在最后添加&amp;符号表示后台启动。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/13/1.html/"/>
      <url>/2022/04/13/1.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F174788b2ec1d828d85a0a7ac65bea2cd.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644064714&t=46bead84c9b2fb6e0b65fd4afdaf805e" alt="点击查看源网页"></p><h1 id="SpringBoot一站式开发"><a href="#SpringBoot一站式开发" class="headerlink" title="SpringBoot一站式开发"></a>SpringBoot一站式开发</h1><p>官网：<a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p><blockquote><p>Spring Boot可以轻松创建独立的、基于Spring的生产级应用程序，它可以让你“运行即可”。大多数Spring Boot应用程序只需要少量的Spring配置。</p></blockquote><p>SpringBoot功能：</p><ul><li>创建独立的Spring应用程序</li><li>直接嵌入Tomcat、Jetty或Undertow（无需部署WAR包，打包成Jar本身就是一个可以运行的应用程序）</li><li>提供一站式的“starter”依赖项，以简化Maven配置（需要整合什么框架，直接导对应框架的starter依赖）</li><li>尽可能自动配置Spring和第三方库（除非特殊情况，否则几乎不需要你进行什么配置）</li><li>提供生产就绪功能，如指标、运行状况检查和外部化配置</li><li>没有代码生成，也没有XML配置的要求（XML是什么，好吃吗）</li></ul><p>SpringBoot是现在最主流的开发框架，它提供了一站式的开发体验，大幅度提高了我们的开发效率。</p><h2 id="走进SpringBoot"><a href="#走进SpringBoot" class="headerlink" title="走进SpringBoot"></a>走进SpringBoot</h2><p>在SSM阶段，当我们需要搭建一个基于Spring全家桶的Web应用程序时，我们不得不做大量的依赖导入和框架整合相关的Bean定义，光是整合框架就花费了我们大量的时间，但是实际上我们发现，整合框架其实基本都是一些固定流程，我们每创建一个新的Web应用程序，基本都会使用同样的方式去整合框架，我们完全可以将一些重复的配置作为约定，只要框架遵守这个约定，为我们提供默认的配置就好，这样就不用我们再去配置了，约定优于配置！</p><p>而SpringBoot正是将这些过程大幅度进行了简化，它可以自动进行配置，我们只需要导入对应的启动器（starter）依赖即可。</p><p>完成本阶段的学习，基本能够胜任部分网站系统的后端开发工作，也建议同学们学习完SpringBoot之后寻找合适的队友去参加计算机项目相关的高校竞赛。</p><p>我们可以通过IDEA来演示如何快速创建一个SpringBoot项目，并且无需任何配置，就可以实现Bean注册。</p><h2 id="SpringBoot项目文件结构"><a href="#SpringBoot项目文件结构" class="headerlink" title="SpringBoot项目文件结构"></a>SpringBoot项目文件结构</h2><p>我们在创建SpringBoot项目之后，首先会自动生成一个主类，而主类中的<code>main</code>方法中调用了<code>SpringApplication</code>类的静态方法来启动整个SpringBoot项目，并且我们可以看到主类的上方有一个<code>@SpringBootApplication</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootTestApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootTestApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringBootTestApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>同时还自带了一个测试类，测试类的上方仅添加了一个<code>@SpringBootTest</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootTestApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootTestApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看Maven中写了哪些内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  父工程  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-study<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>SpringBootTest<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>SpringBootTest<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  spring-boot-starter SpringBoot核心启动器  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  spring-boot-starter-test SpringBoot测试模块启动器  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--  SpringBoot Maven插件，打包Jar都不用你操心了   --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  父工程  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-study<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>SpringBootTest<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>SpringBootTest<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  spring-boot-starter SpringBoot核心启动器  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  spring-boot-starter-test SpringBoot测试模块启动器  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--  SpringBoot Maven插件，打包Jar都不用你操心了   --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>></span><br></code></pre></td></tr></table></figure><p>除了以上这些文件以外，我们的项目目录下还有：</p><ul><li>.gitignore  -  Git忽略名单，下一章我们会专门讲解Git版本控制。</li><li>application.properties   -    SpringBoot的配置文件，所有依赖的配置都在这里编写，但是一般情况下只需要配置必要项即可。</li></ul><hr><h2 id="整合Web相关框架"><a href="#整合Web相关框架" class="headerlink" title="整合Web相关框架"></a>整合Web相关框架</h2><p>我们来看一下，既然我们前面提到SpringBoot会内嵌一个Tomcat服务器，也就是说我们的Jar打包后，相当于就是一个可以直接运行的应用程序，我们来看一下如何创建一个SpringBootWeb项目。</p><p>这里我们演示使用IDEA来创建一个基于SpringBoot的Web应用程序。</p><h3 id="它是真的快"><a href="#它是真的快" class="headerlink" title="它是真的快"></a>它是真的快</h3><p>创建完成后，直接开启项目，我们就可以直接访问：<a href="http://localhost:8080/%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E4%BD%86%E6%98%AF%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E6%B2%A1%E6%9C%89%E7%BC%96%E5%86%99%E4%BB%BB%E4%BD%95%E7%9A%84%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%EF%BC%8C%E6%89%80%E4%BB%A5%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E3%80%82%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%97%A5%E5%BF%97%EF%BC%9A">http://localhost:8080/，我们可以看到，但是由于我们没有编写任何的请求映射，所以没有数据。我们可以来看看日志：</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs stylus"><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.308</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> c<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.SpringBootWebTestApplication</span>   : Starting SpringBootWebTestApplication using Java <span class="hljs-number">1.8</span>.<span class="hljs-number">0</span>_312 on NagodeMacBook-Pro<span class="hljs-selector-class">.local</span> with PID <span class="hljs-number">853</span> (/Users/nagocoler/Downloads/SpringBootWebTest/target/classes started by nagocoler <span class="hljs-keyword">in</span> /Users/nagocoler/Downloads/SpringBootWebTest)<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.309</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> c<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.SpringBootWebTestApplication</span>   : No active profile set, falling back to default profiles: default<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.629</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.w</span><span class="hljs-selector-class">.embedded</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-selector-class">.TomcatWebServer</span>  : Tomcat initialized with port(s): <span class="hljs-number">8080</span> (http)<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.632</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardService</span>   : Starting service <span class="hljs-selector-attr">[Tomcat]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.632</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardEngine</span>  : Starting Servlet engine: <span class="hljs-selector-attr">[Apache Tomcat/9.0.56]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.654</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-attr">[Tomcat]</span>.<span class="hljs-selector-attr">[localhost]</span>.<span class="hljs-selector-attr">[/]</span>       : Initializing Spring embedded WebApplicationContext<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.654</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> w<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.ServletWebServerApplicationContext</span> : Root WebApplicationContext: initialization completed <span class="hljs-keyword">in</span> <span class="hljs-number">325</span> ms<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.780</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.w</span><span class="hljs-selector-class">.embedded</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-selector-class">.TomcatWebServer</span>  : Tomcat started on port(s): <span class="hljs-number">8080</span> (http) with context path <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.785</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> c<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.SpringBootWebTestApplication</span>   : Started SpringBootWebTestApplication <span class="hljs-keyword">in</span> <span class="hljs-number">0.62</span> seconds (JVM running <span class="hljs-keyword">for</span> <span class="hljs-number">0.999</span>)<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">02.979</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> o<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-attr">[Tomcat]</span>.<span class="hljs-selector-attr">[localhost]</span>.<span class="hljs-selector-attr">[/]</span>       : Initializing Spring DispatcherServlet <span class="hljs-string">&#x27;dispatcherServlet&#x27;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">02.979</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.DispatcherServlet</span>        : Initializing Servlet <span class="hljs-string">&#x27;dispatcherServlet&#x27;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">02.980</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.DispatcherServlet</span>        : Completed initialization <span class="hljs-keyword">in</span> <span class="hljs-number"><code class="language-hljs stylus"><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.308</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> c<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.SpringBootWebTestApplication</span>   : Starting SpringBootWebTestApplication using Java <span class="hljs-number">1.8</span>.<span class="hljs-number">0</span>_312 on NagodeMacBook-Pro<span class="hljs-selector-class">.local</span> with PID <span class="hljs-number">853</span> (/Users/nagocoler/Downloads/SpringBootWebTest/target/classes started by nagocoler <span class="hljs-keyword">in</span> /Users/nagocoler/Downloads/SpringBootWebTest)<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.309</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> c<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.SpringBootWebTestApplication</span>   : No active profile set, falling back to default profiles: default<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.629</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.w</span><span class="hljs-selector-class">.embedded</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-selector-class">.TomcatWebServer</span>  : Tomcat initialized with port(s): <span class="hljs-number">8080</span> (http)<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.632</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardService</span>   : Starting service <span class="hljs-selector-attr">[Tomcat]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.632</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardEngine</span>  : Starting Servlet engine: <span class="hljs-selector-attr">[Apache Tomcat/9.0.56]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.654</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-attr">[Tomcat]</span>.<span class="hljs-selector-attr">[localhost]</span>.<span class="hljs-selector-attr">[/]</span>       : Initializing Spring embedded WebApplicationContext<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.654</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> w<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.ServletWebServerApplicationContext</span> : Root WebApplicationContext: initialization completed <span class="hljs-keyword">in</span> <span class="hljs-number">325</span> ms<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.780</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.w</span><span class="hljs-selector-class">.embedded</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-selector-class">.TomcatWebServer</span>  : Tomcat started on port(s): <span class="hljs-number">8080</span> (http) with context path <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.785</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> c<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.SpringBootWebTestApplication</span>   : Started SpringBootWebTestApplication <span class="hljs-keyword">in</span> <span class="hljs-number">0.62</span> seconds (JVM running <span class="hljs-keyword">for</span> <span class="hljs-number">0.999</span>)<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">02.979</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> o<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-attr">[Tomcat]</span>.<span class="hljs-selector-attr">[localhost]</span>.<span class="hljs-selector-attr">[/]</span>       : Initializing Spring DispatcherServlet <span class="hljs-string">&#x27;dispatcherServlet&#x27;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">02.979</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.DispatcherServlet</span>        : Initializing Servlet <span class="hljs-string">&#x27;dispatcherServlet&#x27;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">02.980</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.DispatcherServlet</span>        : Completed initialization <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ms<br></code></pre></td></tr></table></figure><p>我们可以看到，日志中除了最基本的SpringBoot启动日志以外，还新增了内嵌Web服务器（Tomcat）的启动日志，并且显示了当前Web服务器所开放的端口，并且自动帮助我们初始化了DispatcherServlet，但是我们只是创建了项目，导入了web相关的starter依赖，没有进行任何的配置，实际上它使用的是starter提供的默认配置进行初始化的。</p><p>由于SpringBoot是自动扫描的，因此我们直接创建一个Controller即可被加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainController</span> </span>&#123;<br><br>  <span class="hljs-comment">//直接访问http://localhost:8080/index即可，不用加web应用程序名称了</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainController</span> </span>&#123;<br><br>  <span class="hljs-comment">//直接访问http://localhost:8080/index即可，不用加web应用程序名称了</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"你好，欢迎访问主页！"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们几乎没有做任何配置，但是可以直接开始配置Controller，SpringBoot创建一个Web项目的速度就是这么快！</p><p>它还可以自动识别类型，如果我们返回的是一个对象类型的数据，那么它会自动转换为JSON数据格式，无需配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sid;<br>    String name;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@RequestMapping(&quot;/student&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">student</span><span class="hljs-params">()</span></span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    student.setName(<span class="hljs-string">&quot;小明&quot;</span>);<br>    student.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>    student.setSid(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@RequestMapping(&quot;/student&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">student</span><span class="hljs-params">()</span></span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    student.setName(<span class="hljs-string">&quot;小明&quot;</span>);<br>    student.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>    student.setSid(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> student;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后浏览器能够直接得到<code>application/json</code>的响应数据，就是这么方便。</p><h3 id="修改Web相关配置"><a href="#修改Web相关配置" class="headerlink" title="修改Web相关配置"></a>修改Web相关配置</h3><p>如果我们需要修改Web服务器的端口或是一些其他的内容，我们可以直接在<code>application.properties</code>中进行修改，它是整个SpringBoot的配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-comment"># 修改端口为80</span><br><span class="hljs-meta">server.port</span>=<span class="hljs-string"><code class="language-hljs properties"><span class="hljs-comment"># 修改端口为80</span><br><span class="hljs-meta">server.port</span>=<span class="hljs-string">80</span><br></code></pre></td></tr></table></figure><p>我们还可以编写自定义的配置项，并在我们的项目中通过<code>@Value</code>直接注入：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-meta">test.data</span>=<span class="hljs-string"><code class="language-hljs properties"><span class="hljs-meta">test.data</span>=<span class="hljs-string">100</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;test.data&#125;&quot;)</span><br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;test.data&#125;&quot;)</span><br>    <span class="hljs-keyword">int</span> data;<br></code></pre></td></tr></table></figure><p>通过这种方式，我们就可以更好地将一些需要频繁修改的配置项写在配置文件中，并通过注解方式去获取值。</p><p>配置文件除了使用<code>properties</code>格式以外，还有一种叫做<code>yaml</code>格式，它的语法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-string">一级目录:</span><br><span class="hljs-string">二级目录:</span><br>  <span class="hljs-string">三级目录1:</span> <span class="hljs-string">值</span><br>  <span class="hljs-string">三级目录2:</span> <span class="hljs-string">值</span><br>  <span class="hljs-string">三级目录List:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">元素1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">元素2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string"><code class="language-hljs yaml"><span class="hljs-string">一级目录:</span><br><span class="hljs-string">二级目录:</span><br>  <span class="hljs-string">三级目录1:</span> <span class="hljs-string">值</span><br>  <span class="hljs-string">三级目录2:</span> <span class="hljs-string">值</span><br>  <span class="hljs-string">三级目录List:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">元素1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">元素2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">元素3</span><br></code></pre></td></tr></table></figure><p>我们可以看到，每一级目录都是通过缩进（不能使用Tab，只能使用空格）区分，并且键和值之间需要添加冒号+空格来表示。</p><p>SpringBoot也支持这种格式的配置文件，我们可以将<code>application.properties</code>修改为<code>application.yml</code>或是<code>application.yaml</code>来使用YAML语法编写配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number"><code class="language-hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="整合SpringSecurity依赖"><a href="#整合SpringSecurity依赖" class="headerlink" title="整合SpringSecurity依赖"></a>整合SpringSecurity依赖</h3><p>我们接着来整合一下SpringSecurity依赖，继续感受SpringBoot带来的光速开发体验，只需要导入SpringSecurity的Starter依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>导入依赖后，我们直接启动SpringBoot应用程序，可以发现SpringSecurity已经生效了。</p><p>并且SpringSecurity会自动为我们生成一个默认用户<code>user</code>，它的密码会出现在日志中：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs stylus"><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.329</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardService</span>   : Starting service <span class="hljs-selector-attr">[Tomcat]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.329</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardEngine</span>  : Starting Servlet engine: <span class="hljs-selector-attr">[Apache Tomcat/9.0.56]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.350</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-attr">[Tomcat]</span>.<span class="hljs-selector-attr">[localhost]</span>.<span class="hljs-selector-attr">[/]</span>       : Initializing Spring embedded WebApplicationContext<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.351</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> w<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.ServletWebServerApplicationContext</span> : Root WebApplicationContext: initialization completed <span class="hljs-keyword">in</span> <span class="hljs-number">341</span> ms<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.469</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> <span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.UserDetailsServiceAutoConfiguration</span> : <br><br>Using generated security password: ff24bee3-e1b7-<span class="hljs-number">4309</span>-<span class="hljs-number"><code class="language-hljs stylus"><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.329</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardService</span>   : Starting service <span class="hljs-selector-attr">[Tomcat]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.329</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardEngine</span>  : Starting Servlet engine: <span class="hljs-selector-attr">[Apache Tomcat/9.0.56]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.350</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-attr">[Tomcat]</span>.<span class="hljs-selector-attr">[localhost]</span>.<span class="hljs-selector-attr">[/]</span>       : Initializing Spring embedded WebApplicationContext<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.351</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> w<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.ServletWebServerApplicationContext</span> : Root WebApplicationContext: initialization completed <span class="hljs-keyword">in</span> <span class="hljs-number">341</span> ms<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.469</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> <span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.UserDetailsServiceAutoConfiguration</span> : <br><br>Using generated security password: ff24bee3-e1b7-<span class="hljs-number">4309</span>-<span class="hljs-number">9609</span>-d32618baf5cb<br><br></code></pre></td></tr></table></figure><p>其中<code>ff24bee3-e1b7-4309-9609-d32618baf5cb</code>就是随机生成的一个密码，我们可以使用此用户登录。</p><p>我们也可以在配置文件中直接配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">test</span>   <span class="hljs-comment"># 用户名</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>  <span class="hljs-comment"># 密码</span><br>      <span class="hljs-attr">roles:</span>   <span class="hljs-comment"># 角色</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">user</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string"><code class="language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">test</span>   <span class="hljs-comment"># 用户名</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>  <span class="hljs-comment"># 密码</span><br>      <span class="hljs-attr">roles:</span>   <span class="hljs-comment"># 角色</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">user</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">admin</span><br></code></pre></td></tr></table></figure><p>实际上这样的配置方式就是一个<code>inMemoryAuthentication</code>，只是我们可以直接配置而已。</p><p>当然，页面的控制和数据库验证我们还是需要提供<code>WebSecurityConfigurerAdapter</code>的实现类去完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        http<br>                .authorizeRequests()<br>                .antMatchers(<span class="hljs-string">&quot;/login&quot;</span>).permitAll()<br>                .anyRequest().hasRole(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        http<br>                .authorizeRequests()<br>                .antMatchers(<span class="hljs-string">&quot;/login&quot;</span>).permitAll()<br>                .anyRequest().hasRole(<span class="hljs-string">"user"</span>)<br>                .and()<br>                .formLogin();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里不需要再添加<code>@EnableWebSecurity</code>了，因为starter依赖已经帮我们添加了。</p><p>使用了SpringBoot之后，我们发现，需要什么功能，只需要导入对应的starter依赖即可，甚至都不需要你去进行额外的配置，你只需要关注依赖本身的必要设置即可，大大提高了我们的开发效率。</p><hr><h2 id="整合Mybatis框架"><a href="#整合Mybatis框架" class="headerlink" title="整合Mybatis框架"></a>整合Mybatis框架</h2><p>我们接着来看如何整合Mybatis框架，同样的，我们只需要导入对应的starter依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>导入依赖后，直接启动会报错，是因为有必要的配置我们没有去编写，我们需要指定数据源的相关信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string"><code class="language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>再次启动，成功。</p><p>我们发现日志中会出现这样一句话：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs smali">2022-01-07 12:32:09.106  WARN 6917 --- [           main] o.m.s.mapper.ClassPathMapperScanner     <span class="hljs-keyword"> :</span> No MyBatis mapper was found in &#x27;[com.example]&#x27; package. Please<span class="hljs-built_in"><code class="language-hljs smali">2022-01-07 12:32:09.106  WARN 6917 --- [           main] o.m.s.mapper.ClassPathMapperScanner     <span class="hljs-keyword"> :</span> No MyBatis mapper was found in &#x27;[com.example]&#x27; package. Please<span class="hljs-built_in"> check </span>your configuration.<br></code></pre></td></tr></table></figure><p>这是Mybatis自动扫描输出的语句，导入依赖后，我们不需要再去设置Mybatis的相关Bean了，也不需要添加任何<code>@MapperSacn</code>注解，因为starter已经帮助我们做了，它会自动扫描项目中添加了<code>@Mapper</code>注解的接口，直接将其注册为Bean，不需要进行任何配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MainMapper</span> </span>&#123;<br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)</span><br>    <span class="hljs-function">UserData <span class="hljs-title">findUserByName</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MainMapper</span> </span>&#123;<br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)</span><br>    <span class="hljs-function">UserData <span class="hljs-title">findUserByName</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果你觉得每个接口都去加一个<code>@Mapper</code>比较麻烦的话也可以用回之前的方式，直接<code>@MapperScan</code>使用包扫描。</p><p>添加Mapper之后，使用方法和SSM阶段是一样的，我们可以将其与SpringSecurity结合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    MainMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;<br>        UserData data = mapper.findUserByName(username);<br>        <span class="hljs-keyword">if</span>(data == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;用户 &quot;</span>+username+<span class="hljs-string">&quot; 登录失败，用户名不存在！&quot;</span>);<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    MainMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;<br>        UserData data = mapper.findUserByName(username);<br>        <span class="hljs-keyword">if</span>(data == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;用户 &quot;</span>+username+<span class="hljs-string">&quot; 登录失败，用户名不存在！&quot;</span>);<br>        <span class="hljs-keyword">return</span> User<br>                .withUsername(data.getUsername())<br>                .password(data.getPassword())<br>                .roles(data.getRole())<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后配置一下自定义验证即可，注意这样之前配置文件里面配置的用户就失效了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    auth<br>            .userDetailsService(service)<br>            .passwordEncoder(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    auth<br>            .userDetailsService(service)<br>            .passwordEncoder(<span class="hljs-keyword">new</span> BCryptPasswordEncoder());<br>&#125;<br></code></pre></td></tr></table></figure><p>在首次使用时，我们发现日志中输出以以下语句：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs subunit">2022<span class="hljs-string">-01</span><span class="hljs-string">-07</span> 12:39:40.559  INFO 6930 --- [nio<span class="hljs-string">-8080</span>-exec<span class="hljs-string">-3</span>] com.zaxxer.hikari.HikariDataSource       : HikariPool<span class="hljs-string">-1</span> - Starting...<br>2022<span class="hljs-string">-01</span><span class="hljs-string">-07</span> 12:39:41.033  INFO 6930 --- [nio<span class="hljs-string">-8080</span>-exec<span class="hljs-string">-3</span>] com.zaxxer.hikari.HikariDataSource       : HikariPool<span class="hljs-string"><code class="language-hljs subunit">2022<span class="hljs-string">-01</span><span class="hljs-string">-07</span> 12:39:40.559  INFO 6930 --- [nio<span class="hljs-string">-8080</span>-exec<span class="hljs-string">-3</span>] com.zaxxer.hikari.HikariDataSource       : HikariPool<span class="hljs-string">-1</span> - Starting...<br>2022<span class="hljs-string">-01</span><span class="hljs-string">-07</span> 12:39:41.033  INFO 6930 --- [nio<span class="hljs-string">-8080</span>-exec<span class="hljs-string">-3</span>] com.zaxxer.hikari.HikariDataSource       : HikariPool<span class="hljs-string">-1</span> - Start completed.<br></code></pre></td></tr></table></figure><p>实际上，SpringBoot会自动为Mybatis配置数据源，默认使用的就是<code>HikariCP</code>数据源。</p><hr><h2 id="整合Thymeleaf框架"><a href="#整合Thymeleaf框架" class="headerlink" title="整合Thymeleaf框架"></a>整合Thymeleaf框架</h2><p>整合Thymeleaf也只需导入对应的starter即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>接着我们只需要直接使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是注意，这样只能正常解析HTML页面，但是js、css等静态资源我们需要进行路径指定，不然无法访问，我们在配文件中配置一下静态资源的访问前缀：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">mvc:</span><br>  <span class="hljs-attr">static-path-pattern:</span> <span class="hljs-string"><code class="language-hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">mvc:</span><br>  <span class="hljs-attr">static-path-pattern:</span> <span class="hljs-string">/static/**</span><br></code></pre></td></tr></table></figure><p>接着我们像之前一样，把登陆页面实现一下吧。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">http://www.thymeleaf.org</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:sec</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">http://www.thymeleaf.org</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:sec</span>=<span class="hljs-string">http://www.thymeleaf.org/extras/spring-security</span>></span><br></code></pre></td></tr></table></figure><hr><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>SpringBoot为我们提供了丰富的日志系统，它几乎是开箱即用的。</p><h3 id="日志门面和日志实现"><a href="#日志门面和日志实现" class="headerlink" title="日志门面和日志实现"></a>日志门面和日志实现</h3><p>我们首先要区分一下，什么是日志门面（Facade）什么是日志实现，我们之前学习的JUL实际上就是一种日志实现，我们可以直接使用JUL为我们提供的日志框架来规范化打印日志，而日志门面，如Slf4j，是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于它只是一个接口，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要通过接口绑定的具体的日志系统来实现，这些具体的日志系统就有log4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。</p><p>日志门面和日志实现就像JDBC和数据库驱动一样，一个是画大饼的，一个是真的去做饼的。</p><p><img src="https://upload-images.jianshu.io/upload_images/2909474-b5127a18b3eda3ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/888" alt="img"></p><p>但是现在有一个问题就是，不同的框架可能使用了不同的日志框架，如果这个时候出现众多日志框架并存的情况，我们现在希望的是所有的框架一律使用日志门面（Slf4j）进行日志打印，这时该怎么去解决？我们不可能将其他框架依赖的日志框架替换掉，直接更换为Slf4j吧，这样显然不现实。</p><p>这时，可以采取类似于偷梁换柱的做法，只保留不同日志框架的接口和类定义等关键信息，而将实现全部定向为Slf4j调用。相当于有着和原有日志框架一样的外壳，对于其他框架来说依然可以使用对应的类进行操作，而具体如何执行，真正的内心已经是Slf4j的了。</p><p><img src="https://upload-images.jianshu.io/upload_images/2909474-512f5cca92e05e59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/928" alt="img"></p><p>所以，SpringBoot为了统一日志框架的使用，做了这些事情：</p><ul><li>直接将其他依赖以前的日志框架剔除</li><li>导入对应日志框架的Slf4j中间包</li><li>导入自己官方指定的日志实现，并作为Slf4j的日志实现层</li></ul><h3 id="在SpringBoot中打印日志信息"><a href="#在SpringBoot中打印日志信息" class="headerlink" title="在SpringBoot中打印日志信息"></a>在SpringBoot中打印日志信息</h3><p>SpringBoot使用的是Slf4j作为日志门面，Logback（<a href="http://logback.qos.ch/">Logback</a> 是log4j 框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J）作为日志实现，对应的依赖为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>此依赖已经被包含了，所以我们如果需要打印日志，可以像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;<br>    Logger logger = LoggerFactory.getLogger(MainController.class);<br>    logger.info(<span class="hljs-string">&quot;用户访问了一次登陆界面&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;<br>    Logger logger = LoggerFactory.getLogger(MainController.class);<br>    logger.info(<span class="hljs-string">&quot;用户访问了一次登陆界面&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们使用了Lombok，所以直接一个注解也可以搞定哦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;用户访问了一次登陆界面&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;用户访问了一次登陆界面&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，SpringBoot默认只会打印INFO以上级别的信息。</p><h3 id="配置Logback日志"><a href="#配置Logback日志" class="headerlink" title="配置Logback日志"></a>配置Logback日志</h3><p>Logback官网：<a href="https://logback.qos.ch/">https://logback.qos.ch</a></p><p>和JUL一样，Logback也能实现定制化，我们可以编写对应的配置文件，SpringBoot推荐将配置文件名称命名为<code>logback-spring.xml</code>表示这是SpringBoot下Logback专用的配置，可以使用SpringBoot 的高级Proﬁle功能，它的内容类似于这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>></span><br></code></pre></td></tr></table></figure><p>最外层由<code>configuration</code>包裹，一旦编写，那么就会替换默认的配置，所以如果内部什么都不写的话，那么会导致我们的SpringBoot项目没有配置任何日志输出方式，控制台也不会打印日志。</p><p>我们接着来看如何配置一个控制台日志打印，我们可以直接导入并使用SpringBoot为我们预设好的日志格式，在<code>org/springframework/boot/logging/logback/defaults.xml</code>中已经帮我们把日志的输出格式定义好了，我们只需要设置对应的<code>appender</code>即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">included</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;clr&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ColorConverter&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wex&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wEx&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;</span> /&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE_LOG_PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE_LOG_CHARSET&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;CONSOLE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; : %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_CHARSET&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.catalina.startup.DigesterFactory&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.catalina.util.LifecycleBase&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.sshd.common.util.SecurityUtils&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.net.NioSelectorPool&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.hibernate.validator.internal.util.Version&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.boot.actuate.endpoint.jmx&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">included</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;clr&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ColorConverter&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wex&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wEx&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;</span> /&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE_LOG_PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE_LOG_CHARSET&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;CONSOLE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; : %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_CHARSET&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.catalina.startup.DigesterFactory&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.catalina.util.LifecycleBase&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.sshd.common.util.SecurityUtils&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.net.NioSelectorPool&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.hibernate.validator.internal.util.Version&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.boot.actuate.endpoint.jmx&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">included</span>></span><br></code></pre></td></tr></table></figure><p>导入后，我们利用预设的日志格式创建一个控制台日志打印：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  导入其他配置文件，作为预设  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  Appender作为日志打印器配置，这里命名随意  --&gt;</span><br>    <span class="hljs-comment">&lt;!--  ch.qos.logback.core.ConsoleAppender是专用于控制台的Appender  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;CONSOLE_LOG_CHARSET&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  导入其他配置文件，作为预设  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  Appender作为日志打印器配置，这里命名随意  --&gt;</span><br>    <span class="hljs-comment">&lt;!--  ch.qos.logback.core.ConsoleAppender是专用于控制台的Appender  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;CONSOLE_LOG_CHARSET&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>></span><br></code></pre></td></tr></table></figure><p>配置完成后，我们发现控制台已经可以正常打印日志信息了。</p><p>接着我们来看看如何开启文件打印，我们只需要配置一个对应的Appender即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-comment">&lt;!--  ch.qos.logback.core.rolling.RollingFileAppender用于文件日志记录，它支持滚动  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;FILE_LOG_CHARSET&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  自定义滚动策略，防止日志文件无限变大，也就是日志文件写到什么时候为止，重新创建一个新的日志文件开始写  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  文件保存位置以及文件命名规则，这里用到了%d&#123;yyyy-MM-dd&#125;表示当前日期，%i表示这一天的第N个日志  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>log/%d&#123;yyyy-MM-dd&#125;-spring-%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  到期自动清理日志文件  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  最大日志保留时间  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  最大单个日志文件大小  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>10MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-comment">&lt;!--  ch.qos.logback.core.rolling.RollingFileAppender用于文件日志记录，它支持滚动  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;FILE_LOG_CHARSET&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  自定义滚动策略，防止日志文件无限变大，也就是日志文件写到什么时候为止，重新创建一个新的日志文件开始写  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  文件保存位置以及文件命名规则，这里用到了%d&#123;yyyy-MM-dd&#125;表示当前日期，%i表示这一天的第N个日志  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>log/%d&#123;yyyy-MM-dd&#125;-spring-%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  到期自动清理日志文件  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  最大日志保留时间  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  最大单个日志文件大小  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>10MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>></span><br></code></pre></td></tr></table></figure><p>配置完成后，我们可以看到日志文件也能自动生成了。</p><p>我们也可以魔改官方提供的日志格式，官方文档：<a href="https://logback.qos.ch/manual/layouts.html">https://logback.qos.ch/manual/layouts.html</a></p><p>这里需要提及的是MDC机制，Logback内置的日志字段还是比较少，如果我们需要打印有关业务的更多的内容，包括自定义的一些数据，需要借助logback MDC机制，MDC为“Mapped Diagnostic Context”（映射诊断上下文），即将一些运行时的上下文数据通过logback打印出来；此时我们需要借助org.sl4j.MDC类。</p><p>比如我们现在需要记录是哪个用户访问我们网站的日志，只要是此用户访问我们网站，都会在日志中携带该用户的ID，我们希望每条日志中都携带这样一段信息文本，而官方提供的字段无法实现此功能，这时就需要使用MDC机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//这里就用Session代替ID吧</span><br>        MDC.put(<span class="hljs-string">&quot;reqId&quot;</span>, request.getSession().getId());<br>        log.info(<span class="hljs-string">&quot;用户访问了一次登陆界面&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//这里就用Session代替ID吧</span><br>        MDC.put(<span class="hljs-string">&quot;reqId&quot;</span>, request.getSession().getId());<br>        log.info(<span class="hljs-string">&quot;用户访问了一次登陆界面&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，我们就可以向日志中传入自定义参数了，我们日志中添加这样一个占位符<code>%X&#123;键值&#125;</code>，名字保持一致：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><code class="language-hljs xml">%clr([%X&#123;reqId&#125;])&#123;faint&#125; <br></code></pre></td></tr></table></figure><p>这样当我们向MDC中添加信息后，只要是当前线程（本质是ThreadLocal实现）下输出的日志，都会自动替换占位符。</p><h3 id="自定义Banner"><a href="#自定义Banner" class="headerlink" title="自定义Banner"></a>自定义Banner</h3><p>我们在之前发现，实际上Banner部分和日志部分是独立的，SpringBoot启动后，会先打印Banner部分，那么这个Banner部分是否可以自定义呢？答案是可以的。</p><p>我们可以直接来配置文件所在目录下创建一个名为<code>banner.txt</code>的文本文档，内容随便你：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs txt"><code class="language-hljs txt">//                          _ooOoo_                               //<br>//                         o8888888o                              //<br>//                         88" . "88                              //<br>//                         (| ^_^ |)                              //<br>//                         O\  =  /O                              //<br>//                      ____/`---&#x27;\____                           //<br>//                    .&#x27;  \\|     |//  `.                         //<br>//                   /  \\|||  :  |||//  \                        //<br>//                  /  _||||| -:- |||||-  \                       //<br>//                  |   | \\\  -  /// |   |                       //<br>//                  | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |                       //<br>//                  \  .-\__  `-`  ___/-. /                       //<br>//                ___`. .&#x27;  /--.--\  `. . ___                     //<br>//              ."" &#x27;<  `.___\_<|>_/___.&#x27;  >&#x27;"".                  //<br>//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //<br>//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //<br>//      ========`-.____`-.___\_____/___.-`____.-&#x27;========         //<br>//                           `=---=&#x27;                              //<br>//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //<br>//             佛祖保佑          永无BUG         永不修改             //<br></code></pre></td></tr></table></figure><p>可以使用在线生成网站进行生成自己的个性Banner：<a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a></p><p>我们甚至还可以使用颜色代码来为文本切换颜色：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs awk"><span class="hljs-variable">$&#123;AnsiColor.BRIGHT_GREEN&#125;</span>  <span class="hljs-regexp"><code class="language-hljs awk"><span class="hljs-variable">$&#123;AnsiColor.BRIGHT_GREEN&#125;</span>  <span class="hljs-regexp">//</span>绿色<br></code></pre></td></tr></table></figure><p>也可以获取一些常用的变量信息：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs stata"><span class="hljs-variable">$&#123;AnsiColor</span>.YELLOW&#125; 当前 Spring <span class="hljs-keyword">Boot</span> 版本：<span class="hljs-variable">$&#123;spring</span>-<span class="hljs-keyword">boot</span>.<span class="hljs-keyword"><code class="language-hljs stata"><span class="hljs-variable">$&#123;AnsiColor</span>.YELLOW&#125; 当前 Spring <span class="hljs-keyword">Boot</span> 版本：<span class="hljs-variable">$&#123;spring</span>-<span class="hljs-keyword">boot</span>.<span class="hljs-keyword">version</span>&#125;<br></code></pre></td></tr></table></figure><p>玩的开心！</p><hr><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p>在日常开发中，我们项目会有多个环境。例如开发环境（develop）也就是我们研发过程中疯狂敲代码修BUG阶段，生产环境（production ）项目开发得差不多了，可以放在服务器上跑了。不同的环境下，可能我们的配置文件也存在不同，但是我们不可能切换环境的时候又去重新写一次配置文件，所以我们可以将多个环境的配置文件提前写好，进行自由切换。</p><p>由于SpringBoot只会读取<code>application.properties</code>或是<code>application.yml</code>文件，那么怎么才能实现自由切换呢？SpringBoot给我们提供了一种方式，我们可以通过配置文件指定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string"><code class="language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>接着我们分别创建两个环境的配置文件，<code>application-dev.yml</code>和<code>application-prod.yml</code>分别表示开发环境和生产环境的配置文件，比如开发环境我们使用的服务器端口为8080，而生产环境下可能就需要设置为80或是443端口，那么这个时候就需要不同环境下的配置文件进行区分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number"><code class="language-hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number"><code class="language-hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>这样我们就可以灵活切换生产环境和开发环境下的配置文件了。</p><p>SpringBoot自带的Logback日志系统也是支持多环境配置的，比如我们想在开发环境下输出日志到控制台，而生产环境下只需要输出到文件即可，这时就需要进行环境配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>></span><br></code></pre></td></tr></table></figure><p>注意<code>springProfile</code>是区分大小写的！</p><p>那如果我们希望生产环境中不要打包开发环境下的配置文件呢，我们目前虽然可以切换开发环境，但是打包的时候依然是所有配置文件全部打包，这样总感觉还欠缺一点完美，因此，打包的问题就只能找Maven解决了，Maven也可以设置多环境：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-comment">&lt;!--分别设置开发，生产环境--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开发环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 生产环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-comment">&lt;!--分别设置开发，生产环境--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开发环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 生产环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>></span><br></code></pre></td></tr></table></figure><p>接着，我们需要根据环境的不同，排除其他环境的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-comment">&lt;!--排除配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--先排除所有的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--使用通配符，当然可以定义多个exclude标签进行排除--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>application*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据激活条件引入打包所需的配置和文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--引入所需环境的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--根据maven选择环境导入配置文件--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application-$&#123;environment&#125;.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-comment">&lt;!--排除配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--先排除所有的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--使用通配符，当然可以定义多个exclude标签进行排除--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>application*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据激活条件引入打包所需的配置和文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--引入所需环境的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--根据maven选择环境导入配置文件--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application-$&#123;environment&#125;.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>></span><br></code></pre></td></tr></table></figure><p>接着，我们可以直接将Maven中的<code>environment</code>属性，传递给SpringBoot的配置文件，在构建时替换为对应的值：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">&#x27;@environment@&#x27;</span>  <span class="hljs-comment"><code class="language-hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">&#x27;@environment@&#x27;</span>  <span class="hljs-comment">#注意YAML配置文件需要加单引号，否则会报错</span><br></code></pre></td></tr></table></figure><p>这样，根据我们Maven环境的切换，SpringBoot的配置文件也会进行对应的切换。</p><p>最后我们打开Maven栏目，就可以自由切换了，直接勾选即可，注意切换环境之后要重新加载一下Maven项目，不然不会生效！</p><hr><h2 id="打包运行"><a href="#打包运行" class="headerlink" title="打包运行"></a>打包运行</h2><p>现在我们的SpringBoot项目编写完成了，那么如何打包运行呢？非常简单，只需要点击Maven生命周期中的<code>package</code>即可，它会自动将其打包为可直接运行的Jar包，第一次打包可能会花费一些时间下载部分依赖的源码一起打包进Jar文件。</p><p>我们发现在打包的过程中还会完整的将项目跑一遍进行测试，如果我们不想测试直接打包，可以手动使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">mvn package  -DskipTests<br></code></pre></td></tr></table></figure><p>打包后，我们会直接得到一个名为<code>springboot-study-0.0.1-SNAPSHOT.jar</code>的文件，这时在CMD窗口中输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">java -jar springboot-study-0.0.1-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p>输入后，可以看到我们的Java项目成功运行起来了，如果手动关闭窗口会导致整个项目终止运行。</p><hr><h2 id="再谈Spring框架"><a href="#再谈Spring框架" class="headerlink" title="再谈Spring框架"></a>再谈Spring框架</h2><p><strong>注意：</strong>开始本部分前，建议先完成SSM阶段的Spring源码讲解部分。</p><p>我们在SpringBoot阶段，需要继续扩充Spring框架的相关知识，来巩固和强化对于Spring框架的认识。</p><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>为了执行某些任务，我们可能需要一些非常规的操作，比如我们希望使用多线程来处理我们的结果或是执行一些定时任务，到达指定时间再去执行。</p><p>这时我们首先想到的就是创建一个新的线程来处理，或是使用TimerTask来完成定时任务，但是我们有了Spring框架之后，就不用这样了，因为Spring框架为我们提供了更加便捷的方式进行任务调度。</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>需要使用Spring异步任务支持，我们需要在配置类上添加<code>@EnableAsync</code>或是在SpringBoot的启动类上添加也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootWebTestApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootWebTestApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringBootWebTestApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们只需要在需要异步执行的方法上，添加<code>@Async</code>注解即可将此方法标记为异步，当此方法被调用时，会异步执行，也就是新开一个线程执行，不是在当前线程执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            System.out.println(<span class="hljs-string">&quot;我是异步任务！&quot;</span>);<br>        &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            System.out.println(<span class="hljs-string">&quot;我是异步任务！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>    service.test();<br>    System.out.println(<span class="hljs-string">&quot;我是同步任务！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>    service.test();<br>    System.out.println(<span class="hljs-string">&quot;我是同步任务！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这也是得益于AOP机制，通过线程池实现，但是也要注意，正是因为它是AOP机制的产物，所以它只能是在Bean中才会生效！</p><p>使用 @Async 注释的方法可以返回 ‘void’ 或 “Future” 类型，Future是一种用于接收任务执行结果的一种类型，我们会在Java并发编程中进行讲解，这里暂时不做介绍。</p><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>看完了异步任务，我们接着来看定时任务，定时任务其实就是指定在哪个时候再去执行，在JavaSE阶段我们使用过TimerTask来执行定时任务。</p><p>Spring中的定时任务是全局性质的，当我们的Spring程序启动后，那么定时任务也就跟着启动了，我们可以在配置类上添加<code>@EnableScheduling</code>或是在SpringBoot的启动类上添加也可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootWebTestApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootWebTestApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringBootWebTestApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们可以创建一个定时任务配置类，在配置类里面编写定时任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Scheduled(fixedRate = 2000)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是定时任务！&quot;</span>+<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Scheduled(fixedRate = 2000)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是定时任务！&quot;</span>+<span class="hljs-keyword">new</span> Date());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们注意到<code> @Scheduled</code>中有很多参数，我们需要指定’cron’, ‘fixedDelay(String)’, or ‘fixedRate(String)’的其中一个，否则无法创建定时任务，他们的区别如下：</p><ul><li>fixedDelay：在上一次定时任务执行完之后，间隔多久继续执行。</li><li>fixedRate：无论上一次定时任务有没有执行完成，两次任务之间的时间间隔。</li><li>cron：使用cron表达式来指定任务计划。</li></ul><p>这里重点讲解一下cron表达式：<a href="https://blog.csdn.net/sunnyzyq/article/details/98597252">https://blog.csdn.net/sunnyzyq/article/details/98597252</a></p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>监听器对我们来说也是一个比较陌生的概念，那么何谓监听呢？</p><p>监听实际上就是等待某个事件的触发，当事件触发时，对应事件的监听器就会被通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ContextRefreshedEvent</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ContextRefreshedEvent</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;<br>        System.out.println(event.getApplicationContext());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过监听事件，我们就可以在对应的时机进行一些额外的处理，我们可以通过断点调试来查看一个事件是如何发生，以及如何通知监听器的。</p><p>通过阅读源码，我们得知，一个事件实际上就是通过<code>publishEvent</code>方法来进行发布的，我们也可以自定义我们自己项目中的事件，并注册对应的监听器进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> </span>&#123;   <span class="hljs-comment">//需要继承ApplicationEvent</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestEvent</span><span class="hljs-params">(Object source)</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> </span>&#123;   <span class="hljs-comment">//需要继承ApplicationEvent</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestEvent</span><span class="hljs-params">(Object source)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">TestEvent</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(TestEvent event)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">TestEvent</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(TestEvent event)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"自定义事件发生了："</span>+event.getSource());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Resource</span><br>ApplicationContext context;<br><br><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>    context.publishEvent(<span class="hljs-keyword">new</span> TestEvent(<span class="hljs-string">&quot;有人访问了登录界面！&quot;</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Resource</span><br>ApplicationContext context;<br><br><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>    context.publishEvent(<span class="hljs-keyword">new</span> TestEvent(<span class="hljs-string">&quot;有人访问了登录界面！&quot;</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就实现了自定义事件发布和监听。</p><h3 id="Aware系列接口"><a href="#Aware系列接口" class="headerlink" title="Aware系列接口"></a>Aware系列接口</h3><p>我们在之前讲解Spring源码时，经常会发现某些类的定义上，除了我们当时讲解的继承关系以外，还实现了一些接口，他们的名称基本都是<code>xxxxAware</code>，比如我们在讲解SpringSecurity的源码中，AbstractAuthenticationProcessingFilter类就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationEventPublisherAware</span>, <span class="hljs-title">MessageSourceAware</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> ApplicationEventPublisher eventPublisher;<br>    <span class="hljs-keyword">protected</span> AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource = <span class="hljs-keyword">new</span> WebAuthenticationDetailsSource();<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationEventPublisherAware</span>, <span class="hljs-title">MessageSourceAware</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> ApplicationEventPublisher eventPublisher;<br>    <span class="hljs-keyword">protected</span> AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource = <span class="hljs-keyword">new</span> WebAuthenticationDetailsSource();<br>    <span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;<br>    ...<br></code></pre></td></tr></table></figure><p>我们发现它除了继承自GenericFilterBean之外，还实现了ApplicationEventPublisherAware和MessageSourceAware接口，那么这些Aware接口到底是干嘛的呢？</p><p>Aware的中文意思为<strong>感知</strong>。简单来说，他就是一个标识，实现此接口的类会获得某些感知能力，Spring容器会在Bean被加载时，根据类实现的感知接口，会调用类中实现的对应感知方法。</p><p>比如AbstractAuthenticationProcessingFilter就实现了ApplicationEventPublisherAware接口，此接口的感知功能为事件发布器，在Bean加载时，会调用实现类中的<code>setApplicationEventPublisher</code>方法，而AbstractAuthenticationProcessingFilter类则利用此方法，在Bean加载阶段获得了容器的事件发布器，以便之后发布事件使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher eventPublisher)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.eventPublisher = eventPublisher;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher eventPublisher)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.eventPublisher = eventPublisher;   <span class="hljs-comment">//直接存到成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>    SecurityContext context = SecurityContextHolder.createEmptyContext();<br>    context.setAuthentication(authResult);<br>    SecurityContextHolder.setContext(context);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;<br>        <span class="hljs-keyword">this</span>.logger.debug(LogMessage.format(<span class="hljs-string">&quot;Set SecurityContextHolder to %s&quot;</span>, authResult));<br>    &#125;<br><br>    <span class="hljs-keyword">this</span>.rememberMeServices.loginSuccess(request, response, authResult);<br>  <span class="hljs-comment">//在这里使用</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.eventPublisher.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(authResult, <span class="hljs-keyword">this</span>.getClass()));<br>    &#125;<br><br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>    SecurityContext context = SecurityContextHolder.createEmptyContext();<br>    context.setAuthentication(authResult);<br>    SecurityContextHolder.setContext(context);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;<br>        <span class="hljs-keyword">this</span>.logger.debug(LogMessage.format(<span class="hljs-string">&quot;Set SecurityContextHolder to %s&quot;</span>, authResult));<br>    &#125;<br><br>    <span class="hljs-keyword">this</span>.rememberMeServices.loginSuccess(request, response, authResult);<br>  <span class="hljs-comment">//在这里使用</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.eventPublisher.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(authResult, <span class="hljs-keyword">this</span>.getClass()));<br>    &#125;<br><br>    <span class="hljs-keyword">this</span>.successHandler.onAuthenticationSuccess(request, response, authResult);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，除了ApplicationEventPublisherAware接口外，我们再来演示一个接口，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanNameAware</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanNameAware</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BeanNameAware就是感知Bean名称的一个接口，当Bean被加载时，会调用<code>setBeanName</code>方法并将Bean名称作为参数传递。</p><p>有关所有的Aware这里就不一一列举了。</p><hr><h2 id="探究SpringBoot实现原理"><a href="#探究SpringBoot实现原理" class="headerlink" title="探究SpringBoot实现原理"></a>探究SpringBoot实现原理</h2><p><strong>注意：</strong>难度较大，本版块作为选学内容，在开始前，必须完成SSM阶段源码解析部分的学习。</p><p>我们在前面的学习中切实感受到了SpringBoot为我们带来的便捷，那么它为何能够实现如此快捷的开发模式，starter又是一个怎样的存在，它是如何进行自动配置的，我们现在就开始研究。</p><h3 id="启动原理"><a href="#启动原理" class="headerlink" title="启动原理"></a>启动原理</h3><p>首先我们来看看，SpringBoot项目启动之后，做了什么事情，SpringApplication中的静态<code>run</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> run(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> Class[]&#123;primarySource&#125;, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>套娃如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> SpringApplication(primarySources)).run(args);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，这里直接new了一个新的SpringApplication对象，传入我们的主类作为构造方法参数，并调用了非static的<code>run</code>方法，我们先来看看构造方法里面做了什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;<br>    Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>    <span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));<br>  <span class="hljs-comment">//这里是关键，这里会判断当前SpringBoot应用程序是否为Web项目，并返回当前的项目类型</span><br>  <span class="hljs-comment">//deduceFromClasspath是根据类路径下判断是否包含SpringBootWeb依赖，如果不包含就是NONE类型，包含就是SERVLET类型</span><br>    <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>    <span class="hljs-keyword">this</span>.bootstrapRegistryInitializers = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));<br>  <span class="hljs-comment">//创建所有ApplicationContextInitializer实现类的对象</span><br>    <span class="hljs-keyword">this</span>.setInitializers(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>    <span class="hljs-keyword">this</span>.setListeners(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));<br>    <span class="hljs-keyword">this</span>.mainApplicationClass = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;<br>    Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>    <span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));<br>  <span class="hljs-comment">//这里是关键，这里会判断当前SpringBoot应用程序是否为Web项目，并返回当前的项目类型</span><br>  <span class="hljs-comment">//deduceFromClasspath是根据类路径下判断是否包含SpringBootWeb依赖，如果不包含就是NONE类型，包含就是SERVLET类型</span><br>    <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>    <span class="hljs-keyword">this</span>.bootstrapRegistryInitializers = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));<br>  <span class="hljs-comment">//创建所有ApplicationContextInitializer实现类的对象</span><br>    <span class="hljs-keyword">this</span>.setInitializers(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>    <span class="hljs-keyword">this</span>.setListeners(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));<br>    <span class="hljs-keyword">this</span>.mainApplicationClass = <span class="hljs-keyword">this</span>.deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>关键就在这里了，它是如何知道哪些类是ApplicationContextInitializer的实现类的呢？</p><p>这里就要提到spring.factories了，它是 Spring 仿造Java SPI实现的一种类加载机制。它在 META-INF/spring.factories 文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是 Spring Boot Starter 实现的基础。</p><p>SPI的常见例子：</p><ul><li>数据库驱动加载接口实现类的加载：JDBC加载不同类型数据库的驱动</li><li>日志门面接口实现类加载：SLF4J加载不同提供商的日志实现类</li></ul><p>说白了就是人家定义接口，但是实现可能有很多种，但是核心只提供接口，需要我们按需选择对应的实现，这种方式是高度解耦的。</p><p>我们来看看<code>getSpringFactoriesInstances</code>方法做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;<br>  <span class="hljs-comment">//获取当前的类加载器</span><br>    ClassLoader classLoader = <span class="hljs-keyword">this</span>.getClassLoader();<br>  <span class="hljs-comment">//获取所有依赖中 META-INF/spring.factories 中配置的对应接口类的实现类列表</span><br>    Set&lt;String&gt; names = <span class="hljs-keyword">new</span> LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>  <span class="hljs-comment">//根据上方列表，依次创建实例对象  </span><br>  List&lt;T&gt; instances = <span class="hljs-keyword">this</span>.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);<br>  <span class="hljs-comment">//根据对应类上的Order接口或是注解进行排序</span><br>    AnnotationAwareOrderComparator.sort(instances);<br>  <span class="hljs-comment">//返回实例</span><br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;<br>  <span class="hljs-comment">//获取当前的类加载器</span><br>    ClassLoader classLoader = <span class="hljs-keyword">this</span>.getClassLoader();<br>  <span class="hljs-comment">//获取所有依赖中 META-INF/spring.factories 中配置的对应接口类的实现类列表</span><br>    Set&lt;String&gt; names = <span class="hljs-keyword">new</span> LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>  <span class="hljs-comment">//根据上方列表，依次创建实例对象  </span><br>  List&lt;T&gt; instances = <span class="hljs-keyword">this</span>.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);<br>  <span class="hljs-comment">//根据对应类上的Order接口或是注解进行排序</span><br>    AnnotationAwareOrderComparator.sort(instances);<br>  <span class="hljs-comment">//返回实例</span><br>    <span class="hljs-keyword">return</span> instances;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>SpringFactoriesLoader.loadFactoryNames</code>正是读取配置的核心部分，我们后面还会遇到。</p><p>接着我们来看run方法里面做了什么事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> startTime = System.nanoTime();<br>    DefaultBootstrapContext bootstrapContext = <span class="hljs-keyword">this</span>.createBootstrapContext();<br>    ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">this</span>.configureHeadlessProperty();<br>  <span class="hljs-comment">//获取所有的SpringApplicationRunListener，并通知启动事件，默认只有一个实现类EventPublishingRunListener</span><br>  <span class="hljs-comment">//EventPublishingRunListener会将初始化各个阶段的事件转发给所有监听器</span><br>    SpringApplicationRunListeners listeners = <span class="hljs-keyword">this</span>.getRunListeners(args);<br>    listeners.starting(bootstrapContext, <span class="hljs-keyword">this</span>.mainApplicationClass);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//环境配置</span><br>        ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);<br>        ConfigurableEnvironment environment = <span class="hljs-keyword">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>        <span class="hljs-keyword">this</span>.configureIgnoreBeanInfo(environment);<br>      <span class="hljs-comment">//打印Banner</span><br>        Banner printedBanner = <span class="hljs-keyword">this</span>.printBanner(environment);<br>      <span class="hljs-comment">//创建ApplicationContext，注意这里会根据是否为Web容器使用不同的ApplicationContext实现类</span><br>        context = <span class="hljs-keyword">this</span>.createApplicationContext();<br>        context.setApplicationStartup(<span class="hljs-keyword">this</span>.applicationStartup);<br>      <span class="hljs-comment">//初始化ApplicationContext</span><br>        <span class="hljs-keyword">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>      <span class="hljs-comment">//执行ApplicationContext的refresh方法</span><br>        <span class="hljs-keyword">this</span>.refreshContext(context);<br>        <span class="hljs-keyword">this</span>.afterRefresh(context, applicationArguments);<br>        Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>            (<span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass)).logStarted(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> startTime = System.nanoTime();<br>    DefaultBootstrapContext bootstrapContext = <span class="hljs-keyword">this</span>.createBootstrapContext();<br>    ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">this</span>.configureHeadlessProperty();<br>  <span class="hljs-comment">//获取所有的SpringApplicationRunListener，并通知启动事件，默认只有一个实现类EventPublishingRunListener</span><br>  <span class="hljs-comment">//EventPublishingRunListener会将初始化各个阶段的事件转发给所有监听器</span><br>    SpringApplicationRunListeners listeners = <span class="hljs-keyword">this</span>.getRunListeners(args);<br>    listeners.starting(bootstrapContext, <span class="hljs-keyword">this</span>.mainApplicationClass);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//环境配置</span><br>        ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);<br>        ConfigurableEnvironment environment = <span class="hljs-keyword">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>        <span class="hljs-keyword">this</span>.configureIgnoreBeanInfo(environment);<br>      <span class="hljs-comment">//打印Banner</span><br>        Banner printedBanner = <span class="hljs-keyword">this</span>.printBanner(environment);<br>      <span class="hljs-comment">//创建ApplicationContext，注意这里会根据是否为Web容器使用不同的ApplicationContext实现类</span><br>        context = <span class="hljs-keyword">this</span>.createApplicationContext();<br>        context.setApplicationStartup(<span class="hljs-keyword">this</span>.applicationStartup);<br>      <span class="hljs-comment">//初始化ApplicationContext</span><br>        <span class="hljs-keyword">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>      <span class="hljs-comment">//执行ApplicationContext的refresh方法</span><br>        <span class="hljs-keyword">this</span>.refreshContext(context);<br>        <span class="hljs-keyword">this</span>.afterRefresh(context, applicationArguments);<br>        Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>            (<span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass)).logStarted(<span class="hljs-keyword">this</span>.getApplicationLog(), timeTakenToStartup);<br>        &#125;<br>        ....<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，实际上SpringBoot就是Spring的一层壳罢了，离不开最关键的ApplicationContext，也就是说，在启动后会自动配置一个ApplicationContext，只不过是进行了大量的扩展。</p><p>我们来看ApplicationContext是怎么来的，打开<code>createApplicationContext</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title">createApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.applicationContextFactory.create(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title">createApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.applicationContextFactory.create(<span class="hljs-keyword">this</span>.webApplicationType);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现在构造方法中<code>applicationContextFactory</code>直接使用的是DEFAULT：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">this</span>.applicationContextFactory = ApplicationContextFactory.DEFAULT;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java">ApplicationContextFactory DEFAULT = (webApplicationType) -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">switch</span>(webApplicationType) &#123;<br>        <span class="hljs-keyword">case</span> SERVLET:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationConfigServletWebServerApplicationContext();<br>        <span class="hljs-keyword">case</span> REACTIVE:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationConfigReactiveWebServerApplicationContext();<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception var2) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Unable create a default ApplicationContext instance, you may need a custom ApplicationContextFactory&quot;</span>, var2);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">ConfigurableApplicationContext <span class="hljs-title">create</span><span class="hljs-params"><code class="language-hljs java">ApplicationContextFactory DEFAULT = (webApplicationType) -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">switch</span>(webApplicationType) &#123;<br>        <span class="hljs-keyword">case</span> SERVLET:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationConfigServletWebServerApplicationContext();<br>        <span class="hljs-keyword">case</span> REACTIVE:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationConfigReactiveWebServerApplicationContext();<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception var2) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Unable create a default ApplicationContext instance, you may need a custom ApplicationContextFactory&quot;</span>, var2);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">ConfigurableApplicationContext <span class="hljs-title">create</span><span class="hljs-params">(WebApplicationType webApplicationType)</span></span>;<br></code></pre></td></tr></table></figure><p>DEFAULT是直接编写的一个匿名内部类，其实已经很明确了，正是根据<code>webApplicationType</code>类型进行判断，如果是SERVLET，那么久返回专用于Web环境的AnnotationConfigServletWebServerApplicationContext对象（SpringBoot中新增的），否则返回普通的AnnotationConfigApplicationContext对象，也就是到这里为止，Spring的容器就基本已经确定了。</p><p>注意AnnotationConfigApplicationContext是Spring框架提供的类，从这里开始相当于我们在讲Spring的底层源码了，我们继续深入，AnnotationConfigApplicationContext对象在创建过程中会创建<code>AnnotatedBeanDefinitionReader</code>，它是用于通过注解解析Bean定义的工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>    StartupStep createAnnotatedBeanDefReader = <span class="hljs-keyword">this</span>.getApplicationStartup().start(<span class="hljs-string">&quot;spring.context.annotated-bean-reader.create&quot;</span>);<br>    <span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> AnnotatedBeanDefinitionReader(<span class="hljs-keyword">this</span>);<br>    createAnnotatedBeanDefReader.end();<br>    <span class="hljs-keyword">this</span>.scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>    StartupStep createAnnotatedBeanDefReader = <span class="hljs-keyword">this</span>.getApplicationStartup().start(<span class="hljs-string">&quot;spring.context.annotated-bean-reader.create&quot;</span>);<br>    <span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> AnnotatedBeanDefinitionReader(<span class="hljs-keyword">this</span>);<br>    createAnnotatedBeanDefReader.end();<br>    <span class="hljs-keyword">this</span>.scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotatedBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">//这里会注册很多的后置处理器</span><br>    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotatedBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">//这里会注册很多的后置处理器</span><br>    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="hljs-keyword">this</span>.registry);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">registerAnnotationConfigProcessors</span><span class="hljs-params">(BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> </span>&#123;<br>    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);<br>    ....<br>    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="hljs-keyword">new</span> LinkedHashSet(<span class="hljs-number">8</span>);<br>    RootBeanDefinition def;<br>    <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(<span class="hljs-string">&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;</span>)) &#123;<br>      <span class="hljs-comment">//注册了ConfigurationClassPostProcessor用于处理@Configuration、@Import等注解</span><br>      <span class="hljs-comment">//注意这里是关键，之后Selector还要讲到它</span><br>      <span class="hljs-comment">//它是继承自BeanDefinitionRegistryPostProcessor，所以它的执行时间在Bean定义加载完成后，Bean初始化之前</span><br>        def = <span class="hljs-keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);<br>        def.setSource(source);<br>        beanDefs.add(registerPostProcessor(registry, def, <span class="hljs-string">&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(<span class="hljs-string">&quot;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&quot;</span>)) &#123;<br>      <span class="hljs-comment">//AutowiredAnnotationBeanPostProcessor用于处理@Value等注解自动注入</span><br>        def = <span class="hljs-keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);<br>        def.setSource(source);<br>        beanDefs.add(registerPostProcessor(registry, def, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">registerAnnotationConfigProcessors</span><span class="hljs-params">(BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> </span>&#123;<br>    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);<br>    ....<br>    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="hljs-keyword">new</span> LinkedHashSet(<span class="hljs-number">8</span>);<br>    RootBeanDefinition def;<br>    <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(<span class="hljs-string">&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;</span>)) &#123;<br>      <span class="hljs-comment">//注册了ConfigurationClassPostProcessor用于处理@Configuration、@Import等注解</span><br>      <span class="hljs-comment">//注意这里是关键，之后Selector还要讲到它</span><br>      <span class="hljs-comment">//它是继承自BeanDefinitionRegistryPostProcessor，所以它的执行时间在Bean定义加载完成后，Bean初始化之前</span><br>        def = <span class="hljs-keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);<br>        def.setSource(source);<br>        beanDefs.add(registerPostProcessor(registry, def, <span class="hljs-string">&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(<span class="hljs-string">&quot;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&quot;</span>)) &#123;<br>      <span class="hljs-comment">//AutowiredAnnotationBeanPostProcessor用于处理@Value等注解自动注入</span><br>        def = <span class="hljs-keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);<br>        def.setSource(source);<br>        beanDefs.add(registerPostProcessor(registry, def, <span class="hljs-string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>));<br>    &#125;<br>  <br>  ...<br></code></pre></td></tr></table></figure><p>回到SpringBoot，我们最后来看，<code>prepareContext</code>方法中又做了什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;<br>  <span class="hljs-comment">//环境配置</span><br>    context.setEnvironment(environment);<br>    <span class="hljs-keyword">this</span>.postProcessApplicationContext(context);<br>    <span class="hljs-keyword">this</span>.applyInitializers(context);<br>    listeners.contextPrepared(context);<br>    bootstrapContext.close(context);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>        <span class="hljs-keyword">this</span>.logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">this</span>.logStartupProfileInfo(context);<br>    &#125;<br><br>  <span class="hljs-comment">//将Banner注册为Bean</span><br>    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();<br>    beanFactory.registerSingleton(<span class="hljs-string">&quot;springApplicationArguments&quot;</span>, applicationArguments);<br>    <span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) &#123;<br>        beanFactory.registerSingleton(<span class="hljs-string">&quot;springBootBanner&quot;</span>, printedBanner);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> AbstractAutowireCapableBeanFactory) &#123;<br>        ((AbstractAutowireCapableBeanFactory)beanFactory).setAllowCircularReferences(<span class="hljs-keyword">this</span>.allowCircularReferences);<br>        <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;<br>            ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lazyInitialization) &#123;<br>        context.addBeanFactoryPostProcessor(<span class="hljs-keyword">new</span> LazyInitializationBeanFactoryPostProcessor());<br>    &#125;<br><br>  <span class="hljs-comment">//这里会获取我们一开始传入的项目主类</span><br>    Set&lt;Object&gt; sources = <span class="hljs-keyword">this</span>.getAllSources();<br>    Assert.notEmpty(sources, <span class="hljs-string">&quot;Sources must not be empty&quot;</span>);<br>  <span class="hljs-comment">//这里会将我们的主类直接注册为Bean，这样就可以通过注解加载了</span><br>    <span class="hljs-keyword">this</span>.load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;<br>  <span class="hljs-comment">//环境配置</span><br>    context.setEnvironment(environment);<br>    <span class="hljs-keyword">this</span>.postProcessApplicationContext(context);<br>    <span class="hljs-keyword">this</span>.applyInitializers(context);<br>    listeners.contextPrepared(context);<br>    bootstrapContext.close(context);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>        <span class="hljs-keyword">this</span>.logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">this</span>.logStartupProfileInfo(context);<br>    &#125;<br><br>  <span class="hljs-comment">//将Banner注册为Bean</span><br>    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();<br>    beanFactory.registerSingleton(<span class="hljs-string">&quot;springApplicationArguments&quot;</span>, applicationArguments);<br>    <span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) &#123;<br>        beanFactory.registerSingleton(<span class="hljs-string">&quot;springBootBanner&quot;</span>, printedBanner);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> AbstractAutowireCapableBeanFactory) &#123;<br>        ((AbstractAutowireCapableBeanFactory)beanFactory).setAllowCircularReferences(<span class="hljs-keyword">this</span>.allowCircularReferences);<br>        <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;<br>            ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lazyInitialization) &#123;<br>        context.addBeanFactoryPostProcessor(<span class="hljs-keyword">new</span> LazyInitializationBeanFactoryPostProcessor());<br>    &#125;<br><br>  <span class="hljs-comment">//这里会获取我们一开始传入的项目主类</span><br>    Set&lt;Object&gt; sources = <span class="hljs-keyword">this</span>.getAllSources();<br>    Assert.notEmpty(sources, <span class="hljs-string">&quot;Sources must not be empty&quot;</span>);<br>  <span class="hljs-comment">//这里会将我们的主类直接注册为Bean，这样就可以通过注解加载了</span><br>    <span class="hljs-keyword">this</span>.load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]));<br>    listeners.contextLoaded(context);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，在<code>prepareContext</code>执行完成之后，我们的主类成功完成Bean注册，接下来，就该类上注解大显身手了。</p><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p>既然主类已经在初始阶段注册为Bean，那么在加载时，就会根据注解定义，进行更多的额外操作。所以我们来看看主类上的<code>@SpringBootApplication</code>注解做了什么事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;@Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="hljs-meta">), @Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;@Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="hljs-meta">), @Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br></code></pre></td></tr></table></figure><p>我们发现，<code>@SpringBootApplication</code>上添加了<code>@ComponentScan</code>注解，此注解我们此前已经认识过了，但是这里并没有配置具体扫描的包，因此它会自动将声明此接口的类所在的包作为basePackage，因此当添加<code>@SpringBootApplication</code>之后也就等于直接开启了自动扫描，但是一定注意不能在主类之外的包进行Bean定义，否则无法扫描到，需要手动配置。</p><p>接着我们来看第二个注解<code>@EnableAutoConfiguration</code>，它就是自动配置的核心了，我们来看看它是如何定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br></code></pre></td></tr></table></figure><p>老套路了，直接一手<code>@Import</code>，通过这种方式来将一些外部的Bean加载到容器中。我们来看看AutoConfigurationImportSelector做了什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DeferredImportSelector</span>, <span class="hljs-title">BeanClassLoaderAware</span>, <span class="hljs-title">ResourceLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">EnvironmentAware</span>, <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DeferredImportSelector</span>, <span class="hljs-title">BeanClassLoaderAware</span>, <span class="hljs-title">ResourceLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">EnvironmentAware</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到它实现了很多接口，包括大量的Aware接口，实际上就是为了感知某些必要的对象，并将其存到当前类中。</p><p>其中最核心的是<code>DeferredImportSelector</code>接口，它是<code>ImportSelector</code>的子类，它定义了<code>selectImports</code>方法，用于返回需要加载的类名称，在Spring加载ImportSelector类型的Bean时，会调用此方法来获取更多需要加载的类，并将这些类一并注册为Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    String[] selectImports(AnnotationMetadata importingClassMetadata);<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;String&gt; <span class="hljs-title">getExclusionFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    String[] selectImports(AnnotationMetadata importingClassMetadata);<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;String&gt; <span class="hljs-title">getExclusionFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到目前为止，我们了解了两种使用<code>@Import</code>有特殊机制的接口：ImportSelector（这里用到的）和ImportBeanDefinitionRegistrar（之前Mybatis-spring源码有讲）当然还有普通的<code>@Configuration</code>配置类。</p><p>我们可以来阅读一下<code>ConfigurationClassPostProcessor</code>的源码，看看它到底是如何处理<code>@Import</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;<br>    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> ArrayList();<br>  <span class="hljs-comment">//注意这个阶段仅仅是已经完成扫描了所有的Bean，得到了所有的BeanDefinition，但是还没有进行任何区分</span><br>  <span class="hljs-comment">//candidate是候选者的意思，一会会将标记了@Configuration的类作为ConfigurationClass加入到configCandidates中</span><br>    String[] candidateNames = registry.getBeanDefinitionNames();<br>    String[] var4 = candidateNames;<br>    <span class="hljs-keyword">int</span> var5 = candidateNames.length;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var6 = <span class="hljs-number">0</span>; var6 &lt; var5; ++var6) &#123;<br>        String beanName = var4[var6];<br>        BeanDefinition beanDef = registry.getBeanDefinition(beanName);<br>        <span class="hljs-keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;<br>                <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;   <span class="hljs-comment">//判断是否添加了@Configuration注解</span><br>            configCandidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!configCandidates.isEmpty()) &#123;<br>        <span class="hljs-comment">//...省略</span><br><br>      <span class="hljs-comment">//这里创建了一个ConfigurationClassParser用于解析配置类</span><br>        ConfigurationClassParser parser = <span class="hljs-keyword">new</span> ConfigurationClassParser(<span class="hljs-keyword">this</span>.metadataReaderFactory, <span class="hljs-keyword">this</span>.problemReporter, <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator, registry);<br>      <span class="hljs-comment">//所有配置类的BeanDefinitionHolder列表</span><br>        Set&lt;BeanDefinitionHolder&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet(configCandidates);<br>      <span class="hljs-comment">//已经解析完成的类</span><br>        HashSet alreadyParsed = <span class="hljs-keyword">new</span> HashSet(configCandidates.size());<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">//这里省略，直到所有的配置类全部解析完成</span><br>          <span class="hljs-comment">//注意在循环过程中可能会由于@Import新增更多的待解析配置类，一律丢进candidates集合中</span><br>        &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;<br>    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> ArrayList();<br>  <span class="hljs-comment">//注意这个阶段仅仅是已经完成扫描了所有的Bean，得到了所有的BeanDefinition，但是还没有进行任何区分</span><br>  <span class="hljs-comment">//candidate是候选者的意思，一会会将标记了@Configuration的类作为ConfigurationClass加入到configCandidates中</span><br>    String[] candidateNames = registry.getBeanDefinitionNames();<br>    String[] var4 = candidateNames;<br>    <span class="hljs-keyword">int</span> var5 = candidateNames.length;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var6 = <span class="hljs-number">0</span>; var6 &lt; var5; ++var6) &#123;<br>        String beanName = var4[var6];<br>        BeanDefinition beanDef = registry.getBeanDefinition(beanName);<br>        <span class="hljs-keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;<br>                <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;   <span class="hljs-comment">//判断是否添加了@Configuration注解</span><br>            configCandidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!configCandidates.isEmpty()) &#123;<br>        <span class="hljs-comment">//...省略</span><br><br>      <span class="hljs-comment">//这里创建了一个ConfigurationClassParser用于解析配置类</span><br>        ConfigurationClassParser parser = <span class="hljs-keyword">new</span> ConfigurationClassParser(<span class="hljs-keyword">this</span>.metadataReaderFactory, <span class="hljs-keyword">this</span>.problemReporter, <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator, registry);<br>      <span class="hljs-comment">//所有配置类的BeanDefinitionHolder列表</span><br>        Set&lt;BeanDefinitionHolder&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet(configCandidates);<br>      <span class="hljs-comment">//已经解析完成的类</span><br>        HashSet alreadyParsed = <span class="hljs-keyword">new</span> HashSet(configCandidates.size());<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">//这里省略，直到所有的配置类全部解析完成</span><br>          <span class="hljs-comment">//注意在循环过程中可能会由于@Import新增更多的待解析配置类，一律丢进candidates集合中</span><br>        &#125; <span class="hljs-keyword">while</span>(!candidates.isEmpty());<br><br>        ...<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看，<code>ConfigurationClassParser</code>是如何进行解析的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  <span class="hljs-comment">//@Conditional相关注解处理</span><br>  <span class="hljs-comment">//后面会讲</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;<br>        ...<br>        &#125;<br><br>        ConfigurationClassParser.SourceClass sourceClass = <span class="hljs-keyword">this</span>.asSourceClass(configClass, filter);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>          <span class="hljs-comment">//核心</span><br>            sourceClass = <span class="hljs-keyword">this</span>.doProcessConfigurationClass(configClass, sourceClass, filter);<br>        &#125; <span class="hljs-keyword">while</span>(sourceClass != <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  <span class="hljs-comment">//@Conditional相关注解处理</span><br>  <span class="hljs-comment">//后面会讲</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;<br>        ...<br>        &#125;<br><br>        ConfigurationClassParser.SourceClass sourceClass = <span class="hljs-keyword">this</span>.asSourceClass(configClass, filter);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>          <span class="hljs-comment">//核心</span><br>            sourceClass = <span class="hljs-keyword">this</span>.doProcessConfigurationClass(configClass, sourceClass, filter);<br>        &#125; <span class="hljs-keyword">while</span>(sourceClass != <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-keyword">this</span>.configurationClasses.put(configClass, configClass);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们再来看最核心的<code>doProcessConfigurationClass</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="hljs-function">    ...</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">processImports</span><span class="hljs-params">(configClass, sourceClass, getImports(sourceClass)</span>, <span class="hljs-keyword">true</span>)</span>;    <span class="hljs-comment">// 处理Import注解</span><br><br>...<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="hljs-function">    ...</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">processImports</span><span class="hljs-params">(configClass, sourceClass, getImports(sourceClass)</span>, <span class="hljs-keyword">true</span>)</span>;    <span class="hljs-comment">// 处理Import注解</span><br><br>...<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processImports</span><span class="hljs-params">(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter, <span class="hljs-keyword">boolean</span> checkForCircularImports)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!importCandidates.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (checkForCircularImports &amp;&amp; <span class="hljs-keyword">this</span>.isChainedImportOnStack(configClass)) &#123;<br>            <span class="hljs-keyword">this</span>.problemReporter.error(<span class="hljs-keyword">new</span> ConfigurationClassParser.CircularImportProblem(configClass, <span class="hljs-keyword">this</span>.importStack));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.importStack.push(configClass);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Iterator var6 = importCandidates.iterator();<br><br>                <span class="hljs-keyword">while</span>(var6.hasNext()) &#123;<br>                    ConfigurationClassParser.SourceClass candidate = (ConfigurationClassParser.SourceClass)var6.next();<br>                    Class candidateClass;<br>                  <span class="hljs-comment">//如果是ImportSelector类型，继续进行运行</span><br>                    <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;<br>                        candidateClass = candidate.loadClass();<br>                        ImportSelector selector = (ImportSelector)ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.registry);<br>                        Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();<br>                        <span class="hljs-keyword">if</span> (selectorFilter != <span class="hljs-keyword">null</span>) &#123;<br>                            exclusionFilter = exclusionFilter.or(selectorFilter);<br>                        &#125;<br><span class="hljs-comment">//如果是DeferredImportSelector的实现类，那么会走deferredImportSelectorHandler的handle方法</span><br>                        <span class="hljs-keyword">if</span> (selector <span class="hljs-keyword">instanceof</span> DeferredImportSelector) &#123;<br>                            <span class="hljs-keyword">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector)selector);<br>                          <span class="hljs-comment">//否则就按照正常的ImportSelector类型进行加载</span><br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                          <span class="hljs-comment">//调用selectImports方法获取所有需要加载的类</span><br>                            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());<br>                            Collection&lt;ConfigurationClassParser.SourceClass&gt; importSourceClasses = <span class="hljs-keyword">this</span>.asSourceClasses(importClassNames, exclusionFilter);<br>                          <span class="hljs-comment">//递归处理，直到没有</span><br>                            <span class="hljs-keyword">this</span>.processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, <span class="hljs-keyword">false</span>);<br>                        &#125;<br>                      <span class="hljs-comment">//判断是否为ImportBeanDefinitionRegistrar类型</span><br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;<br>                        candidateClass = candidate.loadClass();<br>                        ImportBeanDefinitionRegistrar registrar = (ImportBeanDefinitionRegistrar)ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.registry);<br>                      <span class="hljs-comment">//往configClass丢ImportBeanDefinitionRegistrar信息进去，之后再处理</span><br>                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());<br>                      <span class="hljs-comment">//否则按普通的配置类进行处理</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">this</span>.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());<br>                        <span class="hljs-keyword">this</span>.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException var17) &#123;<br>                <span class="hljs-keyword">throw</span> var17;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var18) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<span class="hljs-string">&quot;Failed to process import candidates for configuration class [&quot;</span> + configClass.getMetadata().getClassName() + <span class="hljs-string">&quot;]&quot;</span>, var18);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processImports</span><span class="hljs-params">(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter, <span class="hljs-keyword">boolean</span> checkForCircularImports)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!importCandidates.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (checkForCircularImports &amp;&amp; <span class="hljs-keyword">this</span>.isChainedImportOnStack(configClass)) &#123;<br>            <span class="hljs-keyword">this</span>.problemReporter.error(<span class="hljs-keyword">new</span> ConfigurationClassParser.CircularImportProblem(configClass, <span class="hljs-keyword">this</span>.importStack));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.importStack.push(configClass);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Iterator var6 = importCandidates.iterator();<br><br>                <span class="hljs-keyword">while</span>(var6.hasNext()) &#123;<br>                    ConfigurationClassParser.SourceClass candidate = (ConfigurationClassParser.SourceClass)var6.next();<br>                    Class candidateClass;<br>                  <span class="hljs-comment">//如果是ImportSelector类型，继续进行运行</span><br>                    <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;<br>                        candidateClass = candidate.loadClass();<br>                        ImportSelector selector = (ImportSelector)ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.registry);<br>                        Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();<br>                        <span class="hljs-keyword">if</span> (selectorFilter != <span class="hljs-keyword">null</span>) &#123;<br>                            exclusionFilter = exclusionFilter.or(selectorFilter);<br>                        &#125;<br><span class="hljs-comment">//如果是DeferredImportSelector的实现类，那么会走deferredImportSelectorHandler的handle方法</span><br>                        <span class="hljs-keyword">if</span> (selector <span class="hljs-keyword">instanceof</span> DeferredImportSelector) &#123;<br>                            <span class="hljs-keyword">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector)selector);<br>                          <span class="hljs-comment">//否则就按照正常的ImportSelector类型进行加载</span><br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                          <span class="hljs-comment">//调用selectImports方法获取所有需要加载的类</span><br>                            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());<br>                            Collection&lt;ConfigurationClassParser.SourceClass&gt; importSourceClasses = <span class="hljs-keyword">this</span>.asSourceClasses(importClassNames, exclusionFilter);<br>                          <span class="hljs-comment">//递归处理，直到没有</span><br>                            <span class="hljs-keyword">this</span>.processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, <span class="hljs-keyword">false</span>);<br>                        &#125;<br>                      <span class="hljs-comment">//判断是否为ImportBeanDefinitionRegistrar类型</span><br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;<br>                        candidateClass = candidate.loadClass();<br>                        ImportBeanDefinitionRegistrar registrar = (ImportBeanDefinitionRegistrar)ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.registry);<br>                      <span class="hljs-comment">//往configClass丢ImportBeanDefinitionRegistrar信息进去，之后再处理</span><br>                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());<br>                      <span class="hljs-comment">//否则按普通的配置类进行处理</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">this</span>.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());<br>                        <span class="hljs-keyword">this</span>.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException var17) &#123;<br>                <span class="hljs-keyword">throw</span> var17;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var18) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<span class="hljs-string">&quot;Failed to process import candidates for configuration class [&quot;</span> + configClass.getMetadata().getClassName() + <span class="hljs-string">&quot;]&quot;</span>, var18);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">this</span>.importStack.pop();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不难注意到，虽然这里额外处理了<code>ImportSelector</code>对象，但是还针对<code>ImportSelector</code>的子接口<code>DeferredImportSelector</code>进行了额外处理，Deferred是延迟的意思，它是一个延迟执行的<code>ImportSelector</code>，并不会立即进处理，而是丢进DeferredImportSelectorHandler，并且在<code>parse</code>方法的最后进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;<br>     ...<br><br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;<br>     ...<br><br>    <span class="hljs-keyword">this</span>.deferredImportSelectorHandler.process();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看<code>DeferredImportSelector</code>正好就有一个<code>process</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DeferredImportSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">default</span> Class&lt;? extends DeferredImportSelector.Group&gt; getImportGroup() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Group</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(AnnotationMetadata metadata, DeferredImportSelector selector)</span></span>;<br><br>        Iterable&lt;DeferredImportSelector.Group.Entry&gt; selectImports();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DeferredImportSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">default</span> Class&lt;? extends DeferredImportSelector.Group&gt; getImportGroup() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Group</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(AnnotationMetadata metadata, DeferredImportSelector selector)</span></span>;<br><br>        Iterable&lt;DeferredImportSelector.Group.Entry&gt; selectImports();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> </span>&#123;<br>          ...<br></code></pre></td></tr></table></figure><p>最后经过ConfigurationClassParser处理完成后，通过<code>parser.getConfigurationClasses()</code>就能得到通过配置类导入了哪些额外的配置类。最后将这些配置类全部注册BeanDefinition，然后就可以交给接下来的Bean初始化过程去处理了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(configClasses);<br></code></pre></td></tr></table></figure><p>最后我们再去看<code>loadBeanDefinitions</code>是如何运行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;<br>    ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator();<br>    Iterator var3 = configurationModel.iterator();<br><br>    <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>        ConfigurationClass configClass = (ConfigurationClass)var3.next();<br>        <span class="hljs-keyword">this</span>.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;<br>        String beanName = configClass.getBeanName();<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-keyword">this</span>.registry.removeBeanDefinition(beanName);<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (configClass.isImported()) &#123;<br>            <span class="hljs-keyword">this</span>.registerBeanDefinitionForImportedConfigurationClass(configClass);  <span class="hljs-comment">//注册配置类自己</span><br>        &#125;<br><br>        Iterator var3 = configClass.getBeanMethods().iterator();<br><br>        <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>            BeanMethod beanMethod = (BeanMethod)var3.next();<br>            <span class="hljs-keyword">this</span>.loadBeanDefinitionsForBeanMethod(beanMethod); <span class="hljs-comment">//注册@Bean注解标识的方法</span><br>        &#125;<br><br>      <span class="hljs-comment">//注册`@ImportResource`引入的XML配置文件中读取的bean定义</span><br>        <span class="hljs-keyword">this</span>.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());<br>      <span class="hljs-comment">//注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinition</span><br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;<br>    ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator();<br>    Iterator var3 = configurationModel.iterator();<br><br>    <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>        ConfigurationClass configClass = (ConfigurationClass)var3.next();<br>        <span class="hljs-keyword">this</span>.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;<br>        String beanName = configClass.getBeanName();<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-keyword">this</span>.registry.removeBeanDefinition(beanName);<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (configClass.isImported()) &#123;<br>            <span class="hljs-keyword">this</span>.registerBeanDefinitionForImportedConfigurationClass(configClass);  <span class="hljs-comment">//注册配置类自己</span><br>        &#125;<br><br>        Iterator var3 = configClass.getBeanMethods().iterator();<br><br>        <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>            BeanMethod beanMethod = (BeanMethod)var3.next();<br>            <span class="hljs-keyword">this</span>.loadBeanDefinitionsForBeanMethod(beanMethod); <span class="hljs-comment">//注册@Bean注解标识的方法</span><br>        &#125;<br><br>      <span class="hljs-comment">//注册`@ImportResource`引入的XML配置文件中读取的bean定义</span><br>        <span class="hljs-keyword">this</span>.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());<br>      <span class="hljs-comment">//注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinition</span><br>        <span class="hljs-keyword">this</span>.loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，整个<code>@Configuration</code>配置类的底层配置流程我们就大致了解了。接着我们来看AutoConfigurationImportSelector是如何实现自动配置的，可以看到内部类AutoConfigurationGroup的process方法，它是父接口的实现，因为父接口是<code>DeferredImportSelector</code>，那么很容易得知，实际上最后会调用<code>process</code>方法获取所有的自动配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;<br>    Assert.state(deferredImportSelector <span class="hljs-keyword">instanceof</span> AutoConfigurationImportSelector, () -&gt; &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Only %s implementations are supported, got %s&quot;</span>, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName());<br>    &#125;);<br>  <span class="hljs-comment">//获取所有的Entry，其实就是，读取spring.factories来查看有哪些自动配置类</span><br>    AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector)deferredImportSelector).getAutoConfigurationEntry(annotationMetadata);<br>    <span class="hljs-keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);<br>    Iterator var4 = autoConfigurationEntry.getConfigurations().iterator();<br><br>    <span class="hljs-keyword">while</span>(var4.hasNext()) &#123;<br>        String importClassName = (String)var4.next();<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;<br>    Assert.state(deferredImportSelector <span class="hljs-keyword">instanceof</span> AutoConfigurationImportSelector, () -&gt; &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Only %s implementations are supported, got %s&quot;</span>, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName());<br>    &#125;);<br>  <span class="hljs-comment">//获取所有的Entry，其实就是，读取spring.factories来查看有哪些自动配置类</span><br>    AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector)deferredImportSelector).getAutoConfigurationEntry(annotationMetadata);<br>    <span class="hljs-keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);<br>    Iterator var4 = autoConfigurationEntry.getConfigurations().iterator();<br><br>    <span class="hljs-keyword">while</span>(var4.hasNext()) &#123;<br>        String importClassName = (String)var4.next();<br>        <span class="hljs-keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看<code>getAutoConfigurationEntry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">protected</span> AutoConfigurationImportSelector.<span class="hljs-function">AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;<br>  <span class="hljs-comment">//判断是否开启了自动配置，是的，自动配置可以关</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//根据注解定义获取一些属性</span><br>        AnnotationAttributes attributes = <span class="hljs-keyword">this</span>.getAttributes(annotationMetadata);<br>      <span class="hljs-comment">//得到spring.factories文件中所有需要自动配置的类</span><br>        List&lt;String&gt; configurations = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">protected</span> AutoConfigurationImportSelector.<span class="hljs-function">AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;<br>  <span class="hljs-comment">//判断是否开启了自动配置，是的，自动配置可以关</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//根据注解定义获取一些属性</span><br>        AnnotationAttributes attributes = <span class="hljs-keyword">this</span>.getAttributes(annotationMetadata);<br>      <span class="hljs-comment">//得到spring.factories文件中所有需要自动配置的类</span><br>        List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>        ... 这里先看前半部分<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里并不是spring.factories文件中所有的自动配置类都会被加载，它会根据@Condition注解的条件进行加载。这样就能实现我们需要什么模块添加对应依赖就可以实现自动配置了。</p><p>所有的源码看不懂，都源自于你的心中没有形成一个完整的闭环！一旦一条线推到头，闭环形成，所有疑惑迎刃而解。</p><h3 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h3><p>我们仿照Mybatis来编写一个自己的starter，Mybatis的starter包含两个部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  starter本身只做依赖集中管理，不编写任何代码  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module.name</span>&gt;</span>org.mybatis.spring.boot.starter<span class="hljs-tag">&lt;/<span class="hljs-name">module.name</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  编写的专用配置模块   --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  starter本身只做依赖集中管理，不编写任何代码  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module.name</span>&gt;</span>org.mybatis.spring.boot.starter<span class="hljs-tag">&lt;/<span class="hljs-name">module.name</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  编写的专用配置模块   --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>></span><br></code></pre></td></tr></table></figure><p>因此我们也将我们自己的starter这样设计：</p><p>我们设计三个模块：</p><ul><li>spring-boot-hello：基础业务功能模块</li><li>spring-boot-starter-hello：启动器</li><li>spring-boot-autoconifgurer-hello：自动配置依赖</li></ul><p>首先是基础业务功能模块，这里我们随便创建一个类就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldService</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>启动器主要做依赖管理，这里就不写任何代码，只写pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigurer-hello<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigurer-hello<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>></span><br></code></pre></td></tr></table></figure><p>导入autoconfigurer模块作为依赖即可，接着我们去编写autoconfigurer模块，首先导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-hello<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-hello<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>></span><br></code></pre></td></tr></table></figure><p>接着创建一个HelloWorldAutoConfiguration作为自动配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnWebApplication</span><br><span class="hljs-meta">@ConditionalOnClass(HelloWorldService.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(HelloWorldProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldAutoConfiguration</span> </span>&#123;<br><br>    Logger logger = Logger.getLogger(<span class="hljs-keyword">this</span>.getClass().getName());<br><br>    <span class="hljs-meta">@Resource</span><br>    HelloWorldProperties properties;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloWorldService <span class="hljs-title">helloWorldService</span><span class="hljs-params">()</span></span>&#123;<br>        logger.info(<span class="hljs-string">&quot;自定义starter项目已启动！&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;读取到自定义配置：&quot;</span>+properties.getValue());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnWebApplication</span><br><span class="hljs-meta">@ConditionalOnClass(HelloWorldService.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(HelloWorldProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldAutoConfiguration</span> </span>&#123;<br><br>    Logger logger = Logger.getLogger(<span class="hljs-keyword">this</span>.getClass().getName());<br><br>    <span class="hljs-meta">@Resource</span><br>    HelloWorldProperties properties;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloWorldService <span class="hljs-title">helloWorldService</span><span class="hljs-params">()</span></span>&#123;<br>        logger.info(<span class="hljs-string">&quot;自定义starter项目已启动！&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;读取到自定义配置：&quot;</span>+properties.getValue());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloWorldService();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的配置读取类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;hello.world&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldProperties</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(String value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;hello.world&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldProperties</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(String value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后再编写<code>spring.factories</code>文件，并将我们的自动配置类添加即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string"><code class="language-hljs properties"><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">  com.hello.autoconfigurer.HelloWorldAutoConfiguration</span><br></code></pre></td></tr></table></figure><p>最后再Maven根项目执行<code>install</code>安装到本地仓库，完成。接着就可以在其他项目中使用我们编写的自定义starter了。</p><h3 id="Runner接口"><a href="#Runner接口" class="headerlink" title="Runner接口"></a>Runner接口</h3><p>在项目中，可能会遇到这样一个问题：我们需要在项目启动完成之后，紧接着执行一段代码。</p><p>我们可以编写自定义的ApplicationRunner来解决，它会在项目启动完成后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">"我是自定义执行！"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以使用CommandLineRunner，它也支持使用@Order或是实现Ordered接口来支持优先级执行。</p><p>实际上它就是run方法的最后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>    ....<br><br>        listeners.started(context, timeTakenToStartup);<br>  <span class="hljs-comment">//这里已经完成整个SpringBoot项目启动，所以执行所有的Runner</span><br>        <span class="hljs-keyword">this</span>.callRunners(context, applicationArguments);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var12) &#123;<br>        <span class="hljs-keyword">this</span>.handleRunFailure(context, var12, listeners);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(var12);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);<br>        listeners.ready(context, timeTakenToReady);<br>        <span class="hljs-keyword">return</span> context;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var11) &#123;<br>        <span class="hljs-keyword">this</span>.handleRunFailure(context, var11, (SpringApplicationRunListeners)<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>    ....<br><br>        listeners.started(context, timeTakenToStartup);<br>  <span class="hljs-comment">//这里已经完成整个SpringBoot项目启动，所以执行所有的Runner</span><br>        <span class="hljs-keyword">this</span>.callRunners(context, applicationArguments);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var12) &#123;<br>        <span class="hljs-keyword">this</span>.handleRunFailure(context, var12, listeners);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(var12);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);<br>        listeners.ready(context, timeTakenToReady);<br>        <span class="hljs-keyword">return</span> context;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var11) &#123;<br>        <span class="hljs-keyword">this</span>.handleRunFailure(context, var11, (SpringApplicationRunListeners)<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(var11);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下一章，我们将继续讲解几乎程序员必会的Git版本控制。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/16/4.html/"/>
      <url>/2022/03/16/4.html/</url>
      
        <content type="html"><![CDATA[<h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><p><strong>提醒：</strong>还没有申请到IDEA专业版本授权的同学要抓紧了，很快就需要用到。</p><p>经过前面基础内容的学习，现在我们就可以正式地进入Web开发的学习当中啦~</p><p>本章节会讲解前端基础内容（如果已经学习过，可以直接跳到下一个大章节了）那么什么是前端，什么又是后端呢？</p><ul><li>前端：我们网站的页面，包括网站的样式、图片、视频等一切用户可见的内容都是前端的内容。</li><li>后端：处理网站的所有数据来源，比如我们之前从数据库中查询数据，而我们查询的数据经过处理最终会被展示到前端，而用于处理前端数据的工作就是由后端来完成的。</li></ul><p>相当于，前端仅仅是一层皮，它直接决定了整个网站的美观程度，我们可以自由地编排页面的布局，甚至可以编写好看的特效；而灵魂则是后端，如何处理用户的交互、如何处理数据查询是后端的职责所在，我们前面学习的都是后端内容，而Java也是一门专注于后端开发的语言。</p><p>对于前端开发我们需要学习一些新的内容，只有了解了它们，我们才能编写出美观的页面。</p><p>本教程并不会过多地去讲解前端知识，我们只会提及一些必要的内容，我们主要学习的是JavaWeb，更倾向于后端开发，学习前端的目的只是为了让同学们了解前后端的交互方式，在进行后端开发时思路能够更加清晰，有关前端的完整内容学习，可以浏览其他前端知识教程。</p><p>我们在最开始讲解网络编程时，提到了浏览器访问服务器，实际上浏览器访问服务器就是一种B/S结构，而我们使用Java代码编写的客户端连接服务器就是一种C/S结构。</p><p>Web开发还要从HTML开始讲起，这个语言非常简单，很好学习，看完视频如果你觉得前端简单自己更喜欢一些，建议马上转前端吧，还来得及，工资还比后端高，不像后端那么枯燥乏味。</p><h2 id="HTML页面"><a href="#HTML页面" class="headerlink" title="HTML页面"></a>HTML页面</h2><p>我们前面学习了XML语言，它是一种标记语言，我们需要以成对标签的格式进行填写，但是它是专用于保存数据，而不是展示数据，而HTML恰恰相反，它专用于展示数据，由于我们前面已经学习过XML语言了，HTML语言和XML很相似，所以我们学习起来会很快。</p><h3 id="第一个HTML页面"><a href="#第一个HTML页面" class="headerlink" title="第一个HTML页面"></a>第一个HTML页面</h3><p>我们前面知道，通过浏览器可以直接浏览XML文件，而浏览器一般是用于浏览HTML文件的，以HTML语言编写的内容，会被浏览器识别为一个页面，并根据我们编写的内容，将对应的组件添加到浏览器窗口中。</p><p>我们一般使用Chrome、Safari、Microsoft Edge等浏览器进行测试，IE浏览器已经彻底淘汰了！</p><p>比如我们可以创建一个Html文件来看看浏览器会如何识别，使用IDEA也能编写HTML页面，我们在IDEA中新建一个<code>Web模块</code>，进入之后我们发现，项目中没有任何内容，我们右键新建一个HTML文件，选择HTML5文件，并命名为index，创建后出现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>></span><br></code></pre></td></tr></table></figure><p>我们发现，它和XML基本长得一样，并且还自带了一些标签，那么现在我们通过浏览器来浏览这个HTML文件（这里推荐使用内置预览，不然还得来回切换窗口）</p><p>我们发现现在什么东西都没有，但是在浏览器的标签位置显示了网页的名称为<code>Title</code>，并且显示了一个IDEA的图标作为网页图标。</p><p>现在我们稍微进行一些修改：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>lbw的直播间<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    现在全体起立<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>lbw的直播间<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    现在全体起立<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>></span><br></code></pre></td></tr></table></figure><p>再次打开浏览器，我们发现页面中出现了我们输入的文本内容，并且标题也改为了我们自定义的标题。</p><p>我们可以在设置-&gt;工具-&gt;Web浏览器和预览中将重新加载页面规则改为<code>变更时</code>，这样我们使用内置浏览器或是外部浏览器，可以自动更新我们编写的内容。</p><p>我们还可以在页面中添加一个图片，随便将一张图片放到html文件的同级目录下，命名为<code>image.xxx</code>，其中xxx是后缀名称，不要修改，我们在body节点中添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.xxx&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;剑光如我，斩尽牛杂&quot;</span>&gt;</span><br><span class="hljs-comment"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.xxx&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;剑光如我，斩尽牛杂&quot;</span>&gt;</span><br><span class="hljs-comment"><!--  注意xxx替换成对应的后缀名称  --></span><br></code></pre></td></tr></table></figure><p>我们发现，我们的页面中居然能够显示我们添加的图片内容。因此，我们只需要编写对应的标签，浏览器就能够自动识别为对应的组件，并将其展示到我们的浏览器窗口中。</p><p>我们再来看看插入一个B站的视频，很简单，只需要到对应的视频下方，找到分享，我们看到有一个嵌入代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//player.bilibili.com/player.html?aid=333231998&amp;bvid=BV1rA411g7q8&amp;cid=346917516&amp;page=1&quot;</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">framespacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//player.bilibili.com/player.html?aid=333231998&amp;bvid=BV1rA411g7q8&amp;cid=346917516&amp;page=1&quot;</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">framespacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>></span><br></code></pre></td></tr></table></figure><p>每一个页面都是通过这些标签来编写的，几乎所有的网站都是使用HTML编写页面。</p><h3 id="HTML语法规范"><a href="#HTML语法规范" class="headerlink" title="HTML语法规范"></a>HTML语法规范</h3><p>一个HTML文件中一般分为两个部分：</p><ul><li>头部：一般包含页面的标题、页面的图标、还有页面的一些设置，也可以在这里导入css、js等内容。</li><li>主体：整个页面所有需要显示的内容全部在主体编写。</li></ul><p>我们首先来看头部，我们之前使用的HTML文件中头部包含了这些内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>lbw的直播间<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>lbw的直播间<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>></span><br></code></pre></td></tr></table></figure><p>首先<code>meta</code>标签用于定义页面的一些元信息，这里使用它来定义了一个字符集（编码格式），一般是UTF-8，下面的<code>title</code>标签就是页面的标题，会显示在浏览器的上方。我们现在来给页面设置一个图标，图标一般可以在字节跳动的IconPark网站找到：<a href="https://iconpark.oceanengine.com/home%EF%BC%8C%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E5%9B%BE%E6%A0%87%E4%B8%8B%E8%BD%BD%E5%8D%B3%E5%8F%AF%E3%80%82">https://iconpark.oceanengine.com/home，选择一个自己喜欢的图标下载即可。</a></p><p>将图标放入到项目目录中，并命名为icon.png，在HTML头部添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;icon.png&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;icon.png&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/x-icon"</span> /></span><br></code></pre></td></tr></table></figure><p><code>link</code>标签用于关联当前HTML页面与其他资源的关系，关系通过<code>rel</code>属性指定，这里使用的是icon表示这个文件是当前页面图标。</p><p>现在访问此页面，我们发现页面的图标已经变成我们指定的图标样式了。</p><p>现在我们再来看主体，我们可以在主体内部编写该页面要展示的所有内容，比如我们之前就用到了img标签来展示一个图片，其中每一个标签都称为一个元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.xxx&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.xxx&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"当图片加载失败时，显示的文本"</span>></span><br></code></pre></td></tr></table></figure><p>我们发现，这个标签只存在一个，并没有成对出现，HTML中有些标签是单标签，也就是说只有这一个，还有一些标签是双标签，必须成对出现，HTML中，也不允许交叉嵌套，但是出现交叉嵌套时，浏览器并不会提示错误，而是仍旧尝试去解析这些内容，甚至会帮助我们进行一定程度的修复，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//player.bilibili.com/player.html?aid=333231998&amp;bvid=BV1rA411g7q8&amp;cid=346917516&amp;page=1&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">scrolling</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">framespacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//player.bilibili.com/player.html?aid=333231998&amp;bvid=BV1rA411g7q8&amp;cid=346917516&amp;page=1&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">scrolling</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">framespacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>></span><br></code></pre></td></tr></table></figure><p>很明显上面的代码已经出现交叉嵌套的情况了，但是依然能够在浏览器中正确地显示。</p><p>在主体中，我们一般使用div标签来分割页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是第一块<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是第二块<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是第一块<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是第二块<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span><br></code></pre></td></tr></table></figure><p>通过使用<code>div</code>标签，我们将整个页面按行划分，而高度就是内部元素的高度，那么如果只希望按元素划分，也就是说元素占多大就划分多大的空间，那么我们就可以使用<code>span</code>标签来划分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是第一块第一个部分<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是第一块第二个部分<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是第二块<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是第一块第一个部分<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是第一块第二个部分<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是第二块<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span><br></code></pre></td></tr></table></figure><p>我们也可以使用<code>p</code>段落标签，它一般用于文章分段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        你看这个彬彬啊，才喝几罐就醉了，真的太逊了。 这个彬彬就是逊呀！<br>        听你这么说，你很勇哦？ 开玩笑，我超勇的，超会喝的啦。<br>        超会喝，很勇嘛。身材不错哦，蛮结实的嘛。<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        哎，杰哥，你干嘛啊。都几岁了，还那么害羞！我看你，完全是不懂哦！<br>        懂，懂什么啊？ 你想懂？我房里有一些好康的。<br>        好康，是新游戏哦！ 什么新游戏，比游戏还刺激！<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        杰哥，这是什么啊？ 哎呦，你脸红啦！来，让我看看。<br>        不要啦！！ 让我看看嘛。 不要啦，杰哥，你干嘛啊！<br>        让我看看你法语正不正常啊！<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        你看这个彬彬啊，才喝几罐就醉了，真的太逊了。 这个彬彬就是逊呀！<br>        听你这么说，你很勇哦？ 开玩笑，我超勇的，超会喝的啦。<br>        超会喝，很勇嘛。身材不错哦，蛮结实的嘛。<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        哎，杰哥，你干嘛啊。都几岁了，还那么害羞！我看你，完全是不懂哦！<br>        懂，懂什么啊？ 你想懂？我房里有一些好康的。<br>        好康，是新游戏哦！ 什么新游戏，比游戏还刺激！<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        杰哥，这是什么啊？ 哎呦，你脸红啦！来，让我看看。<br>        不要啦！！ 让我看看嘛。 不要啦，杰哥，你干嘛啊！<br>        让我看看你法语正不正常啊！<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span><br></code></pre></td></tr></table></figure><p>那么如果遇到特殊字符该怎么办呢？和XML一样，我们可以使用转义字符：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.51wendang.com%2Fpic%2F208288d7561926f359c6be84%2F1-352-jpg_6_0_______-356-0-0-356.jpg&refer=http%3A%2F%2Fwww.51wendang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639877607&t=bcc1fcfe8bae53e90c365a4fd8c00a1c" alt="点击查看源网页"></p><p><strong>注意：</strong>多个连续的空格字符只能被识别为一个，如果需要连续多个必须使用转义字符，同时也不会识别换行，换行只会变成一个空格，需要换行必须使用<code>br</code>标签。</p><p>通过了解了HTML的一些基础语法，我们现在就知道一个页面大致是如何编写了。</p><h3 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h3><p>前面我们已经了解了HTML的基本语法规范，那么现在我们就来看看，有哪些常用的标签吧，首先是换行和分割线：</p><ul><li>br 换行</li><li>hr 分割线</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        我是一段文字<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>我是第二段文字<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是底部文字<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        我是一段文字<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>我是第二段文字<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是底部文字<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span><br></code></pre></td></tr></table></figure><p>标题一般用h1到h6表示，我们来看看效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>五级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是正文内容，真不错。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>五级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是正文内容，真不错。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span><br></code></pre></td></tr></table></figure><p>现在我们来看看超链接，我们可以添加一个链接用于指向其他网站：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>&gt;</span>点击访问小破站<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>&gt;</span>点击访问小破站<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>></span><br></code></pre></td></tr></table></figure><p>我们也可以指定页面上的一个锚点进行滚动：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#test&quot;</span>&gt;</span>跳转锚点<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>我是锚点<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#test&quot;</span>&gt;</span>跳转锚点<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>我是锚点<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpeg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span><br></code></pre></td></tr></table></figure><p>每个元素都可以有一个id属性，我们只需要给元素添加一个id属性，就使用a标签可以跳转到一个指定锚点。</p><p>我们接着来看看列表元素，这是一个无需列表，其中每一个<code>li</code>表示一个列表项：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>一号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>二号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>三号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>四号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>五号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>一号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>二号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>三号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>四号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>五号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>></span><br></code></pre></td></tr></table></figure><p>我们也可以使用<code>ol</code>来显示一个有序列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>一号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>二号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>三号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>四号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>五号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>一号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>二号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>三号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>四号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>五号选项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>></span><br></code></pre></td></tr></table></figure><p>表格也是很重要的一种元素，但是它编写起来相对有一点麻烦：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>学号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年级<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>0001<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小明<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2019<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>0002<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小红<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2020<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>学号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年级<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>0001<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小明<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2019<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>0002<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小红<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2020<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>></span><br></code></pre></td></tr></table></figure><p>虽然这样生成了一个表格，但是这个表格并没有分割线，并且格式也不符合我们想要的样式，那么如何才能修改这些基础属性的样式呢，我们就需要聊聊CSS了。</p><h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3><p>表单就像其名字一样，用户在页面中填写了对应的内容，点击按钮就可以提交到后台，比如登陆界面，就可以使用表单来实现：</p><p>一个网页中最重要的当属输入框和按钮了，那么我们来看看如何创建一个输入框和按钮：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    我是输入框<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    我是输入框<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>></span><br></code></pre></td></tr></table></figure><p>对于一个输入框，我们一般会将其包括在一个<code>lable</code>标签中，它和span效果一样，但是我们点击前面文字也能快速获取输入框焦点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>登陆我们的网站<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        账号：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        密码：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>登陆我们的网站<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        账号：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        密码：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span><br></code></pre></td></tr></table></figure><p>输入框可以有很多类型，我们来试试看password，现在输入内容就不会直接展示原文了。</p><p>创建一个按钮有以下几种方式，在学习JavaWeb时，我们更推荐第二种方式，我们后面进行登陆操作需要配合表单使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登陆&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登陆<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登陆&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登陆"</span>></span><br></code></pre></td></tr></table></figure><p>现在我们就可以写一个大致的登陆页面了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登陆我们的网站<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                账号：<br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Username...&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                密码：<br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Password...&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>&gt;</span>忘记密码<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登陆&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登陆我们的网站<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                账号：<br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Username...&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                密码：<br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Password...&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>&gt;</span>忘记密码<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登陆&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span><br></code></pre></td></tr></table></figure><p>表单一般使用<code>form</code>标签将其囊括，但是现在我们还用不到表单提交，因此之后我们再来讲解表单的提交。</p><p><code>input</code>只能实现单行文本，那么如何实现多行文本呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    这是我们的文本框<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;文本内容...&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    这是我们的文本框<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;文本内容...&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>></span><br></code></pre></td></tr></table></figure><p>我们还可以指定默认的行数和列数，拖动左下角可以自定义文本框的大小。</p><p>我们还可以在页面中添加勾选框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>    我同意本网站的隐私政策<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>    我同意本网站的隐私政策<br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>></span><br></code></pre></td></tr></table></figure><p>上面演示的是一个多选框，那么我们来看看单选框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;role&quot;</span>&gt;</span><br>    学生<br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;role&quot;</span>&gt;</span><br>    教师<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;role&quot;</span>&gt;</span><br>    学生<br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;role&quot;</span>&gt;</span><br>    教师<br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>></span><br></code></pre></td></tr></table></figure><p>这里需要使用name属性进行分组，同一个组内的选项只能选择一个。</p><p>我们也可以添加列表让用户进行选择，创建一个下拉列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    登陆身份：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>学生<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>教师<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>    登陆身份：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>学生<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>教师<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>></span><br></code></pre></td></tr></table></figure><p>默认选取的是第一个选项，我们可以通过<code>selected</code>属性来决定默认使用的是哪个选项。</p><p>当然，HTML的元素远不止我们所提到的这些，有关更多HTML元素的内容，可以自行了解。</p><hr><h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><p>之前我们编写的页面非常基础，我们只能通过一些很基本的属性来排列我们的页面元素，那么如何实现更高度的自定义呢，我们就需要用到CSS来自定义样式，首先我们创建一个名为<code>style.css</code>的文件。</p><p>首先在我们HTML文件的头部添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>></span><br></code></pre></td></tr></table></figure><p>我们在CSS文件中添加以下内容：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute"><code class="language-hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，网页的内容全部变为居中显示了，这正是css在生效，相当于我们现在给页面添加了自定义的样式规则。</p><p>当然，我们也可以选择不使用CSS，而是直接对某个元素添加样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center;"</span>></span><br>  ...<br></code></pre></td></tr></table></figure><p>这样的效果其实是等同于上面的css文件的，相当于我们直接把样式定义在指定元素上。</p><p>也可以在头部直接定义样式，而不是使用外部文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">    &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">    &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>></span><br></code></pre></td></tr></table></figure><p>使用以上三种方式都可以自定义页面的样式，我们推荐使用还是第一种，不然我们的代码会很繁杂。</p><p>样式的属性是非常多的，我们不可能一个一个全部讲完，视频中用到什么再来讲解什么，如果同学们感兴趣，可以自行下去了解。</p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>我们首先来了解一下选择器，那么什么是选择器呢？我们想要自定义一个元素的样式，那么我们肯定要去选择某个元素，只有先找到要自定义的元素，我们才能开始编写样式。</p><p>我们上面的例子中使用的就是标签名选择器，它可以快速选择页面中所有指定的的标签，比如我们之前使用的就是<code>body</code>标签，那么就相当于页面中所有的body元素全都使用此样式，那么我们现在来试试看选择页面中所有的<code>input</code>标签：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-tag">input</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number"><code class="language-hljs css"><span class="hljs-selector-tag">input</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，页面中所有的<code>input</code>元素宽度全部被设定为了200个像素（<code>px</code>是单位大小，代表像素，除了<code>px</code>还有<code>em</code>和<code>rem</code>，他们是根据当前元素字体大小决定的相对大小，一般用于适配各种大小的浏览器窗口，这里暂时不用）</p><p>样式编写完成后，如果只有一个属性，可以不带<code>;</code>若多个属性则每个属性后面都需要添加一个<code>;</code></p><p>因此，一个标签选择器的格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs css"><code class="language-hljs css">标签名称 &#123;<br>  属性名称: 属性值<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以设定输入框的字体大小、行高等：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-tag">input</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number"><code class="language-hljs css"><span class="hljs-selector-tag">input</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">40px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在可以通过选择器快速地去设置某个元素样式了，那么如何实现只设置某个元素的样式呢，现在我们来看看，id选择器，我们之前已经讲解过了，每个元素都可以有一个id属性，我们可以将其当做一个跳转的锚点使用，而现在，我们可以使用css来进行定位：</p><p>我们先为元素添加id属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>登陆我们的网站<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>登陆我们的网站<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>></span><br></code></pre></td></tr></table></figure><p>现在使用CSS选择我们的元素，并设定一个属性，选择某个id需要在前面加上一个<code>#</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-id">#title</span> &#123;<br>    <span class="hljs-attribute"><code class="language-hljs css"><span class="hljs-selector-id">#title</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然id选择器已经可以很方便的指定某个元素，但是如果我们希望n个但不是元素都被选择，id选择器就无法实现了，因为每个元素的id是唯一的，不允许出现重复id的元素，因此接着我们来讲解一下类选择器。</p><p>每个元素都可以有一个<code>class</code>属性，表示当前元素属于某个类（注意这里的类和我们Java中的类概念完全不同）一个元素可以属于很多个类，一个类也可以被很多个元素使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            账号：<br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Username...&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            密码：<br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Password...&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            账号：<br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Username...&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            密码：<br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Password...&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>></span><br></code></pre></td></tr></table></figure><p>上面的例子中，两个<code>label</code>元素都使用了<code>test</code>类（类名称是我们自定义的），现在我们在css文件中编写以下内容来以类进行选择：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-class">.test</span>&#123;<br>    <span class="hljs-attribute"><code class="language-hljs css"><span class="hljs-selector-class">.test</span>&#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，两个标签的文本内容都变为了蓝色，因此使用类选择器，能够对所有为此类的元素添加样式。注意在进行类选择时，我们需要在类名前面加上<code>.</code>来表示。</p><h3 id="组合选择器和优先级问题"><a href="#组合选择器和优先级问题" class="headerlink" title="组合选择器和优先级问题"></a>组合选择器和优先级问题</h3><p>我们也可以让多个选择器，共用一个css样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-class">.test</span>, <span class="hljs-selector-id">#title</span> &#123;<br>    <span class="hljs-attribute"><code class="language-hljs css"><span class="hljs-selector-class">.test</span>, <span class="hljs-selector-id">#title</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要并排写即可，注意中间需要添加一个英文的逗号用于分割，我们也可以使用<code>*</code>来一次性选择所有的元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs css">* &#123;<br>    <span class="hljs-attribute"><code class="language-hljs css">* &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以选择位于某个元素内的某个元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">label</span> &#123;<br>    <span class="hljs-attribute"><code class="language-hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">label</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，就会选择所有位于div元素中的label元素。</p><p>当然，我们这里只介绍了一些常用的选择器，有关详细的CSS选择器可以查阅：<a href="https://www.runoob.com/cssref/css-selectors.html">https://www.runoob.com/cssref/css-selectors.html</a></p><p>我们接着来看一下选择器的优先级：</p><p><img src="https://img2020.cnblogs.com/blog/1864877/202004/1864877-20200408234042787-674324294.png" alt="img"></p><p>我们根据上面的信息，来测试一下，首先编写一下HTML文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simple&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue&quot;</span>&gt;</span>我是测试文本内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simple&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue&quot;</span>&gt;</span>我是测试文本内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span><br></code></pre></td></tr></table></figure><p>现在我们来编写一下css文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-class">.test</span> &#123;<br>    <span class="hljs-attribute">color</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-id">#simple</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br>* &#123;<br>    <span class="hljs-attribute"><code class="language-hljs css"><span class="hljs-selector-class">.test</span> &#123;<br>    <span class="hljs-attribute">color</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-id">#simple</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br>* &#123;<br>    <span class="hljs-attribute">color</span>: palegreen;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在我们可以看到，实际上生效的是我们直接编写在标签内部的内联属性，那么现在我们依次进行移除，来看看它们的优先级。</p><p>那么如果我们希望某个属性无视任何的优先级，我们可以在属性后面添加<code>!important</code>标记，表示此属性是一个重要属性，它的优先级会被置为最高。</p><p><strong>思考：</strong>那要是我每个选择器的这个属性后面都加一个<code>!important</code>会怎么样？</p><h3 id="自定义边距"><a href="#自定义边距" class="headerlink" title="自定义边距"></a>自定义边距</h3><p>我们来看看，如何使用css控制一个div板块的样式，首先编写以下代码，相当于一个div嵌套了一个div元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>现在编写一下自定义的css样式，我们将div设定为固定大小，并且背景颜色添加为绿色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-id">#outer</span> &#123;<br>    <span class="hljs-attribute">background</span>: palegreen;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number"><code class="language-hljs css"><span class="hljs-selector-id">#outer</span> &#123;<br>    <span class="hljs-attribute">background</span>: palegreen;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现左侧快速预览页面存在空隙，这是因为浏览器给我们添加了一个边距属性，我们只需要覆盖此属性并将其设定为0即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number"><code class="language-hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们给内部嵌套的div也设定一个大小，并将颜色设定为橙色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-id">#inner</span> &#123;<br>    <span class="hljs-attribute">background</span>: darkorange;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number"><code class="language-hljs css"><span class="hljs-selector-id">#inner</span> &#123;<br>    <span class="hljs-attribute">background</span>: darkorange;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们发现内部的div元素位于右上角，我们还可以以百分比的形式来指定大小：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-id">#inner</span> &#123;<br>    <span class="hljs-attribute">background</span>: darkorange;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number"><code class="language-hljs css"><span class="hljs-selector-id">#inner</span> &#123;<br>    <span class="hljs-attribute">background</span>: darkorange;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>百分比会依照当前可用大小来进行分配，比如当前位于一个div内部，并且外部div元素是固定大小300px，因此100%就相当于使用了外部的全部大小，也是300px，现在内部元素完全将外部元素覆盖了，整个元素现在呈现为橙色。</p><p>我们可以为一个元素设定边距，边距分为外边距和内边距，外部元素内边距决定了内部元素与外部元素之间的间隔，我们来修改一下css样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-id">#outer</span> &#123;<br>    <span class="hljs-attribute">background</span>: palegreen;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number"><code class="language-hljs css"><span class="hljs-selector-id">#outer</span> &#123;<br>    <span class="hljs-attribute">background</span>: palegreen;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，内部的div元素小了一圈，这是因为外部div元素设定了内边距，上下左右都被设定为10px大小。</p><p>而我们发现，实际上我们在一开始也是将body的外边距设定为了0，整个页面跟浏览器窗口直接间隔0px的宽度。</p><h3 id="编写一个漂亮的登陆界面"><a href="#编写一个漂亮的登陆界面" class="headerlink" title="编写一个漂亮的登陆界面"></a>编写一个漂亮的登陆界面</h3><p>现在我们就来尝试编写一个漂亮的登陆界面吧！</p><hr><h2 id="JavaScript语言"><a href="#JavaScript语言" class="headerlink" title="JavaScript语言"></a>JavaScript语言</h2><p>也称为js，是我们整个前端基础的重点内容，只有了解了JavaScript语言，我们才能了解前端如何与后端交互。</p><p>JavaScript与Java没有毛关系，仅仅只是名字中包含了Java而已，跟Java比起来，它更像Python，它是一门解释型语言，不需要进行编译，它甚至可以直接在浏览器的命令窗口中运行。</p><p>它相当于是前端静态页面的一个补充，它可以让一个普通的页面在后台执行一些程序，比如我们点击一个按钮，我们可能希望执行某些操作，比如下载文件、页面跳转、页面弹窗、进行登陆等，都可以使用JavaScript来帮助我们实现。</p><p>我们来看看一个简单的JavaScript程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">const</span> tmp = arr[j]<br>            arr[j] = arr[j+<span class="hljs-number">1</span>]<br>            arr[j+<span class="hljs-number">1</span>] = tmp<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in"><code class="language-hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">const</span> tmp = arr[j]<br>            arr[j] = arr[j+<span class="hljs-number">1</span>]<br>            arr[j+<span class="hljs-number">1</span>] = tmp<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">window</span>.alert(arr)<br></code></pre></td></tr></table></figure><p>这段代码实际上就是实现了一个冒泡排序算法，我们可以直接在页面的头部中引用此js文件，浏览器会在加载时自动执行js文件中编写的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;test.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;test.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span><br></code></pre></td></tr></table></figure><p>我们发现JS的语法和Java非常相似，但是它还是和Java存在一些不同之处，而且存在很多阴间语法，那么我们来看看JS的语法。</p><h3 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h3><p>在js中，定义变量和Java中有一些不同，定义一个变量可以使用<code>let</code>关键字或是<code>var</code>关键字，IDEA推荐我们使用<code>let</code>关键字，因为<code>var</code>存在一定的设计缺陷（这里就不做讲解了，之后一律使用let关键字进行变量声明）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>a++;<br><span class="hljs-built_in"><code class="language-hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>a++;<br><span class="hljs-built_in">window</span>.alert(a)<br></code></pre></td></tr></table></figure><p>上面的结果中，我们得到了a的结果是11，也就是说自增和自减运算在JS中也是支持的，并且JS每一句结尾可以不用加分号。</p><p>js并不是Java那样的强类型语言（任意变量的类型一定是明确的），它是一门弱类型语言，变量的类型并不会在一开始确定，因此我们在定义变量时无需指定变量的确切类型，而是在运行时动态解析类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-string">&quot;HelloWorld！&quot;</span><br><span class="hljs-built_in"><code class="language-hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-string">&quot;HelloWorld！&quot;</span><br><span class="hljs-built_in">console</span>.info(a)<br></code></pre></td></tr></table></figure><p>我们发现，变量a已经被赋值为数字类型，但是我们依然在后续能将其赋值一个字符串，它的类型是随时可变的。</p><p>很多人说，这种变态的类型机制是JS的一大缺陷。</p><p>世界上只有两种语言：一种是很多人骂的，一种是没人用的。</p><p>我们接着来看看，JS中存在的基本数据类型：</p><ul><li>Number：数字类型（包括小数和整数）</li><li>String：字符串类型（可以使用单引号或是双引号）</li><li>Boolean：布尔类型（与Java一致）</li></ul><p>还包括一些特殊值：</p><ul><li><p>undefined：未定义 - 变量声明但不赋值默认为undefined</p></li><li><p>null：空值 - 等同于Java中的null</p></li><li><p>NaN：非数字 - 值不是合法数字，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-built_in">window</span>.alert(<span class="hljs-number">100</span>/<span class="hljs-string"><code class="language-hljs js"><span class="hljs-built_in">window</span>.alert(<span class="hljs-number">100</span>/<span class="hljs-string">&#x27;xx&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><p>我们可以使用<code>typeof</code>关键字来查看当前变量值的类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.info(<span class="hljs-keyword">typeof</span> a)<br>a = <span class="hljs-string">&#x27;Hello World&#x27;</span><br><span class="hljs-built_in">console</span>.info(<span class="hljs-keyword"><code class="language-hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.info(<span class="hljs-keyword">typeof</span> a)<br>a = <span class="hljs-string">&#x27;Hello World&#x27;</span><br><span class="hljs-built_in">console</span>.info(<span class="hljs-keyword">typeof</span> a)<br></code></pre></td></tr></table></figure><h3 id="JavaScript逻辑运算和流程控制"><a href="#JavaScript逻辑运算和流程控制" class="headerlink" title="JavaScript逻辑运算和流程控制"></a>JavaScript逻辑运算和流程控制</h3><p>我们接着来看看js中的关系运算符，包括如下8个关系运算符：大于（&gt;）,小于（&lt;）,小于等于（&lt;=）,大于等于（&gt;=）,相等（==），不等（!=），全等（===），不全等（!==）</p><p>其实关系运算符大致和Java中的使用方法一致，不过它还可以进行字符串比较，有点像C++的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-number">666</span> &gt; <span class="hljs-number">777</span>)<br><span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;aa&#x27;</span> &gt; <span class="hljs-string"><code class="language-hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-number">666</span> &gt; <span class="hljs-number">777</span>)<br><span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;aa&#x27;</span> &gt; <span class="hljs-string">&#x27;ab&#x27;</span>)<br></code></pre></td></tr></table></figure><p>那么，相等和全等有什么区别呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">console.info(<span class="hljs-string">&#x27;10&#x27;</span> == <span class="hljs-number">10</span>)<br>console.info(<span class="hljs-string">&#x27;10&#x27;</span> === <span class="hljs-number"><code class="language-hljs java">console.info(<span class="hljs-string">&#x27;10&#x27;</span> == <span class="hljs-number">10</span>)<br>console.info(<span class="hljs-string">&#x27;10&#x27;</span> === <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>我们发现，在Java中，若运算符两边是不同的基本数据类型，会直接得到false，而JS中却不像这样，我们发现字符串的10居然等于数字10，而使用全等判断才是我们希望的结果。</p><p><code>==</code>的比较规则是：当操作数类型一样时，比较的规则和恒等运算符一样，都相等才相等，如果两个操作数是字符串，则进行字符串的比较，如果里面有一个操作数不是字符串，那两个操作数通过Number()方法进行转换，转成数字进行比较。</p><p>因此，我们上面进行的判断实际上是运算符两边都进行了数字转换的结果进行比较，自然也就得到了true，而全等判断才是我们在Java中认识的相等判断。</p><p>我们接着来看逻辑运算，JS中包括&amp;&amp;、||、&amp;、|、?:等，我们先来看看位运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-number">4</span> &amp; <span class="hljs-number">7</span>)<br><span class="hljs-built_in">console</span>.info(<span class="hljs-number">4</span> | <span class="hljs-number"><code class="language-hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-number">4</span> &amp; <span class="hljs-number">7</span>)<br><span class="hljs-built_in">console</span>.info(<span class="hljs-number">4</span> | <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><p>实际上和Java中是一样的，那么我再来看看逻辑运算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-literal">true</span> || <span class="hljs-literal"><code class="language-hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p>对于boolean变量的判断，是与Java一致的，但是JS也可以使用非Boolen类型变量进行判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-built_in">console</span>.info(!<span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-number"><code class="language-hljs js"><span class="hljs-built_in">console</span>.info(!<span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>和C/C++语言一样，0代表false，非0代表true，那么字符串呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-built_in">console</span>.info(!<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-string"><code class="language-hljs js"><span class="hljs-built_in">console</span>.info(!<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-string">""</span>)<br></code></pre></td></tr></table></figure><p>我们发现，空串为false，非空串为true，我们再来看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-literal">true</span> || <span class="hljs-number">7</span>)<br><span class="hljs-built_in">console</span>.info(<span class="hljs-number">7</span> || <span class="hljs-literal"><code class="language-hljs js"><span class="hljs-built_in">console</span>.info(<span class="hljs-literal">true</span> || <span class="hljs-number">7</span>)<br><span class="hljs-built_in">console</span>.info(<span class="hljs-number">7</span> || <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>我们发现，前者得到的结果为true，而后者得到的结果却是是7，真是滑天下之大稽，什么鬼玩意，实际上是因为，默认非0都是true，而后者又是先判断的7，因此会直接得到7而不是被转换为true</p><p>那么我们再来看看几个特殊值默认代表什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-built_in">console</span>.info(!<span class="hljs-literal">undefined</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-literal">null</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-literal"><code class="language-hljs js"><span class="hljs-built_in">console</span>.info(!<span class="hljs-literal">undefined</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-literal">null</span>)<br><span class="hljs-built_in">console</span>.info(!<span class="hljs-literal">NaN</span>)<br></code></pre></td></tr></table></figure><p>最后来使用一下三元运算符，实际上和Java中是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">true</span> ? <span class="hljs-string">&quot;xx&quot;</span> : <span class="hljs-number">20</span><br><span class="hljs-built_in"><code class="language-hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">true</span> ? <span class="hljs-string">&quot;xx&quot;</span> : <span class="hljs-number">20</span><br><span class="hljs-built_in">console</span>.info(a)<br></code></pre></td></tr></table></figure><p>得益于JS的动态类型，emmm，三元运算符不一定需要固定的返回值类型。</p><p>JS的分支结构，实际上和Java是一样的，也是使用if-else语句来进行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;lbwnb&quot;</span>)&#123;   <span class="hljs-comment">//非空串为true</span><br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;!!!&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;lbwnb&quot;</span>)&#123;   <span class="hljs-comment">//非空串为true</span><br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;!!!&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"???"</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，多分支语句也能实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;&quot;</span>)&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;!!!&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(-<span class="hljs-number">666</span>)&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;???&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;&quot;</span>)&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;!!!&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(-<span class="hljs-number">666</span>)&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;???&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"O.O"</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，多分支语句也可以使用switch来完成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">switch</span> (a)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;1&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;b&quot;</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;2&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;c&quot;</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;3&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-attr">default</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">switch</span> (a)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;1&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;b&quot;</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;2&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;c&quot;</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;3&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-attr">default</span>:<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"4"</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看看循环结构，其实循环结构也和Java相差不大：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">10</span><br><span class="hljs-keyword">while</span>(i--)&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">10</span><br><span class="hljs-keyword">while</span>(i--)&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"100"</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"??"</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JavaScript函数定义"><a href="#JavaScript函数定义" class="headerlink" title="JavaScript函数定义"></a>JavaScript函数定义</h3><p>JS中的方法和Java中的方法定义不太一样，JS中一般称其为函数，我们来看看定义一个函数的格式是什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"有一个人前来买瓜"</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个函数，需要在前面加上<code>function</code>关键字表示这是一个函数，后面跟上函数名称和<code>()</code>，其中可以包含参数，在<code>&#123;&#125;</code>中编写函数代码。我们只需要直接使用函数名+<code>()</code>就能调用函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs js"><code class="language-hljs js">f();<br></code></pre></td></tr></table></figure><p>我们接着来看一下，如何给函数添加形式参数以及返回值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;得到的实参为：&quot;</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>&#125;<br><br>f(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;得到的实参为：&quot;</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>&#125;<br><br>f(<span class="hljs-string">"aa"</span>);<br></code></pre></td></tr></table></figure><p>由于JS是动态类型，因此我们不必指明参数a的类型，同时也不必指明返回值的类型，一个函数可能返回不同类型的结果，因此直接编写return语句即可。同理，我们可以在调用函数时，不传参，那么默认会使用undefined：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;得到的实参为：&quot;</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;得到的实参为：&quot;</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>&#125;<br><br>f();<br></code></pre></td></tr></table></figure><p>那么如果我们希望不传参的时候使用我们自定义的默认值呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a = <span class="hljs-string">&quot;6666&quot;</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;得到的实参为：&quot;</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a = <span class="hljs-string">&quot;6666&quot;</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;得到的实参为：&quot;</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>&#125;<br><br>f();<br></code></pre></td></tr></table></figure><p>我们可以直接在形参后面指定默认值。</p><p>函数本身也是一种类型，他可以被变量接收，所有函数类型的变量，也可以直接被调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a = <span class="hljs-string">&quot;6666&quot;</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;得到的实参为：&quot;</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>&#125;<br><br><span class="hljs-keyword"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a = <span class="hljs-string">&quot;6666&quot;</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;得到的实参为：&quot;</span>+a)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>&#125;<br><br><span class="hljs-keyword">let</span> k = f;<br>k();<br></code></pre></td></tr></table></figure><p>我们也可以直接将匿名函数赋值给变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-keyword">let</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"实参为："</span>+str)<br>&#125;<br></code></pre></td></tr></table></figure><p>既然函数是一种类型，那么函数也能作为一个参数进行传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">test</span>) </span>&#123;<br>    test();<br>&#125;<br><br>f(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">test</span>) </span>&#123;<br>    test();<br>&#125;<br><br>f(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"这是一个匿名函数"</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>对于所有的匿名函数，可以像Java的匿名接口实现一样编写lambda表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">test</span>) </span>&#123;<br>    test();<br>&#125;<br><br>f(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">test</span>) </span>&#123;<br>    test();<br>&#125;<br><br>f(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"可以，不跟你多bb"</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">test</span>) </span>&#123;<br>    test(<span class="hljs-string">&quot;这个是回调参数&quot;</span>);<br>&#125;<br><br>f(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">test</span>) </span>&#123;<br>    test(<span class="hljs-string">&quot;这个是回调参数&quot;</span>);<br>&#125;<br><br>f(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"接受到回调参数："</span>+param)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="JavaScript数组和对象"><a href="#JavaScript数组和对象" class="headerlink" title="JavaScript数组和对象"></a>JavaScript数组和对象</h3><p>JS中的数组定义与Java不同，它更像是Python中的列表，数组中的每个元素并不需要时同样的类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal"><code class="language-hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br></code></pre></td></tr></table></figure><p>我们可以直接使用下标来访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br><span class="hljs-built_in">console</span>.info(arr[<span class="hljs-number"><code class="language-hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br><span class="hljs-built_in">console</span>.info(arr[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>我们一开始编写的排序算法，也是使用了数组。</p><p>数组还可以动态扩容，如果我们尝试访问超出数组长度的元素，并不会出现错误，而是得到undefined，同样的，我们也可以直接往超出数组长度的地方设置元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br>arr[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;???&quot;</span><br><span class="hljs-built_in"><code class="language-hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br>arr[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;???&quot;</span><br><span class="hljs-built_in">console</span>.info(arr)<br></code></pre></td></tr></table></figure><p>也可以使用<code>push</code>和<code>pop</code>来实现栈操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br>arr.push(<span class="hljs-string">&quot;bbb&quot;</span>)<br><span class="hljs-built_in">console</span>.info(arr.pop())<br><span class="hljs-built_in"><code class="language-hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br>arr.push(<span class="hljs-string">&quot;bbb&quot;</span>)<br><span class="hljs-built_in">console</span>.info(arr.pop())<br><span class="hljs-built_in">console</span>.info(arr)<br></code></pre></td></tr></table></figure><p>数组还包括一些其他的方法，这里就不一一列出了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br>arr.fill(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">console</span>.info(arr.map(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string"><code class="language-hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>]<br>arr.fill(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">console</span>.info(arr.map(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;xxx&#x27;</span>+o<br>&#125;))<br></code></pre></td></tr></table></figure><p>我们接着来看对象，JS中也能定义对象，但是这里的对象有点颠覆我们的认知：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br><span class="hljs-keyword"><code class="language-hljs js"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br><span class="hljs-keyword">let</span> obj = &#123;&#125;<br></code></pre></td></tr></table></figure><p>以上两种写法都能够创建一个对象，但是更推荐使用下面的一种。</p><p>JS中的对象也是非常随意的，我们可以动态为其添加属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br>obj.name = <span class="hljs-string">&quot;伞兵一号&quot;</span><br><span class="hljs-built_in"><code class="language-hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br>obj.name = <span class="hljs-string">&quot;伞兵一号&quot;</span><br><span class="hljs-built_in">console</span>.info(obj)<br></code></pre></td></tr></table></figure><p>同理，我们也可以给对象动态添加一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br>obj.f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br>obj.f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"我是对象内部的函数"</span>)<br>&#125;<br><br>obj.f()<br></code></pre></td></tr></table></figure><p>我们可以在函数内使用this关键字来指定对象内的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;我是外部变量&quot;</span><br><span class="hljs-keyword">let</span> obj = &#123;&#125;<br>obj.name = <span class="hljs-string">&quot;我是内部变量&quot;</span><br>obj.f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;name属性为：&quot;</span>+<span class="hljs-built_in"><code class="language-hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;我是外部变量&quot;</span><br><span class="hljs-keyword">let</span> obj = &#123;&#125;<br>obj.name = <span class="hljs-string">&quot;我是内部变量&quot;</span><br>obj.f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;name属性为：&quot;</span>+<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br>obj.f()<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>如果使用lambda表达式，那么this并不会指向对象。</p><p>除了动态添加属性，我们也可以在一开始的时候指定对象内部的成员：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;我是内部的变量&quot;</span>,<br>  <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;name属性为：&quot;</span>+<span class="hljs-built_in"><code class="language-hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;我是内部的变量&quot;</span>,<br>  <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;name属性为：&quot;</span>+<span class="hljs-built_in">this</span>.name)<br>    &#125;<br>&#125;<br><br>obj.f()<br></code></pre></td></tr></table></figure><p>注意如果有多行属性，需要在属性定义后添加一个<code>,</code>进行分割！</p><h3 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a>JavaScript事件</h3><p>当我们点击一个页面中的按钮之后，我们希望之后能够进行登陆操作，或是执行一些JS代码来实现某些功能，那么这个时候，就需要用到事件。</p><p>事件相当于一个通知，我们可以提前设定好事件发生时需要执行的内容，当事件发生时，就会执行我们预先设定好的JS代码。</p><p>事件有很多种类型，其中常用的有：</p><ul><li>onclick：点击事件</li><li>oninput：内容输入事件</li><li>onsubmit：内容提交事件</li></ul><p>那么如何为事件添加一个动作呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string">"console.info(&#x27;正在输入文本&#x27;)"</span>></span><br></code></pre></td></tr></table></figure><p>我们可以直接为一个元素添加对应事件的属性，比如<code>oninput</code>事件，我们可以直接在事件的值中编写js代码，但是注意，只能使用单引号，因为双引号用于囊括整个值。</p><p>我们也可以单独编写一个函数，当事件发生时直接调用我们的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">window</span>.alert(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">"你输入了一个字符"</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string">"oninput()"</span>></span><br></code></pre></td></tr></table></figure><p>仅仅了解了事件，还不足以实现高度自定义，我们接着来看DOM。</p><h3 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h3><p>当网页被加载时，浏览器会创建页面的文档对象模型（<em>D</em>ocument <em>O</em>bject <em>M</em>odel），它将整个页面的所有元素全部映射为JS对象，这样我们就可以在JS中操纵页面中的元素。</p><p><img src="https://www.w3school.com.cn/i/ct_htmltree.gif" alt="DOM HTML 树"></p><p>比如我现在想要读取页面中某个输入框中的内容，那么我们就需要从DOM中获取此输入框元素的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"pwd"</span>).value<br></code></pre></td></tr></table></figure><p>通过document对象就能够快速获取当前页面中对应的元素，并且我们也可以快速获取元素中的一些属性。</p><p>比如现在我们可以结合事件，来进行密码长度的校验，密码长度小于6则不合法，不合法的密码，会让密码框边框变红，那么首先我们先来编写一个css样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-class">.illegal-pwd</span>&#123;<br>    <span class="hljs-attribute">border</span>: red <span class="hljs-number">1px</span> solid <span class="hljs-meta">!important</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number"><code class="language-hljs css"><span class="hljs-selector-class">.illegal-pwd</span>&#123;<br>    <span class="hljs-attribute">border</span>: red <span class="hljs-number">1px</span> solid <span class="hljs-meta">!important</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span> red;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来编写一下js代码，定义一个函数，此函数接受一个参数（元素本身的对象）检测输入的长度是否大于6，否则就将当前元素的class属性设定为css指定的class：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkIllegal</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(e.value.length &lt; <span class="hljs-number">6</span>) &#123;<br>        e.setAttribute(<span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;illegal-pwd&quot;</span>)   <br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        e.removeAttribute(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkIllegal</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(e.value.length &lt; <span class="hljs-number">6</span>) &#123;<br>        e.setAttribute(<span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;illegal-pwd&quot;</span>)   <br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        e.removeAttribute(<span class="hljs-string">"class"</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们将此函数绑定到<code>oninput</code>事件即可，注意传入了一个this，这里的this代表的是输入框元素本身：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string">&quot;checkIllegal(this)&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string">&quot;checkIllegal(this)&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span>></span><br></code></pre></td></tr></table></figure><p>现在我们在输入的时候，会自动检查密码是否合法。</p><p>既然oninput本身也是一个属性，那么实际上我们可以动态进行修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;pwd&quot;</span>).oninput = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.info(<span class="hljs-string"><code class="language-hljs js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;pwd&quot;</span>).oninput = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"???"</span>)<br></code></pre></td></tr></table></figure><p>那么，我们前面提及的window对象又是什么东西呢？</p><p>实际上Window对象范围更加广阔，它甚至直接代表了整个窗口，当然也包含我们的Document对象，我们一般通过Window对象来弹出提示框之类的东西。</p><h3 id="发送XHR请求"><a href="#发送XHR请求" class="headerlink" title="发送XHR请求"></a>发送XHR请求</h3><p>JS的大致内容我们已经全部学习完成了，那么如何使用JS与后端进行交互呢？</p><p>我们知道，如果我们需要提交表单，那么我们就需要将表单的信息全部发送给我们的服务器，那么，如何发送给服务器呢？</p><p>通过使用XMLHttpRequest对象，来向服务器发送一个HTTP请求，下面是一个最简单的请求格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string"><code class="language-hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>);<br>xhr.send();<br></code></pre></td></tr></table></figure><p>上面的例子中，我们向服务器发起了一次网络请求，但是我们请求的是百度的服务器，并且此请求的方法为GET请求。</p><p>我们现在将其绑定到一个按钮上作为事件触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">http</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">http</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>);<br>    xhr.send();    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"http()"</span>></span><br></code></pre></td></tr></table></figure><p>我们可以在网络中查看我们发起的HTTP请求并且查看请求的响应结果，比如上面的请求，会返回百度这个页面的全部HTML代码。</p><p>实际上，我们的浏览器在我们输入网址后，也会向对应网站的服务器发起一次HTTP的GET请求。</p><p>在浏览器得到页面响应后，会加载当前页面，如果当前页面还引用了其他资源文件，那么会继续向服务器发起请求，直到页面中所有的资源文件全部加载完成后，才会停止。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/16/3.html/"/>
      <url>/2022/03/16/3.html/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb后端"><a href="#JavaWeb后端" class="headerlink" title="JavaWeb后端"></a>JavaWeb后端</h1><p>经过前面的学习，现在终于可以正式进入到后端的学习当中，不过，我们还是需要再系统地讲解一下HTTP通信基础知识，它是我们学习JavaWeb的基础知识，我们之前已经学习过TCP通信，而HTTP实际上是基于TCP协议之上的应用层协议，因此理解它并不难理解。</p><p>打好基础是关键！为什么要去花费时间来讲解计算机网络基础，我们学习一门技术，如果仅仅是知道如何使用却不知道其原理，那么就成了彻头彻尾的“码农”，只知道搬运代码实现功能，却不知道这行代码的执行流程，在遇到一些问题的时候就不知道如何解决，无论是知识层面还是应用层面都得不到提升。</p><p>无论怎么样，我们都要明确，我们学习JavaWeb的最终目的是为了搭建一个网站，并且让用户能访问我们的网站并在我们的网站上做一些事情。</p><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><p>在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的：</p><blockquote><p> 万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称<code>Web</code>，万维网用**<u>链接</u>**的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。</p></blockquote><p>这句话说的非常官方，但是也蕴藏着许多的信息，首先它指明，我们的互联网上存在许许多多的服务器，而我们通过访问这些服务器就能快速获取服务器为我们提供的信息（比如打开百度就能展示搜索、打开小破站能刷视频、打开微博能查看实时热点）而这些服务器就是由不同的公司在运营。</p><p>其次，我们通过浏览器，只需要输入对应的网址或是点击页面中的一个链接，就能够快速地跳转到另一个页面，从而按我们的意愿来访问服务器。</p><p>而书中是这样描述万维网的工作方式：</p><blockquote><p>万维网以客户服务器的方式工作，浏览器就是安装在用户主机上的万维网客户程序，万维网文档所驻留的主机则运行服务器程序，因此这台主机也称为万维网服务器。<strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong>，在一个客户程序主窗口上显示出的万维网文档称为页面。</p></blockquote><p>上面提到的客户程序其实就是我们电脑上安装的浏览器，而服务端就是我们即将要去学习的Web服务器，也就是说，我们要明白如何搭建一个Web服务器并向用户发送我们提供的Web页面，在浏览器中显示的，一般就是HTML文档被解析后的样子。</p><p>那么，我们的服务器可能不止一个页面，可能会有很多个页面，那么客户端如何知道该去访问哪个服务器的哪个页面呢？这个时候就需要用到<code>URL</code>统一资源定位符。互联网上所有的资源，都有一个唯一确定的URL，比如<code>http://www.baidu.com</code></p><p>URL的格式为：</p><blockquote><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>协议是指采用什么协议来访问服务器，不同的协议决定了服务器返回信息的格式，我们一般使用HTTP协议。</p><p>主机可以是一个域名，也可以是一个IP地址（实际上域名最后会被解析为IP地址进行访问）</p><p>端口是当前服务器上Web应用程序开启的端口，我们前面学习TCP通信的时候已经介绍过了，HTTP协议默认使用80端口，因此有时候可以省略。</p><p>路径就是我们希望去访问此服务器上的某个文件，不同的路径代表访问不同的资源。</p></blockquote><p>我们接着来了解一下什么是HTTP协议：</p><blockquote><p>HTTP是面向事务的应用层协议，它是万维网上能够可靠交换文件的重要基础。HTTP不仅传送完成超文本跳转所需的必须信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像。</p></blockquote><p>实际上我们之前访问百度、访问自己的网站，所有的传输都是以HTTP作为协议进行的。</p><p>我们来看看HTTP的传输原理：</p><blockquote><p>HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。HTTP不必考虑数据在传输过程中被丢弃后又怎样被重传。但是HTTP协议本身是无连接的。也就是说，HTTP虽然使用了TCP连接，但是通信的双方在交换HTTP报文之前不需要先建立HTTP连接。1997年以前使用的是HTTP/1.0协议，之后就是HTTP/1.1协议了。</p></blockquote><p>那么既然HTTP是基于TCP进行通信的，我们首先来回顾一下TCP的通信原理：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fstatic.oschina.net%2Fuploads%2Fspace%2F2016%2F0407%2F144257_WTql_2537915.jpg&refer=http%3A%2F%2Fstatic.oschina.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640244422&t=e2c991d149b7ae79d3baa7868633f4d6" alt="点击查看源网页"></p><p>TCP协议实际上是经历了三次握手再进行通信，也就是说保证整个通信是稳定的，才可以进行数据交换，并且在连接已经建立的过程中，双方随时可以互相发送数据，直到有一方主动关闭连接，这时在进行四次挥手，完成整个TCP通信。</p><p>而HTTP和TCP并不是一个层次的通信协议，TCP是传输层协议，而HTTP是应用层协议，因此，实际上HTTP的内容会作为TCP协议的报文被封装，并继续向下一层进行传递，而传输到客户端时，会依次进行解包，还原为最开始的HTTP数据。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.edatop.com%2Ftech%2Fimages%2Fefans%2Fmcu%2Fmcu-257524hyx0ez3djs.png&refer=http%3A%2F%2Fwww.edatop.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640244335&t=b0e3e66fdac9f66ab64262a725e041f8" alt="点击查看源网页"></p><p>HTTP使用TCP协议是为了使得数据传输更加可靠，既然它是依靠TCP协议进行数据传输，那么为什么说它本身是无连接的呢？我们来看一下HTTP的传输过程：</p><blockquote><p>用户在点击鼠标链接某个万维网文档时，HTTP协议首先要和服务器建立TCP连接。这需要使用三报文握手。当建立TCP连接的三报文握手的前两部分完成后（即经过了一个RTT时间后），万维网客户就把HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。</p></blockquote><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F323%2F7b19a0d1acac11f91ba549001758a393.png&refer=http%3A%2F%2Fwww.pianshen.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640245028&t=bb9d88a42c52313924edc8a7d937cbf8" alt="点击查看源网页"></p><p>因此，我们的浏览器请求一个页面，需要两倍的往返时间。</p><p>最后，我们再来了解一下HTTP的报文结构：</p><p><img src="https://img2.baidu.com/it/u=1539060868,3030092954&fm=26&fmt=auto" alt="img"></p><p>由客户端向服务端发送是报文称为请求报文，而服务端返回给客户端的称为响应报文，实际上，整个报文全部是以文本形式发送的，通过使用空格和换行来完成分段。</p><p>现在，我们已经了解了HTTP协议的全部基础知识，那么什么是Web服务器呢，实际上，它就是一个软件，但是它已经封装了所有的HTTP协议层面的操作，我们无需关心如何使用HTTP协议通信，而是直接基于服务器软件进行开发，我们只需要关心我们的页面数据如何展示、前后端如何交互即可。</p><h2 id="认识Tomcat服务器"><a href="#认识Tomcat服务器" class="headerlink" title="认识Tomcat服务器"></a>认识Tomcat服务器</h2><p><a href="http://tomcat.apache.org/"><img src="https://tomcat.apache.org/res/images/tomcat.png" alt="Tomcat Home"></a></p><p>Tomcat（汤姆猫）就是一个典型的Web应用服务器软件，通过运行Tomcat服务器，我们就可以快速部署我们的Web项目，并交由Tomcat进行管理，我们只需要直接通过浏览器访问我们的项目即可。</p><p>那么首先，我们需要进行一个简单的环境搭建，我们需要在Tomcat官网下载最新的Tomcat服务端程序：<a href="https://tomcat.apache.org/download-10.cgi%EF%BC%88%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%8F%AF%E8%83%BD%E6%9C%89%E7%82%B9%E6%85%A2%EF%BC%89">https://tomcat.apache.org/download-10.cgi（下载速度可能有点慢）</a></p><ul><li>下载：64-bit Windows zip</li></ul><p>下载完成后，解压，并放入桌面，接下来需要配置一下环境变量，打开<code>高级系统设置</code>，打开<code>环境变量</code>，添加一个新的系统变量，变量名称为<code>JRE_HOME</code>，填写JDK的安装目录+/jre，比如Zulujdk默认就是：C:\Program Files\Zulu\zulu-8\jre</p><p>设置完成后，我们进入tomcat文件夹bin目录下，并在当前位置打开CMD窗口，将startup.sh拖入窗口按回车运行，如果环境变量配置有误，会提示，若没问题，服务器则正常启动。</p><p>如果出现乱码，说明编码格式配置有问题，我们修改一下服务器的配置文件，打开<code>conf</code>文件夹，找到<code>logging.properties</code>文件，这就是日志的配置文件（我们在前面已经给大家讲解过了）将ConsoleHandler的默认编码格式修改为GBK编码格式：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-meta">java.util.logging.ConsoleHandler.encoding</span> = <span class="hljs-string"><code class="language-hljs properties"><span class="hljs-meta">java.util.logging.ConsoleHandler.encoding</span> = <span class="hljs-string">GBK</span><br></code></pre></td></tr></table></figure><p>现在重新启动服务器，就可以正常显示中文了。</p><p>服务器启动成功之后，不要关闭，我们打开浏览器，在浏览器中访问：<a href="http://localhost:8080/%EF%BC%8CTomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%BB%98%E8%AE%A4%E6%98%AF%E4%BD%BF%E7%94%A88080%E7%AB%AF%E5%8F%A3%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BF%AE%E6%94%B9%EF%BC%89%EF%BC%8C%E8%AE%BF%E9%97%AE%E6%88%90%E5%8A%9F%E8%AF%B4%E6%98%8E%E6%88%91%E4%BB%AC%E7%9A%84Tomcat%E7%8E%AF%E5%A2%83%E5%B7%B2%E7%BB%8F%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F%E4%BA%86%E3%80%82">http://localhost:8080/，Tomcat服务器默认是使用8080端口（可以在配置文件中修改），访问成功说明我们的Tomcat环境已经部署成功了。</a></p><p>整个Tomcat目录下，我们已经认识了bin目录（所有可执行文件，包括启动和关闭服务器的脚本）以及conf目录（服务器配置文件目录），那么我们接着来看其他的文件夹：</p><ul><li>lib目录：Tomcat服务端运行的一些依赖，不用关心。</li><li>logs目录：所有的日志信息都在这里。</li><li>temp目录：存放运行时产生的一些临时文件，不用关心。</li><li>work目录：工作目录，Tomcat会将jsp文件转换为java文件（我们后面会讲到，这里暂时不提及）</li><li>webapp目录：所有的Web项目都在这里，每个文件夹都是一个Web应用程序：</li></ul><p>我们发现，官方已经给我们预设了一些项目了，访问后默认使用的项目为ROOT项目，也就是我们默认打开的网站。</p><p>我们也可以访问example项目，只需要在后面填写路径即可：<a href="http://localhost:8080/examples/%EF%BC%8C%E6%88%96%E6%98%AFdocs%E9%A1%B9%E7%9B%AE%EF%BC%88%E8%BF%99%E4%B8%AA%E6%98%AFTomcat%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%87%E6%A1%A3%EF%BC%89http://localhost:8080/docs/">http://localhost:8080/examples/，或是docs项目（这个是Tomcat的一些文档）http://localhost:8080/docs/</a></p><p>Tomcat还自带管理页面，我们打开：<a href="http://localhost:8080/manager%EF%BC%8C%E6%8F%90%E7%A4%BA%E9%9C%80%E8%A6%81%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%EF%BC%8C%E7%94%B1%E4%BA%8E%E4%B8%8D%E7%9F%A5%E9%81%93%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%88%91%E4%BB%AC%E5%85%88%E7%82%B9%E5%87%BB%E5%8F%96%E6%B6%88%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%87%BA%E7%8E%B0%E5%A6%82%E4%B8%8B%E5%86%85%E5%AE%B9%EF%BC%9A">http://localhost:8080/manager，提示需要用户名和密码，由于不知道是什么，我们先点击取消，页面中出现如下内容：</a></p><blockquote><p>You are not authorized to view this page. If you have not changed any configuration files, please examine the file <code>conf/tomcat-users.xml</code> in your installation. That file must contain the credentials to let you use this webapp.</p><p>For example, to add the <code>manager-gui</code> role to a user named <code>tomcat</code> with a password of <code>s3cret</code>, add the following to the config file listed above.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs routeros">&lt;role <span class="hljs-attribute">rolename</span>=<span class="hljs-string">&quot;manager-gui&quot;</span>/&gt;<br>&lt;user <span class="hljs-attribute">username</span>=<span class="hljs-string">&quot;tomcat&quot;</span> <span class="hljs-attribute">password</span>=<span class="hljs-string">&quot;s3cret&quot;</span> <span class="hljs-attribute">roles</span>=<span class="hljs-string"><code class="language-hljs routeros">&lt;role <span class="hljs-attribute">rolename</span>=<span class="hljs-string">&quot;manager-gui&quot;</span>/&gt;<br>&lt;user <span class="hljs-attribute">username</span>=<span class="hljs-string">&quot;tomcat&quot;</span> <span class="hljs-attribute">password</span>=<span class="hljs-string">&quot;s3cret&quot;</span> <span class="hljs-attribute">roles</span>=<span class="hljs-string">"manager-gui"</span>/><br></code></pre></td></tr></table></figure><p>Note that for Tomcat 7 onwards, the roles required to use the manager application were changed from the single <code>manager</code> role to the following four roles. You will need to assign the role(s) required for the functionality you wish to access.</p><ul><li><code>manager-gui</code> - allows access to the HTML GUI and the status pages</li><li><code>manager-script</code> - allows access to the text interface and the status pages</li><li><code>manager-jmx</code> - allows access to the JMX proxy and the status pages</li><li><code>manager-status</code> - allows access to the status pages only</li></ul><p>The HTML interface is protected against CSRF but the text and JMX interfaces are not. To maintain the CSRF protection:</p><ul><li>Users with the <code>manager-gui</code> role should not be granted either the <code>manager-script</code> or <code>manager-jmx</code> roles.</li><li>If the text or jmx interfaces are accessed through a browser (e.g. for testing since these interfaces are intended for tools not humans) then the browser must be closed afterwards to terminate the session.</li></ul><p>For more information - please see the <a href="http://localhost:8080/docs/manager-howto.html">Manager App How-To</a>.</p></blockquote><p>现在我们按照上面的提示，去配置文件中进行修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-gui&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-attr">roles</span>=<span class="hljs-string"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-gui&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">"manager-gui"</span>/></span><br></code></pre></td></tr></table></figure><p>现在再次打开管理页面，已经可以成功使用此用户进行登陆了。登录后，展示给我们的是一个图形化界面，我们可以快速预览当前服务器的一些信息，包括已经在运行的Web应用程序，甚至还可以查看当前的Web应用程序有没有出现内存泄露。</p><p>同样的，还有一个虚拟主机管理页面，用于一台主机搭建多个Web站点，一般情况下使用不到，这里就不做演示了。</p><p>我们可以将我们自己的项目也放到webapp文件夹中，这样就可以直接访问到了，我们在webapp目录下新建test文件夹，将我们之前编写的前端代码全部放入其中（包括html文件、js、css、icon等），重启服务器。</p><p>我们可以直接通过 <a href="http://localhost:8080/test/">http://localhost:8080/test/</a> 来进行访问。</p><hr><h2 id="使用Maven创建Web项目"><a href="#使用Maven创建Web项目" class="headerlink" title="使用Maven创建Web项目"></a>使用Maven创建Web项目</h2><p>虽然我们已经可以在Tomcat上部署我们的前端页面了，但是依然只是一个静态页面（每次访问都是同样的样子），那么如何向服务器请求一个动态的页面呢（比如显示我们访问当前页面的时间）这时就需要我们编写一个Web应用程序来实现了，我们需要在用户向服务器发起页面请求时，进行一些处理，再将结果发送给用户的浏览器。</p><p><strong>注意：</strong>这里需要使用终极版IDEA，如果你的还是社区版，就很难受了。</p><p>我们打开IDEA，新建一个项目，选择Java Enterprise（社区版没有此选项！）项目名称随便，项目模板选择Web应用程序，然后我们需要配置Web应用程序服务器，将我们的Tomcat服务器集成到IDEA中。配置很简单，首先点击新建，然后设置Tomcat主目录即可，配置完成后，点击下一步即可，依赖项使用默认即可，然后点击完成，之后IDEA会自动帮助我们创建Maven项目。</p><p>创建完成后，直接点击右上角即可运行此项目了，但是我们发现，有一个Servlet页面不生效。</p><p>需要注意的是，Tomcat10以上的版本比较新，Servlet API包名发生了一些变化，因此我们需要修改一下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>注意包名全部从javax改为jakarta，我们需要手动修改一下。</p><p>感兴趣的可以了解一下为什么名称被修改了：</p><blockquote><p>Eclipse基金会在2019年对 Java EE 标准的每个规范进行了重命名，阐明了每个规范在Jakarta EE平台未来的角色。</p><p>新的名称Jakarta EE是Java EE的第二次重命名。2006年5月，“J2EE”一词被弃用，并选择了Java EE这个名称。在YouTube还只是一家独立的公司的时候，数字2就就从名字中消失了，而且当时冥王星仍然被认为是一颗行星。同样，作为Java SE 5（2004）的一部分，数字2也从J2SE中删除了，那时谷歌还没有上市。</p><p><strong>因为不能再使用javax名称空间，Jakarta EE提供了非常明显的分界线。</strong></p><ul><li>Jakarta 9（2019及以后）使用jakarta命名空间。</li><li>Java EE 5（2005）到Java EE 8（2017）使用javax命名空间。</li><li>Java EE 4使用javax命名空间。</li></ul></blockquote><p>我们可以将项目直接打包为war包（默认），打包好之后，放入webapp文件夹，就可以直接运行我们通过Java编写的Web应用程序了，访问路径为文件的名称。</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>前面我们已经完成了基本的环境搭建，那么现在我们就可以开始来了解我们的第一个重要类——Servlet。</p><p>它是Java EE的一个标准，大部分的Web服务器都支持此标准，包括Tomcat，就像之前的JDBC一样，由官方定义了一系列接口，而具体实现由我们来编写，最后交给Web服务器（如Tomcat）来运行我们编写的Servlet。</p><p>那么，它能做什么呢？我们可以通过实现Servlet来进行动态网页响应，使用Servlet，不再是直接由Tomcat服务器发送我们编写好的静态网页内容（HTML文件），而是由我们通过Java代码进行动态拼接的结果，它能够很好地实现动态网页的返回。</p><p>当然，Servlet并不是专用于HTTP协议通信，也可以用于其他的通信，但是一般都是用于HTTP。</p><h3 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h3><p>那么如何创建一个Servlet呢，非常简单，我们只需要实现<code>Servlet</code>类即可，并添加注解<code>@WebServlet</code>来进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@WebServlet(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-meta">@WebServlet(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>&#123;<br>...实现接口方法<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在就可以去访问一下我们的页面：<a href="http://localhost:8080/test/test">http://localhost:8080/test/test</a></p><p>我们发现，直接访问此页面是没有任何内容的，这是因为我们还没有为该请求方法编写实现，这里先不做讲解，后面我们会对浏览器的请求处理做详细的介绍。</p><p>除了直接编写一个类，我们也可以在<code>web.xml</code>中进行注册，现将类上<code>@WebServlet</code>的注解去掉：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.example.webtest.TestServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/test<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.example.webtest.TestServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/test<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>></span><br></code></pre></td></tr></table></figure><p>这样的方式也能注册Servlet，但是显然直接使用注解更加方便，因此之后我们一律使用注解进行开发。只有比较新的版本才支持此注解，老的版本是不支持的哦。</p><p>实际上，Tomcat服务器会为我们提供一些默认的Servlet，也就是说在服务器启动后，即使我们什么都不编写，Tomcat也自带了几个默认的Servlet，他们编写在conf目录下的web.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-comment">&lt;!-- The mapping for the default servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-comment">&lt;!-- The mapping for the default servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>></span><br><br></code></pre></td></tr></table></figure><p>我们发现，默认的Servlet实际上可以帮助我们去访问一些静态资源，这也是为什么我们启动Tomcat服务器之后，能够直接访问webapp目录下的静态页面。</p><p>我们可以将之前编写的页面放入到webapp目录下，来测试一下是否能直接访问。</p><h3 id="探究Servlet的生命周期"><a href="#探究Servlet的生命周期" class="headerlink" title="探究Servlet的生命周期"></a>探究Servlet的生命周期</h3><p>我们已经了解了如何注册一个Servlet，那么我们接着来看看，一个Servlet是如何运行的。</p><p>首先我们需要了解，Servlet中的方法各自是在什么时候被调用的，我们先编写一个打印语句来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestServlet</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是构造方法！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是init&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是getServletConfig&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是service&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是getServletInfo&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestServlet</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是构造方法！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是init&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是getServletConfig&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是service&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是getServletInfo&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"我是destroy"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先启动一次服务器，然后访问我们定义的页面，然后再关闭服务器，得到如下的顺序：</p><blockquote><p>我是构造方法！<br>我是init<br>我是service<br>我是service（出现两次是因为浏览器请求了2次，是因为有一次是请求favicon.ico，浏览器通病）</p><p>我是destroy</p></blockquote><p>我们可以多次尝试去访问此页面，但是init和构造方法只会执行一次，而每次访问都会执行的是<code>service</code>方法，因此，一个Servlet的生命周期为：</p><ul><li>首先执行构造方法完成 Servlet 初始化</li><li>Servlet 初始化后调用 <strong>init ()</strong> 方法。</li><li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li><li>Servlet 销毁前调用 <strong>destroy()</strong> 方法。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><p>现在我们发现，实际上在Web应用程序运行时，每当浏览器向服务器发起一个请求时，都会创建一个线程执行一次<code>service</code>方法，来让我们处理用户的请求，并将结果响应给用户。</p><p>我们发现<code>service</code>方法中，还有两个参数，<code>ServletRequest</code>和<code>ServletResponse</code>，实际上，用户发起的HTTP请求，就被Tomcat服务器封装为了一个<code>ServletRequest</code>对象，我们得到是其实是Tomcat服务器帮助我们创建的一个实现类，HTTP请求报文中的所有内容，都可以从<code>ServletRequest</code>对象中获取，同理，<code>ServletResponse</code>就是我们需要返回给浏览器的HTTP响应报文实体类封装。</p><p>那么我们来看看<code>ServletRequest</code>中有哪些内容，我们可以获取请求的一些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-comment">//首先将其转换为HttpServletRequest（继承自ServletRequest，一般是此接口实现）</span><br>        HttpServletRequest request = (HttpServletRequest) servletRequest;<br>        <br>        System.out.println(request.getProtocol());  <span class="hljs-comment">//获取协议版本</span><br>        System.out.println(request.getRemoteAddr());  <span class="hljs-comment">//获取访问者的IP地址</span><br>    System.out.println(request.getMethod());   <span class="hljs-comment">//获取请求方法</span><br>        <span class="hljs-comment">//获取头部信息</span><br>        Enumeration&lt;String&gt; enumeration = request.getHeaderNames();<br>        <span class="hljs-keyword">while</span> (enumeration.hasMoreElements())&#123;<br>            String name = enumeration.nextElement();<br>            System.out.println(name + <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-comment">//首先将其转换为HttpServletRequest（继承自ServletRequest，一般是此接口实现）</span><br>        HttpServletRequest request = (HttpServletRequest) servletRequest;<br>        <br>        System.out.println(request.getProtocol());  <span class="hljs-comment">//获取协议版本</span><br>        System.out.println(request.getRemoteAddr());  <span class="hljs-comment">//获取访问者的IP地址</span><br>    System.out.println(request.getMethod());   <span class="hljs-comment">//获取请求方法</span><br>        <span class="hljs-comment">//获取头部信息</span><br>        Enumeration&lt;String&gt; enumeration = request.getHeaderNames();<br>        <span class="hljs-keyword">while</span> (enumeration.hasMoreElements())&#123;<br>            String name = enumeration.nextElement();<br>            System.out.println(name + <span class="hljs-string">": "</span> + request.getHeader(name));<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，整个HTTP请求报文中的所有内容，都可以通过<code>HttpServletRequest</code>对象来获取，当然，它的作用肯定不仅仅是获取头部信息，我们还可以使用它来完成更多操作，后面会一一讲解。</p><p>那么我们再来看看<code>ServletResponse</code>，这个是服务端的响应内容，我们可以在这里填写我们想要发送给浏览器显示的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//转换为HttpServletResponse（同上）</span><br>HttpServletResponse response = (HttpServletResponse) servletResponse;<br><span class="hljs-comment">//设定内容类型以及编码格式（普通HTML文本使用text/html，之后会讲解文件传输）</span><br>response.setHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br><span class="hljs-comment">//获取Writer直接写入内容</span><br>response.getWriter().write(<span class="hljs-string">&quot;我是响应内容！&quot;</span>);<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//转换为HttpServletResponse（同上）</span><br>HttpServletResponse response = (HttpServletResponse) servletResponse;<br><span class="hljs-comment">//设定内容类型以及编码格式（普通HTML文本使用text/html，之后会讲解文件传输）</span><br>response.setHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br><span class="hljs-comment">//获取Writer直接写入内容</span><br>response.getWriter().write(<span class="hljs-string">&quot;我是响应内容！&quot;</span>);<br><span class="hljs-comment">//所有内容写入完成之后，再发送给浏览器</span><br></code></pre></td></tr></table></figure><p>现在我们在浏览器中打开此页面，就能够收到服务器发来的响应内容了。其中，响应头部分，是由Tomcat帮助我们生成的一个默认响应头。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.qingruanit.net%2FcatchImages%2F20170218%2F1487385940733020268.png&refer=http%3A%2F%2Fwww.qingruanit.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640328590&t=27d773847d13c6ac21c270379dc25717" alt="点击查看源网页"></p><p>因此，实际上整个流程就已经很清晰明了了。</p><h3 id="解读和使用HttpServlet"><a href="#解读和使用HttpServlet" class="headerlink" title="解读和使用HttpServlet"></a>解读和使用HttpServlet</h3><p>前面我们已经学习了如何创建、注册和使用Servlet，那么我们继续来深入学习Servlet接口的一些实现类。</p><p>首先<code>Servlet</code>有一个直接实现抽象类<code>GenericServlet</code>，那么我们来看看此类做了什么事情。</p><p>我们发现，这个类完善了配置文件读取和Servlet信息相关的的操作，但是依然没有去实现service方法，因此此类仅仅是用于完善一个Servlet的基本操作，那么我们接着来看<code>HttpServlet</code>，它是遵循HTTP协议的一种Servlet，继承自<code>GenericServlet</code>，它根据HTTP协议的规则，完善了service方法。</p><p>在阅读了HttpServlet源码之后，我们发现，其实我们只需要继承HttpServlet来编写我们的Servlet就可以了，并且它已经帮助我们提前实现了一些操作，这样就会给我们省去很多的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string">"<h1>恭喜你解锁了全新玩法</h1>"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们只需要重写对应的请求方式，就可以快速完成Servlet的编写。</p><h3 id="WebServlet注解详解"><a href="#WebServlet注解详解" class="headerlink" title="@WebServlet注解详解"></a>@WebServlet注解详解</h3><p>我们接着来看WebServlet注解，我们前面已经得知，可以直接使用此注解来快速注册一个Servlet，那么我们来想细看看此注解还有什么其他的玩法。</p><p>首先name属性就是Servlet名称，而urlPatterns和value实际上是同样功能，就是代表当前Servlet的访问路径，它不仅仅可以是一个固定值，还可以进行通配符匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@WebServlet("/test/*")</span><br></code></pre></td></tr></table></figure><p>上面的路径表示，所有匹配<code>/test/随便什么</code>的路径名称，都可以访问此Servlet，我们可以在浏览器中尝试一下。</p><p>也可以进行某个扩展名称的匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@WebServlet("*.js")</span><br></code></pre></td></tr></table></figure><p>这样的话，获取任何以js结尾的文件，都会由我们自己定义的Servlet处理。</p><p>那么如果我们的路径为<code>/</code>呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@WebServlet("/")</span><br></code></pre></td></tr></table></figure><p>此路径和Tomcat默认为我们提供的Servlet冲突，会直接替换掉默认的，而使用我们的，此路径的意思为，如果没有找到匹配当前访问路径的Servlet，那么久会使用此Servlet进行处理。</p><p>我们还可以为一个Servlet配置多个访问路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@WebServlet(&#123;"/test1", "/test2"&#125;)</span><br></code></pre></td></tr></table></figure><p>我们接着来看loadOnStartup属性，此属性决定了是否在Tomcat启动时就加载此Servlet，默认情况下，Servlet只有在被访问时才会加载，它的默认值为-1，表示不在启动时加载，我们可以将其修改为大于等于0的数，来开启启动时加载。并且数字的大小决定了此Servlet的启动优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet(value = &quot;/test&quot;, loadOnStartup = 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        <span class="hljs-keyword">super</span>.init();<br>        log.info(<span class="hljs-string">&quot;我被初始化了！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet(value = &quot;/test&quot;, loadOnStartup = 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        <span class="hljs-keyword">super</span>.init();<br>        log.info(<span class="hljs-string">&quot;我被初始化了！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string">"<h1>恭喜你解锁了全新玩法</h1>"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他内容都是Servlet的一些基本配置，这里就不详细讲解了。</p><h3 id="使用POST请求完成登陆"><a href="#使用POST请求完成登陆" class="headerlink" title="使用POST请求完成登陆"></a>使用POST请求完成登陆</h3><p>我们前面已经了解了如何使用Servlet来处理HTTP请求，那么现在，我们就结合前端，来实现一下登陆操作。</p><p>我们需要修改一下我们的Servlet，现在我们要让其能够接收一个POST请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        req.getParameterMap().forEach((k, v) -&gt; &#123;<br>            System.out.println(k + <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        req.getParameterMap().forEach((k, v) -&gt; &#123;<br>            System.out.println(k + <span class="hljs-string">": "</span> + Arrays.toString(v));<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ParameterMap</code>存储了我们发送的POST请求所携带的表单数据，我们可以直接将其遍历查看，浏览器发送了什么数据。</p><p>现在我们再来修改一下前端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录到系统<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;用户名&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;密码&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录到系统<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;用户名&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;密码&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>></span><br></code></pre></td></tr></table></figure><p>通过修改form标签的属性，现在我们点击登录按钮，会自动向后台发送一个POST请求，请求地址为当前地址+/login（注意不同路径的写法），也就是我们上面编写的Servlet路径。</p><p>运行服务器，测试后发现，在点击按钮后，确实向服务器发起了一个POST请求，并且携带了表单中文本框的数据。</p><p>现在，我们根据已有的基础，将其与数据库打通，我们进行一个真正的用户登录操作，首先修改一下Servlet的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-comment">//首先设置一下响应类型</span><br>    resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>    <span class="hljs-comment">//获取POST请求携带的表单数据</span><br>    Map&lt;String, String[]&gt; map = req.getParameterMap();<br>    <span class="hljs-comment">//判断表单是否完整</span><br>    <span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-string">&quot;username&quot;</span>) &amp;&amp; map.containsKey(<span class="hljs-string">&quot;password&quot;</span>)) &#123;<br>        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br><br>        <span class="hljs-comment">//权限校验（待完善）</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        resp.getWriter().write(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-comment">//首先设置一下响应类型</span><br>    resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>    <span class="hljs-comment">//获取POST请求携带的表单数据</span><br>    Map&lt;String, String[]&gt; map = req.getParameterMap();<br>    <span class="hljs-comment">//判断表单是否完整</span><br>    <span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-string">&quot;username&quot;</span>) &amp;&amp; map.containsKey(<span class="hljs-string">&quot;password&quot;</span>)) &#123;<br>        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br><br>        <span class="hljs-comment">//权限校验（待完善）</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        resp.getWriter().write(<span class="hljs-string">"错误，您的表单数据不完整！"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们再去编写Mybatis的依赖和配置文件，创建一个表，用于存放我们用户的账号和密码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;驱动类（含包名）&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;数据库连接URL&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;用户名&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;密码&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;驱动类（含包名）&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;数据库连接URL&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;用户名&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;密码&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>></span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>配置完成后，在我们的Servlet的init方法中编写Mybatis初始化代码，因为它只需要初始化一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java">SqlSessionFactory factory;<br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>    factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsReader(<span class="hljs-string"><code class="language-hljs java">SqlSessionFactory factory;<br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>    factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(Resources.getResourceAsReader(<span class="hljs-string">"mybatis-config.xml"</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们创建一个实体类以及Mapper来进行用户信息查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username, <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username, <span class="hljs-meta">@Param("password")</span> String password)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.dao.UserMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.dao.UserMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>></span><br></code></pre></td></tr></table></figure><p>好了，现在完事具备，只欠东风了，我们来完善一下登陆验证逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//登陆校验（待完善）</span><br><span class="hljs-keyword">try</span> (SqlSession sqlSession = factory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>    UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>    User user = mapper.getUser(username, password);<br>    <span class="hljs-comment">//判断用户是否登陆成功，若查询到信息则表示存在此用户</span><br>    <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>)&#123;<br>        resp.getWriter().write(<span class="hljs-string">&quot;登陆成功！&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        resp.getWriter().write(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-comment">//登陆校验（待完善）</span><br><span class="hljs-keyword">try</span> (SqlSession sqlSession = factory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>    UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>    User user = mapper.getUser(username, password);<br>    <span class="hljs-comment">//判断用户是否登陆成功，若查询到信息则表示存在此用户</span><br>    <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>)&#123;<br>        resp.getWriter().write(<span class="hljs-string">&quot;登陆成功！&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        resp.getWriter().write(<span class="hljs-string">"登陆失败，请验证您的用户名或密码！"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在再去浏览器上进行测试吧！</p><p>注册界面其实是同理的，这里就不多做讲解了。</p><h3 id="上传和下载文件"><a href="#上传和下载文件" class="headerlink" title="上传和下载文件"></a>上传和下载文件</h3><p>首先我们来看看比较简单的下载文件，首先将我们的icon.png放入到resource文件夹中，接着我们编写一个Servlet用于处理文件下载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@WebServlet(&quot;/file&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>      resp.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);  <br>      OutputStream outputStream = resp.getOutputStream();<br>      InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@WebServlet(&quot;/file&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>      resp.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);  <br>      OutputStream outputStream = resp.getOutputStream();<br>      InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">"icon.png"</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更加快速地编写IO代码，我们可以引入一个工具库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>使用此类库可以快速完成IO操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">resp.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);<br>OutputStream outputStream = resp.getOutputStream();<br>InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">&quot;icon.png&quot;</span>);<br><span class="hljs-comment"><code class="language-hljs java">resp.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);<br>OutputStream outputStream = resp.getOutputStream();<br>InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">&quot;icon.png&quot;</span>);<br><span class="hljs-comment">//直接使用copy方法完成转换</span><br>IOUtils.copy(inputStream, outputStream);<br></code></pre></td></tr></table></figure><p>现在我们在前端页面添加一个链接，用于下载此文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;icon.png&quot;</span>&gt;</span>点我下载高清资源<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;icon.png&quot;</span>&gt;</span>点我下载高清资源<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>></span><br></code></pre></td></tr></table></figure><p>下载文件搞定，那么如何上传一个文件呢？</p><p>首先我们编写前端部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test-file&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test-file&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>></span><br></code></pre></td></tr></table></figure><p>注意必须添加<code>enctype=&quot;multipart/form-data&quot;</code>，来表示此表单用于文件传输。</p><p>现在我们来修改一下Servlet代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@MultipartConfig</span><br><span class="hljs-meta">@WebServlet(&quot;/file&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">try</span>(FileOutputStream stream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;/Users/nagocoler/Documents/IdeaProjects/WebTest/test.png&quot;</span>))&#123;<br>            Part part = req.getPart(<span class="hljs-string">&quot;test-file&quot;</span>);<br>            IOUtils.copy(part.getInputStream(), stream);<br>            resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>            resp.getWriter().write(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@MultipartConfig</span><br><span class="hljs-meta">@WebServlet(&quot;/file&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">try</span>(FileOutputStream stream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;/Users/nagocoler/Documents/IdeaProjects/WebTest/test.png&quot;</span>))&#123;<br>            Part part = req.getPart(<span class="hljs-string">&quot;test-file&quot;</span>);<br>            IOUtils.copy(part.getInputStream(), stream);<br>            resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>            resp.getWriter().write(<span class="hljs-string">"文件上传成功！"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，必须添加<code>@MultipartConfig</code>注解来表示此Servlet用于处理文件上传请求。</p><p>现在我们再运行服务器，并将我们刚才下载的文件又上传给服务端。</p><h3 id="使用XHR请求数据"><a href="#使用XHR请求数据" class="headerlink" title="使用XHR请求数据"></a>使用XHR请求数据</h3><p>现在我们希望，网页中的部分内容，可以动态显示，比如网页上有一个时间，旁边有一个按钮，点击按钮就可以刷新当前时间。</p><p>这个时候就需要我们在网页展示时向后端发起请求了，并根据后端响应的结果，动态地更新页面中的内容，要实现此功能，就需要用到JavaScript来帮助我们，首先在js中编写我们的XHR请求，并在请求中完成动态更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTime</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;time&quot;</span>).innerText = xhr.responseText<br>        &#125;<br>    &#125;;<br>    xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-literal"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTime</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;time&quot;</span>).innerText = xhr.responseText<br>        &#125;<br>    &#125;;<br>    xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-literal">true</span>);<br>    xhr.send();<br>&#125;<br></code></pre></td></tr></table></figure><p>接着修改一下前端页面，添加一个时间显示区域：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;updateTime()&quot;</span>&gt;</span>更新数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    updateTime()<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;updateTime()&quot;</span>&gt;</span>更新数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    updateTime()<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span><br></code></pre></td></tr></table></figure><p>最后创建一个Servlet用于处理时间更新请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@WebServlet(&quot;/time&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br>        String date = dateFormat.format(<span class="hljs-keyword">new</span> Date());<br>        resp.setContentType(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@WebServlet(&quot;/time&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br>        String date = dateFormat.format(<span class="hljs-keyword">new</span> Date());<br>        resp.setContentType(<span class="hljs-string">"text/html;charset=UTF-8"</span>);<br>        resp.getWriter().write(date);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在点击按钮就可以更新了。</p><p>GET请求也能传递参数，这里做一下演示。</p><h3 id="重定向与请求转发"><a href="#重定向与请求转发" class="headerlink" title="重定向与请求转发"></a>重定向与请求转发</h3><p>当我们希望用户登录完成之后，直接跳转到网站的首页，那么这个时候，我们就可以使用重定向来完成。当浏览器收到一个重定向的响应时，会按照重定向响应给出的地址，再次向此地址发出请求。</p><p>实现重定向很简单，只需要调用一个方法即可，我们修改一下登陆成功后执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">resp.sendRedirect(<span class="hljs-string"><code class="language-hljs java">resp.sendRedirect(<span class="hljs-string">"time"</span>);<br></code></pre></td></tr></table></figure><p>调用后，响应的状态码会被设置为302，并且响应头中添加了一个Location属性，此属性表示，需要重定向到哪一个网址。</p><p>现在，如果我们成功登陆，那么服务器会发送给我们一个重定向响应，这时，我们的浏览器会去重新请求另一个网址。这样，我们在登陆成功之后，就可以直接帮助用户跳转到用户首页了。</p><p>那么我们接着来看请求转发，请求转发其实是一种服务器内部的跳转机制，我们知道，重定向会使得浏览器去重新请求一个页面，而请求转发则是服务器内部进行跳转，它的目的是，直接将本次请求转发给其他Servlet进行处理，并由其他Servlet来返回结果，因此它是在进行内部的转发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">req.getRequestDispatcher(<span class="hljs-string"><code class="language-hljs java">req.getRequestDispatcher(<span class="hljs-string">"/time"</span>).forward(req, resp);<br></code></pre></td></tr></table></figure><p>现在，在登陆成功的时候，我们将请求转发给处理时间的Servlet，注意这里的路径规则和之前的不同，我们需要填写Servlet上指明的路径，并且请求转发只能转发到此应用程序内部的Servlet，不能转发给其他站点或是其他Web应用程序。</p><p>现在再次进行登陆操作，我们发现，返回结果为一个405页面，证明了，我们的请求现在是被另一个Servlet进行处理，并且请求的信息全部被转交给另一个Servlet，由于此Servlet不支持POST请求，因此返回405状态码。</p><p>那么也就是说，该请求包括请求参数也一起被传递了，那么我们可以尝试获取以下POST请求的参数。</p><p>现在我们给此Servlet添加POST请求处理，直接转交给Get请求处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-keyword">this</span>.doGet(req, resp);<br>&#125;<br></code></pre></td></tr></table></figure><p>再次访问，成功得到结果，但是我们发现，浏览器只发起了一次请求，并没有再次请求新的URL，也就是说，这一次请求直接返回了请求转发后的处理结果。</p><p>那么，请求转发有什么好处呢？它可以携带数据！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">req.setAttribute(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;我是请求转发前的数据&quot;</span>);<br>req.getRequestDispatcher(<span class="hljs-string"><code class="language-hljs java">req.setAttribute(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;我是请求转发前的数据&quot;</span>);<br>req.getRequestDispatcher(<span class="hljs-string">"/time"</span>).forward(req, resp);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">System.out.println(req.getAttribute(<span class="hljs-string"><code class="language-hljs java">System.out.println(req.getAttribute(<span class="hljs-string">"test"</span>));<br></code></pre></td></tr></table></figure><p>通过<code>setAttribute</code>方法来给当前请求添加一个附加数据，在请求转发后，我们可以直接获取到该数据。</p><p>重定向属于2次请求，因此无法使用这种方式来传递数据，那么，如何在重定向之间传递数据呢？我们可以使用即将要介绍的ServletContext对象。</p><p>最后总结，两者的区别为：</p><ul><li>请求转发是一次请求，重定向是两次请求</li><li>请求转发地址栏不会发生改变， 重定向地址栏会发生改变</li><li>请求转发可以共享请求参数 ，重定向之后，就获取不了共享参数了</li><li>请求转发只能转发给内部的Servlet</li></ul><h3 id="了解ServletContext对象"><a href="#了解ServletContext对象" class="headerlink" title="了解ServletContext对象"></a>了解ServletContext对象</h3><p>ServletContext全局唯一，它是属于整个Web应用程序的，我们可以通过<code>getServletContext()</code>来获取到此对象。</p><p>此对象也能设置附加值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java">ServletContext context = getServletContext();<br>context.setAttribute(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;我是重定向之前的数据&quot;</span>);<br>resp.sendRedirect(<span class="hljs-string"><code class="language-hljs java">ServletContext context = getServletContext();<br>context.setAttribute(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;我是重定向之前的数据&quot;</span>);<br>resp.sendRedirect(<span class="hljs-string">"time"</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">System.out.println(getServletContext().getAttribute(<span class="hljs-string"><code class="language-hljs java">System.out.println(getServletContext().getAttribute(<span class="hljs-string">"test"</span>));<br></code></pre></td></tr></table></figure><p>因为无论在哪里，无论什么时间，获取到的ServletContext始终是同一个对象，因此我们可以随时随地获取我们添加的属性。</p><p>它不仅仅可以用来进行数据传递，还可以做一些其他的事情，比如请求转发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">context.getRequestDispatcher(<span class="hljs-string"><code class="language-hljs java">context.getRequestDispatcher(<span class="hljs-string">"/time"</span>).forward(req, resp);<br></code></pre></td></tr></table></figure><p>它还可以获取根目录下的资源文件（注意是webapp根目录下的，不是resource中的资源）</p><h3 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h3><p>初始化参数类似于初始化配置需要的一些值，比如我们的数据库连接相关信息，就可以通过初始化参数来给予Servlet，或是一些其他的配置项，也可以使用初始化参数来实现。</p><p>我们可以给一个Servlet添加一些初始化参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@WebServlet(value = &quot;/login&quot;, initParams = &#123;</span><br><span class="hljs-meta">        @WebInitParam(name = &quot;test&quot;, value = &quot;我是一个默认的初始化参数&quot;)</span><br><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@WebServlet(value = &quot;/login&quot;, initParams = &#123;</span><br><span class="hljs-meta">        @WebInitParam(name = &quot;test&quot;, value = &quot;我是一个默认的初始化参数&quot;)</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>它也是以键值对形式保存的，我们可以直接通过Servlet的<code>getInitParameter</code>方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">System.out.println(getInitParameter(<span class="hljs-string"><code class="language-hljs java">System.out.println(getInitParameter(<span class="hljs-string">"test"</span>));<br></code></pre></td></tr></table></figure><p>但是，这里的初始化参数仅仅是针对于此Servlet，我们也可以定义全局初始化参数，只需要在web.xml编写即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>lbwnb<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>我是全局初始化参数<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>lbwnb<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>我是全局初始化参数<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>></span><br></code></pre></td></tr></table></figure><p>我们需要使用ServletContext来读取全局初始化参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">ServletContext context = getServletContext();<br>System.out.println(context.getInitParameter(<span class="hljs-string"><code class="language-hljs java">ServletContext context = getServletContext();<br>System.out.println(context.getInitParameter(<span class="hljs-string">"lbwnb"</span>));<br></code></pre></td></tr></table></figure><p>有关ServletContext其他的内容，我们需要完成后面内容的学习，才能理解。</p><hr><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>什么是Cookie？不是曲奇，它可以在浏览器中保存一些信息，并且在下次请求时，请求头中会携带这些信息。</p><p>我们可以编写一个测试用例来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;yyds&quot;</span>);<br>resp.addCookie(cookie);<br>resp.sendRedirect(<span class="hljs-string"><code class="language-hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;yyds&quot;</span>);<br>resp.addCookie(cookie);<br>resp.sendRedirect(<span class="hljs-string">"time"</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">for</span> (Cookie cookie : req.getCookies()) &#123;<br>    System.out.println(cookie.getName() + <span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">for</span> (Cookie cookie : req.getCookies()) &#123;<br>    System.out.println(cookie.getName() + <span class="hljs-string">": "</span> + cookie.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以观察一下，在<code>HttpServletResponse</code>中添加Cookie之后，浏览器的响应头中会包含一个<code>Set-Cookie</code>属性，同时，在重定向之后，我们的请求头中，会携带此Cookie作为一个属性，同时，我们可以直接通过<code>HttpServletRequest</code>来快速获取有哪些Cookie信息。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.uml.org.cn%2Fxjs%2Fimages%2F2019032226.jpg&refer=http%3A%2F%2Fwww.uml.org.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640427806&t=a452f8b27a0769ca82d2269664e71a5e" alt="点击查看源网页"></p><p>还有这么神奇的事情吗？那么我们来看看，一个Cookie包含哪些信息：</p><ul><li>name   -   Cookie的名称，Cookie一旦创建，名称便不可更改</li><li>value  -   Cookie的值，如果值为Unicode字符，需要为字符编码。如果为二进制数据，则需要使用BASE64编码</li><li>maxAge  -  Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为-1。</li><li>secure  -  该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。</li><li>path  -  Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”。</li><li>domain  -  可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。</li><li>comment  -  该Cookie的用处说明，浏览器显示Cookie信息的时候显示该说明。</li><li>version  -  Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范</li></ul><p>我们发现，最关键的其实是<code>name</code>、<code>value</code>、<code>maxAge</code>、<code>domain</code>属性。</p><p>那么我们来尝试修改一下maxAge来看看失效时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">cookie.setMaxAge(<span class="hljs-number"><code class="language-hljs java">cookie.setMaxAge(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>设定为20秒，我们可以直接看到，响应头为我们设定了20秒的过期时间。20秒内访问都会携带此Cookie，而超过20秒，Cookie消失。</p><p>既然了解了Cookie的作用，我们就可以通过使用Cookie来实现记住我功能，我们可以将用户名和密码全部保存在Cookie中，如果访问我们的首页时携带了这些Cookie，那么我们就可以直接为用户进行登陆，如果登陆成功则直接跳转到首页，如果登陆失败，则清理浏览器中的Cookie。</p><p>那么首先，我们先在前端页面的表单中添加一个勾选框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;记住我&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;remember-me&quot;</span>&gt;</span><br>        记住我<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;记住我&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;remember-me&quot;</span>&gt;</span><br>        记住我<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>接着，我们在登陆成功时进行判断，如果用户勾选了记住我，那么就讲Cookie存储到本地：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-string">&quot;remember-me&quot;</span>))&#123;   <span class="hljs-comment">//若勾选了勾选框，那么会此表单信息</span><br>    Cookie cookie_username = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;username&quot;</span>, username);<br>    cookie_username.setMaxAge(<span class="hljs-number">30</span>);<br>    Cookie cookie_password = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;password&quot;</span>, password);<br>    cookie_password.setMaxAge(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-string">&quot;remember-me&quot;</span>))&#123;   <span class="hljs-comment">//若勾选了勾选框，那么会此表单信息</span><br>    Cookie cookie_username = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;username&quot;</span>, username);<br>    cookie_username.setMaxAge(<span class="hljs-number">30</span>);<br>    Cookie cookie_password = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;password&quot;</span>, password);<br>    cookie_password.setMaxAge(<span class="hljs-number">30</span>);<br>    resp.addCookie(cookie_username);<br>    resp.addCookie(cookie_password);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们修改一下默认的请求地址，现在一律通过<code>http://localhost:8080/yyds/login</code>进行登陆，那么我们需要添加GET请求的相关处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    Cookie[] cookies = req.getCookies();<br>    <span class="hljs-keyword">if</span>(cookies != <span class="hljs-keyword">null</span>)&#123;<br>        String username = <span class="hljs-keyword">null</span>;<br>        String password = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;<br>            <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">&quot;username&quot;</span>)) username = cookie.getValue();<br>            <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">&quot;password&quot;</span>)) password = cookie.getValue();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(username != <span class="hljs-keyword">null</span> &amp;&amp; password != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//登陆校验</span><br>            <span class="hljs-keyword">try</span> (SqlSession sqlSession = factory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>                UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>                User user = mapper.getUser(username, password);<br>                <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>)&#123;<br>                    resp.sendRedirect(<span class="hljs-string">&quot;time&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//直接返回</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    req.getRequestDispatcher(<span class="hljs-string">&quot;/&quot;</span>).forward(req, resp);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    Cookie[] cookies = req.getCookies();<br>    <span class="hljs-keyword">if</span>(cookies != <span class="hljs-keyword">null</span>)&#123;<br>        String username = <span class="hljs-keyword">null</span>;<br>        String password = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;<br>            <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">&quot;username&quot;</span>)) username = cookie.getValue();<br>            <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">&quot;password&quot;</span>)) password = cookie.getValue();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(username != <span class="hljs-keyword">null</span> &amp;&amp; password != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//登陆校验</span><br>            <span class="hljs-keyword">try</span> (SqlSession sqlSession = factory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>                UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>                User user = mapper.getUser(username, password);<br>                <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>)&#123;<br>                    resp.sendRedirect(<span class="hljs-string">&quot;time&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//直接返回</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    req.getRequestDispatcher(<span class="hljs-string">&quot;/&quot;</span>).forward(req, resp);   <span class="hljs-comment">//正常情况还是转发给默认的Servlet帮我们返回静态页面</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，30秒内都不需要登陆，访问登陆页面后，会直接跳转到time页面。</p><p>现在已经离我们理想的页面越来越接近了，但是仍然有一个问题，就是我们的首页，无论是否登陆，所有人都可以访问，那么，如何才可以实现只有登陆之后才能访问呢？这就需要用到Session了。</p><hr><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>由于HTTP是无连接的，那么如何能够辨别当前的请求是来自哪个用户发起的呢？Session就是用来处理这种问题的，每个用户的会话都会有一个自己的Session对象，来自同一个浏览器的所有请求，就属于同一个会话。</p><p>但是HTTP协议是无连接的呀，那Session是如何做到辨别是否来自同一个浏览器呢？Session实际上是基于Cookie实现的，前面我们了解了Cookie，我们知道，服务端可以将Cookie保存到浏览器，当浏览器下次访问时，就会附带这些Cookie信息。</p><p>Session也利用了这一点，它会给浏览器设定一个叫做<code>JSESSIONID</code>的Cookie，值是一个随机的排列组合，而此Cookie就对应了你属于哪一个对话，只要我们的浏览器携带此Cookie访问服务器，服务器就会通过Cookie的值进行辨别，得到对应的Session对象，因此，这样就可以追踪到底是哪一个浏览器在访问服务器。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xaecong.com%2Fuploadfile%2F2018-5%2F20180511113613649.gif&refer=http%3A%2F%2Fwww.xaecong.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640433362&t=bbfd240d9a7ec60468840f01b097d2a2" alt="点击查看源网页"></p><p>那么现在，我们在用户登录成功之后，将用户对象添加到Session中，只要是此用户发起的请求，我们都可以从<code>HttpSession</code>中读取到存储在会话中的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">HttpSession session = req.getSession();<br>session.setAttribute(<span class="hljs-string"><code class="language-hljs java">HttpSession session = req.getSession();<br>session.setAttribute(<span class="hljs-string">"user"</span>, user);<br></code></pre></td></tr></table></figure><p>同时，如果用户没有登录就去访问首页，那么我们将发送一个重定向请求，告诉用户，需要先进行登录才可以访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java">HttpSession session = req.getSession();<br>User user = (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br><span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;<br>    resp.sendRedirect(<span class="hljs-string">&quot;login&quot;</span>);<br>    <span class="hljs-keyword"><code class="language-hljs java">HttpSession session = req.getSession();<br>User user = (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br><span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;<br>    resp.sendRedirect(<span class="hljs-string">&quot;login&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在访问的过程中，注意观察Cookie变化。</p><p>Session并不是永远都存在的，它有着自己的过期时间，默认时间为30分钟，若超过此时间，Session将丢失，我们可以在配置文件中修改过期时间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>></span><br></code></pre></td></tr></table></figure><p>我们也可以在代码中使用<code>invalidate</code>方法来使Session立即失效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><code class="language-hljs java">session.invalidate();<br></code></pre></td></tr></table></figure><p>现在，通过Session，我们就可以更好地控制用户对于资源的访问，只有完成登陆的用户才有资格访问首页。</p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>有了Session之后，我们就可以很好地控制用户的登陆验证了，只有授权的用户，才可以访问一些页面，但是我们需要一个一个去进行配置，还是太过复杂，能否一次性地过滤掉没有登录验证的用户呢？</p><p>过滤器相当于在所有访问前加了一堵墙，来自浏览器的所有访问请求都会首先经过过滤器，只有过滤器允许通过的请求，才可以顺利地到达对应的Servlet，而过滤器不允许的通过的请求，我们可以自由地进行控制是否进行重定向或是请求转发。并且过滤器可以添加很多个，就相当于添加了很多堵墙，我们的请求只有穿过层层阻碍，才能与Servlet相拥，像极了爱情。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages.cnitblog.com%2Fblog%2F150046%2F201501%2F072114593437292.png&refer=http%3A%2F%2Fimages.cnitblog.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640479081&t=a1259950e28398b095ea7ce30c022904" alt="点击查看源网页"></p><p>添加一个过滤器非常简单，只需要实现Filter接口，并添加<code>@WebFilter</code>注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span>   <span class="hljs-comment">//路径的匹配规则和Servlet一致，这里表示匹配所有请求</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span>   <span class="hljs-comment">//路径的匹配规则和Servlet一致，这里表示匹配所有请求</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就成功地添加了一个过滤器，那么添加一句打印语句看看，是否所有的请求都会经过此过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><code class="language-hljs java">HttpServletRequest request = (HttpServletRequest) servletRequest;<br>System.out.println(request.getRequestURL());<br></code></pre></td></tr></table></figure><p>我们发现，现在我们发起的所有请求，一律需要经过此过滤器，并且所有的请求都没有任何的响应内容。</p><p>那么如何让请求可以顺利地到达对应的Servlet，也就是说怎么让这个请求顺利通过呢？我们只需要在最后添加一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><code class="language-hljs java">filterChain.doFilter(servletRequest, servletResponse);<br></code></pre></td></tr></table></figure><p>那么这行代码是什么意思呢？</p><p>由于我们整个应用程序可能存在多个过滤器，那么这行代码的意思实际上是将此请求继续传递给下一个过滤器，当没有下一个过滤器时，才会到达对应的Servlet进行处理，我们可以再来创建一个过滤器看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFilter2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFilter2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">"我是2号过滤器"</span>);<br>        filterChain.doFilter(servletRequest, servletResponse);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于过滤器的过滤顺序是按照类名的自然排序进行的，因此我们将第一个过滤器命名进行调整。</p><p>我们发现，在经过第一个过滤器之后，会继续前往第二个过滤器，只有两个过滤器全部经过之后，才会到达我们的Servlet中。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages.cnitblog.com%2Fblog%2F34303%2F201212%2F30153033-d9e09a9c8dfe403fb9f6303052ba4b6c.png&refer=http%3A%2F%2Fimages.cnitblog.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640479150&t=d14eb2b4c2a3d6e987fc9cf6680a326f" alt="点击查看源网页"></p><p>实际上，当<code>doFilter</code>方法调用时，就会一直向下直到Servlet，在Servlet处理完成之后，又依次返回到最前面的Filter，类似于递归的结构，我们添加几个输出语句来判断一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是2号过滤器&quot;</span>);<br>    filterChain.doFilter(servletRequest, servletResponse);<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是2号过滤器&quot;</span>);<br>    filterChain.doFilter(servletRequest, servletResponse);<br>    System.out.println(<span class="hljs-string">"我是2号过滤器，处理后"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是1号过滤器&quot;</span>);<br>    filterChain.doFilter(servletRequest, servletResponse);<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是1号过滤器&quot;</span>);<br>    filterChain.doFilter(servletRequest, servletResponse);<br>    System.out.println(<span class="hljs-string">"我是1号过滤器，处理后"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后验证我们的结论。</p><p>同Servlet一样，Filter也有对应的HttpFilter专用类，它针对HTTP请求进行了专门处理，因此我们可以直接使用HttpFilter来编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7478463438252262094L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpFilter</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        <span class="hljs-keyword">if</span> (req <span class="hljs-keyword">instanceof</span> HttpServletRequest &amp;&amp; res <span class="hljs-keyword">instanceof</span> HttpServletResponse) &#123;<br>            <span class="hljs-keyword">this</span>.doFilter((HttpServletRequest)req, (HttpServletResponse)res, chain);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">&quot;non-HTTP request or response&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, FilterChain chain)</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7478463438252262094L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpFilter</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        <span class="hljs-keyword">if</span> (req <span class="hljs-keyword">instanceof</span> HttpServletRequest &amp;&amp; res <span class="hljs-keyword">instanceof</span> HttpServletResponse) &#123;<br>            <span class="hljs-keyword">this</span>.doFilter((HttpServletRequest)req, (HttpServletResponse)res, chain);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">&quot;non-HTTP request or response&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        chain.doFilter(req, res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在，我们就可以给我们的应用程序添加一个过滤器，用户在未登录情况下，只允许静态资源和登陆页面请求通过，登陆之后畅行无阻：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpFilter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        String url = req.getRequestURL().toString();<br>        <span class="hljs-comment">//判断是否为静态资源</span><br>        <span class="hljs-keyword">if</span>(!url.endsWith(<span class="hljs-string">&quot;.js&quot;</span>) &amp;&amp; !url.endsWith(<span class="hljs-string">&quot;.css&quot;</span>) &amp;&amp; !url.endsWith(<span class="hljs-string">&quot;.png&quot;</span>))&#123;<br>            HttpSession session = req.getSession();<br>            User user = (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>            <span class="hljs-comment">//判断是否未登陆</span><br>            <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span> &amp;&amp; !url.endsWith(<span class="hljs-string">&quot;login&quot;</span>))&#123;<br>                res.sendRedirect(<span class="hljs-string">&quot;login&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpFilter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        String url = req.getRequestURL().toString();<br>        <span class="hljs-comment">//判断是否为静态资源</span><br>        <span class="hljs-keyword">if</span>(!url.endsWith(<span class="hljs-string">&quot;.js&quot;</span>) &amp;&amp; !url.endsWith(<span class="hljs-string">&quot;.css&quot;</span>) &amp;&amp; !url.endsWith(<span class="hljs-string">&quot;.png&quot;</span>))&#123;<br>            HttpSession session = req.getSession();<br>            User user = (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>            <span class="hljs-comment">//判断是否未登陆</span><br>            <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span> &amp;&amp; !url.endsWith(<span class="hljs-string">&quot;login&quot;</span>))&#123;<br>                res.sendRedirect(<span class="hljs-string">&quot;login&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//交给过滤链处理</span><br>        chain.doFilter(req, res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们的页面已经基本完善为我们想要的样子了。</p><p>当然，可能跟着教程编写的项目比较乱，大家可以自己花费一点时间来重新编写一个Web应用程序，加深对之前讲解知识的理解。我们也会在之后安排一个编程实战进行深化练习。</p><hr><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>监听器并不是我们学习的重点内容，那么什么是监听器呢？</p><p>如果我们希望，在应用程序加载的时候，或是Session创建的时候，亦或是在Request对象创建的时候进行一些操作，那么这个时候，我们就可以使用监听器来实现。</p><p><img src="https://img-blog.csdn.net/20180825212011379?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MjA0MTc5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>默认为我们提供了很多类型的监听器，我们这里就演示一下监听Session的创建即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@WebListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@WebListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"有一个Session被创建了"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有关监听器相关内容，了解即可。</p><hr><h2 id="了解JSP页面与加载规则"><a href="#了解JSP页面与加载规则" class="headerlink" title="了解JSP页面与加载规则"></a>了解JSP页面与加载规则</h2><p>前面我们已经完成了整个Web应用程序生命周期中所有内容的学习，我们已经完全了解，如何编写一个Web应用程序，并放在Tomcat上部署运行，以及如何控制浏览器发来的请求，通过Session+Filter实现用户登陆验证，通过Cookie实现自动登陆等操作。到目前为止，我们已经具备编写一个完整Web网站的能力。</p><p>在之前的教程中，我们的前端静态页面并没有与后端相结合，我们前端页面所需的数据全部需要单独向后端发起请求获取，并动态进行内容填充，这是一种典型的前后端分离写法，前端只负责要数据和显示数据，后端只负责处理数据和提供数据，这也是现在更流行的一种写法，让前端开发者和后端开发者各尽其责，更加专一，这才是我们所希望的开发模式。</p><p>JSP并不是我们需要重点学习的内容，因为它已经过时了，使用JSP会导致前后端严重耦合，因此这里只做了解即可。</p><p>JSP其实就是一种模板引擎，那么何谓模板引擎呢？顾名思义，它就是一个模板，而模板需要我们填入数据，才可以变成一个页面，也就是说，我们可以直接在前端页面中直接填写数据，填写后生成一个最终的HTML页面返回给前端。</p><p>首先我们来创建一个新的项目，项目创建成功后，删除Java目录下的内容，只留下默认创建的jsp文件，我们发现，在webapp目录中，存在一个<code>index.jsp</code>文件，现在我们直接运行项目，会直接访问这个JSP页面。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;JSP - Hello World&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;&lt;%= <span class="hljs-string">&quot;Hello World!&quot;</span> %&gt;<br>&lt;/h1&gt;<br>&lt;br/&gt;<br>&lt;a href=<span class="hljs-string"><code class="language-hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;JSP - Hello World&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;&lt;%= <span class="hljs-string">&quot;Hello World!&quot;</span> %&gt;<br>&lt;/h1&gt;<br>&lt;br/&gt;<br>&lt;a href=<span class="hljs-string">"hello-servlet"</span>>Hello Servlet</a><br></body><br></html><br></code></pre></td></tr></table></figure><p>但是我们并没有编写对应的Servlet来解析啊，那么为什么这个JSP页面会被加载呢？</p><p>实际上，我们一开始提到的两个Tomcat默认的Servlet中，一个是用于请求静态资源，还有一个就是用于处理jsp的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>></span><br></code></pre></td></tr></table></figure><p>那么，JSP和普通HTML页面有什么区别呢，我们发现它的语法和普通HTML页面几乎一致，我们可以直接在JSP中编写Java代码，并在页面加载的时候执行，我们随便找个地方插入：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs jsp">&lt;%<br>    System.out.println(<span class="hljs-string"><code class="language-hljs jsp">&lt;%<br>    System.out.println(<span class="hljs-string">"JSP页面被加载"</span>);<br>%><br></code></pre></td></tr></table></figure><p>我们发现，请求一次页面，页面就会加载一次，并执行我们填写的Java代码。也就是说，我们可以直接在此页面中执行Java代码来填充我们的数据，这样我们的页面就变成了一个动态页面，使用<code>&lt;%=  %&gt;</code>来填写一个值：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs jsp">&lt;h1&gt;&lt;%= <span class="hljs-keyword"><code class="language-hljs jsp">&lt;h1&gt;&lt;%= <span class="hljs-keyword">new</span> Date() %></h1><br></code></pre></td></tr></table></figure><p>现在访问我们的网站，每次都会创建一个新的Date对象，因此每次访问获取的时间都不一样，我们的网站已经算是一个动态的网站的了。</p><p>虽然这样在一定程度上上为我们提供了便利，但是这样的写法相当于整个页面既要编写前端代码，也要编写后端代码，随着项目的扩大，整个页面会显得难以阅读，并且现在都是前后端开发人员职责非常明确的，如果要编写JSP页面，那就必须要招一个既会前端也会后端的程序员，这样显然会导致不必要的开销。</p><p>那么我们来研究一下，为什么JSP页面能够在加载的时候执行Java代码呢？</p><p>首先我们将此项目打包，并在Tomcat服务端中运行，生成了一个文件夹并且可以正常访问。</p><p>我们现在看到<code>work</code>目录，我们发现这个里面多了一个<code>index_jsp.java</code>和<code>index_jsp.class</code>，那么这些东西是干嘛的呢，我们来反编译一下就啥都知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">index_jsp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">jasper</span>.<span class="hljs-title">runtime</span>.<span class="hljs-title">HttpJspBase</span>  //继承自<span class="hljs-title">HttpServlet</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">jasper</span>.<span class="hljs-title">runtime</span>.<span class="hljs-title">JspSourceDependent</span>,</span><br><span class="hljs-class">                 <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">jasper</span>.<span class="hljs-title">runtime</span>.<span class="hljs-title">JspSourceImports</span> </span>&#123;<br><br> ...<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspService</span><span class="hljs-params">(<span class="hljs-keyword">final</span> jakarta.servlet.http.HttpServletRequest request, <span class="hljs-keyword">final</span> jakarta.servlet.http.HttpServletResponse response)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">throws</span> java.io.IOException, jakarta.servlet.ServletException </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (!jakarta.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;<br>      <span class="hljs-keyword">final</span> java.lang.String _jspx_method = request.getMethod();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OPTIONS&quot;</span>.equals(_jspx_method)) &#123;<br>        response.setHeader(<span class="hljs-string">&quot;Allow&quot;</span>,<span class="hljs-string">&quot;GET, HEAD, POST, OPTIONS&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;GET&quot;</span>.equals(_jspx_method) &amp;&amp; !<span class="hljs-string">&quot;POST&quot;</span>.equals(_jspx_method) &amp;&amp; !<span class="hljs-string">&quot;HEAD&quot;</span>.equals(_jspx_method)) &#123;<br>        response.setHeader(<span class="hljs-string">&quot;Allow&quot;</span>,<span class="hljs-string">&quot;GET, HEAD, POST, OPTIONS&quot;</span>);<br>        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, <span class="hljs-string">&quot;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> jakarta.servlet.jsp.PageContext pageContext;<br>    jakarta.servlet.http.HttpSession session = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">final</span> jakarta.servlet.ServletContext application;<br>    <span class="hljs-keyword">final</span> jakarta.servlet.ServletConfig config;<br>    jakarta.servlet.jsp.JspWriter out = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">final</span> java.lang.Object page = <span class="hljs-keyword">this</span>;<br>    jakarta.servlet.jsp.JspWriter _jspx_out = <span class="hljs-keyword">null</span>;<br>    jakarta.servlet.jsp.PageContext _jspx_page_context = <span class="hljs-keyword">null</span>;<br><br><br>    <span class="hljs-keyword">try</span> &#123;<br>      response.setContentType(<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br>      pageContext = _jspxFactory.getPageContext(<span class="hljs-keyword">this</span>, request, response,<br>             <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">8192</span>, <span class="hljs-keyword">true</span>);<br>      _jspx_page_context = pageContext;<br>      application = pageContext.getServletContext();<br>      config = pageContext.getServletConfig();<br>      session = pageContext.getSession();<br>      out = pageContext.getOut();<br>      _jspx_out = out;<br><br>      out.write(<span class="hljs-string">&quot;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;head&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;    &lt;title&gt;JSP - Hello World&lt;/title&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;/head&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;body&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;h1&gt;&quot;</span>);<br>      out.print( <span class="hljs-keyword">new</span> Date() );<br>      out.write(<span class="hljs-string">&quot;&lt;/h1&gt;\n&quot;</span>);<br><br>    System.out.println(<span class="hljs-string">&quot;JSP页面被加载&quot;</span>);<br><br>      out.write(<span class="hljs-string">&quot;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;br/&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;a href=\&quot;hello-servlet\&quot;&gt;Hello Servlet&lt;/a&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;/body&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (java.lang.Throwable t) &#123;<br>      <span class="hljs-keyword">if</span> (!(t <span class="hljs-keyword">instanceof</span> jakarta.servlet.jsp.SkipPageException))&#123;<br>        out = _jspx_out;<br>        <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span> &amp;&amp; out.getBufferSize() != <span class="hljs-number">0</span>)<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (response.isCommitted()) &#123;<br>              out.flush();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              out.clearBuffer();<br>            &#125;<br>          &#125; <span class="hljs-keyword">catch</span> (java.io.IOException e) &#123;&#125;<br>        <span class="hljs-keyword">if</span> (_jspx_page_context != <span class="hljs-keyword">null</span>) _jspx_page_context.handlePageException(t);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(t);<br>      &#125;<br>    &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">index_jsp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">jasper</span>.<span class="hljs-title">runtime</span>.<span class="hljs-title">HttpJspBase</span>  //继承自<span class="hljs-title">HttpServlet</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">jasper</span>.<span class="hljs-title">runtime</span>.<span class="hljs-title">JspSourceDependent</span>,</span><br><span class="hljs-class">                 <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">jasper</span>.<span class="hljs-title">runtime</span>.<span class="hljs-title">JspSourceImports</span> </span>&#123;<br><br> ...<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspService</span><span class="hljs-params">(<span class="hljs-keyword">final</span> jakarta.servlet.http.HttpServletRequest request, <span class="hljs-keyword">final</span> jakarta.servlet.http.HttpServletResponse response)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">throws</span> java.io.IOException, jakarta.servlet.ServletException </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (!jakarta.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;<br>      <span class="hljs-keyword">final</span> java.lang.String _jspx_method = request.getMethod();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OPTIONS&quot;</span>.equals(_jspx_method)) &#123;<br>        response.setHeader(<span class="hljs-string">&quot;Allow&quot;</span>,<span class="hljs-string">&quot;GET, HEAD, POST, OPTIONS&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;GET&quot;</span>.equals(_jspx_method) &amp;&amp; !<span class="hljs-string">&quot;POST&quot;</span>.equals(_jspx_method) &amp;&amp; !<span class="hljs-string">&quot;HEAD&quot;</span>.equals(_jspx_method)) &#123;<br>        response.setHeader(<span class="hljs-string">&quot;Allow&quot;</span>,<span class="hljs-string">&quot;GET, HEAD, POST, OPTIONS&quot;</span>);<br>        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, <span class="hljs-string">&quot;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> jakarta.servlet.jsp.PageContext pageContext;<br>    jakarta.servlet.http.HttpSession session = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">final</span> jakarta.servlet.ServletContext application;<br>    <span class="hljs-keyword">final</span> jakarta.servlet.ServletConfig config;<br>    jakarta.servlet.jsp.JspWriter out = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">final</span> java.lang.Object page = <span class="hljs-keyword">this</span>;<br>    jakarta.servlet.jsp.JspWriter _jspx_out = <span class="hljs-keyword">null</span>;<br>    jakarta.servlet.jsp.PageContext _jspx_page_context = <span class="hljs-keyword">null</span>;<br><br><br>    <span class="hljs-keyword">try</span> &#123;<br>      response.setContentType(<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br>      pageContext = _jspxFactory.getPageContext(<span class="hljs-keyword">this</span>, request, response,<br>             <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">8192</span>, <span class="hljs-keyword">true</span>);<br>      _jspx_page_context = pageContext;<br>      application = pageContext.getServletContext();<br>      config = pageContext.getServletConfig();<br>      session = pageContext.getSession();<br>      out = pageContext.getOut();<br>      _jspx_out = out;<br><br>      out.write(<span class="hljs-string">&quot;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;head&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;    &lt;title&gt;JSP - Hello World&lt;/title&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;/head&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;body&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;h1&gt;&quot;</span>);<br>      out.print( <span class="hljs-keyword">new</span> Date() );<br>      out.write(<span class="hljs-string">&quot;&lt;/h1&gt;\n&quot;</span>);<br><br>    System.out.println(<span class="hljs-string">&quot;JSP页面被加载&quot;</span>);<br><br>      out.write(<span class="hljs-string">&quot;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;br/&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;a href=\&quot;hello-servlet\&quot;&gt;Hello Servlet&lt;/a&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;/body&gt;\n&quot;</span>);<br>      out.write(<span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (java.lang.Throwable t) &#123;<br>      <span class="hljs-keyword">if</span> (!(t <span class="hljs-keyword">instanceof</span> jakarta.servlet.jsp.SkipPageException))&#123;<br>        out = _jspx_out;<br>        <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span> &amp;&amp; out.getBufferSize() != <span class="hljs-number">0</span>)<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (response.isCommitted()) &#123;<br>              out.flush();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              out.clearBuffer();<br>            &#125;<br>          &#125; <span class="hljs-keyword">catch</span> (java.io.IOException e) &#123;&#125;<br>        <span class="hljs-keyword">if</span> (_jspx_page_context != <span class="hljs-keyword">null</span>) _jspx_page_context.handlePageException(t);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(t);<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      _jspxFactory.releasePageContext(_jspx_page_context);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，它是继承自<code>HttpJspBase</code>类，我们可以反编译一下jasper.jar（它在tomcat的lib目录中）来看看:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">package</span> org.apache.jasper.runtime;<br><br><span class="hljs-keyword">import</span> jakarta.servlet.ServletConfig;<br><span class="hljs-keyword">import</span> jakarta.servlet.ServletException;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> jakarta.servlet.jsp.HttpJspPage;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> org.apache.jasper.compiler.Localizer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpJspBase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpJspPage</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">HttpJspBase</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        <span class="hljs-keyword">super</span>.init(config);<br>        <span class="hljs-keyword">this</span>.jspInit();<br>        <span class="hljs-keyword">this</span>._jspInit();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Localizer.getMessage(<span class="hljs-string">&quot;jsp.engine.info&quot;</span>, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;3.0&quot;</span>&#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.jspDestroy();<br>        <span class="hljs-keyword">this</span>._jspDestroy();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>._jspService(request, response);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspInit</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspInit</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspService</span><span class="hljs-params">(HttpServletRequest var1, HttpServletResponse var2)</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">package</span> org.apache.jasper.runtime;<br><br><span class="hljs-keyword">import</span> jakarta.servlet.ServletConfig;<br><span class="hljs-keyword">import</span> jakarta.servlet.ServletException;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> jakarta.servlet.jsp.HttpJspPage;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> org.apache.jasper.compiler.Localizer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpJspBase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpJspPage</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">HttpJspBase</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        <span class="hljs-keyword">super</span>.init(config);<br>        <span class="hljs-keyword">this</span>.jspInit();<br>        <span class="hljs-keyword">this</span>._jspInit();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Localizer.getMessage(<span class="hljs-string">&quot;jsp.engine.info&quot;</span>, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;3.0&quot;</span>&#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.jspDestroy();<br>        <span class="hljs-keyword">this</span>._jspDestroy();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>._jspService(request, response);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspInit</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspInit</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspService</span><span class="hljs-params">(HttpServletRequest var1, HttpServletResponse var2)</span> <span class="hljs-keyword">throws</span> ServletException, IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，Tomcat在加载JSP页面时，会将其动态转换为一个java类并编译为class进行加载，而生成的Java类，正是一个Servlet的子类，而页面的内容全部被编译为输出字符串，这便是JSP的加载原理，因此，JSP本质上依然是一个Servlet！</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.debugrun.com%2Fpic%2F2017%2F10%2F8%2F017e6d66d6d9589dfc7377a052ca8047.png&refer=http%3A%2F%2Fimg.debugrun.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640487718&t=2656b55a2eb461b4a90afb1076aeb355" alt="点击查看源网页"></p><p>如果同学们感兴趣的话，可以查阅一下其他相关的教程，本教程不再讲解此技术。</p><hr><h2 id="使用Thymeleaf模板引擎"><a href="#使用Thymeleaf模板引擎" class="headerlink" title="使用Thymeleaf模板引擎"></a>使用Thymeleaf模板引擎</h2><p>虽然JSP为我们带来了便捷，但是其缺点也是显而易见的，那么有没有一种既能实现模板，又能兼顾前后端分离的模板引擎呢？</p><p><strong>Thymeleaf</strong>（百里香叶）是一个适用于Web和独立环境的现代化服务器端Java模板引擎，官方文档：<a href="https://www.thymeleaf.org/documentation.html%E3%80%82">https://www.thymeleaf.org/documentation.html。</a></p><p>那么它和JSP相比，好在哪里呢，我们来看官网给出的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;msgs.headers.name&#125;&quot;</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;msgs.headers.price&#125;&quot;</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;prod: $&#123;allProducts&#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;prod.name&#125;&quot;</span>&gt;</span>Oranges<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#numbers.formatDecimal(prod.price, 1, 2)&#125;&quot;</span>&gt;</span>0.99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;msgs.headers.name&#125;&quot;</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;msgs.headers.price&#125;&quot;</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;prod: $&#123;allProducts&#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;prod.name&#125;&quot;</span>&gt;</span>Oranges<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#numbers.formatDecimal(prod.price, 1, 2)&#125;&quot;</span>&gt;</span>0.99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>></span><br></code></pre></td></tr></table></figure><p>我们可以在前端页面中填写占位符，而这些占位符的实际值则由后端进行提供，这样，我们就不用再像JSP那样前后端都写在一起了。</p><p>那么我们来创建一个例子感受一下，首先还是新建一个项目，注意，在创建时，勾选Thymeleaf依赖。</p><p>首先编写一个前端页面，名称为<code>test.html</code>，注意，是放在resource目录下，在html标签内部添加<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code>引入Thymeleaf定义的标签属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;title&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;title&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>></span><br></code></pre></td></tr></table></figure><p>接着我们编写一个Servlet作为默认页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@WebServlet(&quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    TemplateEngine engine;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        engine = <span class="hljs-keyword">new</span> TemplateEngine();<br>        ClassLoaderTemplateResolver r = <span class="hljs-keyword">new</span> ClassLoaderTemplateResolver();<br>        engine.setTemplateResolver(r);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        context.setVariable(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;我是标题&quot;</span>);<br>        engine.process(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@WebServlet(&quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    TemplateEngine engine;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        engine = <span class="hljs-keyword">new</span> TemplateEngine();<br>        ClassLoaderTemplateResolver r = <span class="hljs-keyword">new</span> ClassLoaderTemplateResolver();<br>        engine.setTemplateResolver(r);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        context.setVariable(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;我是标题&quot;</span>);<br>        engine.process(<span class="hljs-string">"test.html"</span>, context, resp.getWriter());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，浏览器得到的页面，就是已经经过模板引擎解析好的页面，而我们的代码依然是后端处理数据，前端展示数据，因此使用Thymeleaf就能够使得当前Web应用程序的前后端划分更加清晰。</p><p>虽然Thymeleaf在一定程度上分离了前后端，但是其依然是在后台渲染HTML页面并发送给前端，并不是真正意义上的前后端分离。</p><h3 id="Thymeleaf语法基础"><a href="#Thymeleaf语法基础" class="headerlink" title="Thymeleaf语法基础"></a>Thymeleaf语法基础</h3><p>那么，如何使用Thymeleaf呢？</p><p>首先我们看看后端部分，我们需要通过<code>TemplateEngine</code>对象来将模板文件渲染为最终的HTML页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java">TemplateEngine engine;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>    engine = <span class="hljs-keyword">new</span> TemplateEngine();<br>  <span class="hljs-comment">//设定模板解析器决定了从哪里获取模板文件，这里直接使用ClassLoaderTemplateResolver表示加载内部资源文件</span><br>    ClassLoaderTemplateResolver r = <span class="hljs-keyword"><code class="language-hljs java">TemplateEngine engine;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>    engine = <span class="hljs-keyword">new</span> TemplateEngine();<br>  <span class="hljs-comment">//设定模板解析器决定了从哪里获取模板文件，这里直接使用ClassLoaderTemplateResolver表示加载内部资源文件</span><br>    ClassLoaderTemplateResolver r = <span class="hljs-keyword">new</span> ClassLoaderTemplateResolver();<br>    engine.setTemplateResolver(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于此对象只需要创建一次，之后就可以一直使用了。接着我们来看如何使用模板引擎进行解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-comment">//创建上下文，上下文中包含了所有需要替换到模板中的内容</span><br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;&lt;h1&gt;我是标题&lt;/h1&gt;&quot;</span>);<br>    <span class="hljs-comment">//通过此方法就可以直接解析模板并返回响应</span><br>    engine.process(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-comment">//创建上下文，上下文中包含了所有需要替换到模板中的内容</span><br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;&lt;h1&gt;我是标题&lt;/h1&gt;&quot;</span>);<br>    <span class="hljs-comment">//通过此方法就可以直接解析模板并返回响应</span><br>    engine.process(<span class="hljs-string">"test.html"</span>, context, resp.getWriter());<br>&#125;<br></code></pre></td></tr></table></figure><p>操作非常简单，只需要简单几步配置就可以实现模板的解析。接下来我们就可以在前端页面中通过上下文提供的内容，来将Java代码中的数据解析到前端页面。</p><p>接着我们来了解Thymeleaf如何为普通的标签添加内容，比如我们示例中编写的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;title&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;title&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>我们使用了<code>th:text</code>来为当前标签指定内部文本，注意任何内容都会变成普通文本，即使传入了一个HTML代码，如果我希望向内部添加一个HTML文本呢？我们可以使用<code>th:utext</code>属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">&quot;$&#123;title&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">&quot;$&#123;title&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>并且，传入的title属性，不仅仅只是一个字符串的值，而是一个字符串的引用，我们可以直接通过此引用调用相关的方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;title.toLowerCase()&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;title.toLowerCase()&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>这样看来，Thymeleaf既能保持JSP为我们带来的便捷，也能兼顾前后端代码的界限划分。</p><p>除了替换文本，它还支持替换一个元素的任意属性，我们发现，<code>th:</code>能够拼接几乎所有的属性，一旦使用<code>th:属性名称</code>，那么属性的值就可以通过后端提供了，比如我们现在想替换一个图片的链接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;http://n.sinaimg.cn/sinakd20121/600/w1920h1080/20210727/a700-adf8480ff24057e04527bdfea789e788.jpg&quot;</span>);<br>  context.setVariable(<span class="hljs-string">&quot;alt&quot;</span>, <span class="hljs-string">&quot;图片就是加载不出来啊&quot;</span>);<br>    engine.process(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;http://n.sinaimg.cn/sinakd20121/600/w1920h1080/20210727/a700-adf8480ff24057e04527bdfea789e788.jpg&quot;</span>);<br>  context.setVariable(<span class="hljs-string">&quot;alt&quot;</span>, <span class="hljs-string">&quot;图片就是加载不出来啊&quot;</span>);<br>    engine.process(<span class="hljs-string">"test.html"</span>, context, resp.getWriter());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;700&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span> <span class="hljs-attr">th:alt</span>=<span class="hljs-string">&quot;$&#123;alt&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;700&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span> <span class="hljs-attr">th:alt</span>=<span class="hljs-string">&quot;$&#123;alt&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>></span><br></code></pre></td></tr></table></figure><p>现在访问我们的页面，就可以看到替换后的结果了。</p><p>Thymeleaf还可以进行一些算术运算，几乎Java中的运算它都可以支持：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;value % 2&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;value % 2&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>同样的，它还支持三元运算：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;value % 2 == 0 ? &#x27;yyds&#x27; : &#x27;lbwnb&#x27;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;value % 2 == 0 ? &#x27;yyds&#x27; : &#x27;lbwnb&#x27;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>多个属性也可以通过<code>+</code>进行拼接，就像Java中的字符串拼接一样，这里要注意一下，字符串不能直接写，要添加单引号：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;name&#125;+&#x27; 我是文本 &#x27;+$&#123;value&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;name&#125;+&#x27; 我是文本 &#x27;+$&#123;value&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><h3 id="Thymeleaf流程控制语法"><a href="#Thymeleaf流程控制语法" class="headerlink" title="Thymeleaf流程控制语法"></a>Thymeleaf流程控制语法</h3><p>除了一些基本的操作，我们还可以使用Thymeleaf来处理流程控制语句，当然，不是直接编写Java代码的形式，而是添加一个属性即可。</p><p>首先我们来看if判断语句，如果if条件满足，则此标签留下，若if条件不满足，则此标签自动被移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">&quot;eval&quot;</span>, <span class="hljs-keyword">true</span>);<br>    engine.process(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">&quot;eval&quot;</span>, <span class="hljs-keyword">true</span>);<br>    engine.process(<span class="hljs-string">"test.html"</span>, context, resp.getWriter());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;eval&#125;&quot;</span>&gt;</span>我是判断条件标签<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;eval&#125;&quot;</span>&gt;</span>我是判断条件标签<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p><code>th:if</code>会根据其中传入的值或是条件表达式的结果进行判断，只有满足的情况下，才会显示此标签，具体的判断规则如下：</p><ul><li>如果值不是空的：<ul><li>如果值是布尔值并且为<code>true</code>。</li><li>如果值是一个数字，并且是非零</li><li>如果值是一个字符，并且是非零</li><li>如果值是一个字符串，而不是“错误”、“关闭”或“否”</li><li>如果值不是布尔值、数字、字符或字符串。</li></ul></li><li>如果值为空，th:if将计算为false</li></ul><p><code>th:if</code>还有一个相反的属性<code>th:unless</code>，效果完全相反，这里就不演示了。</p><p>我们接着来看多分支条件判断，我们可以使用<code>th:switch</code>属性来实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">&quot;$&#123;eval&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>我是1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>我是2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>我是3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">&quot;$&#123;eval&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>我是1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>我是2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>我是3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>只不过没有default属性，但是我们可以使用<code>th:case=&quot;*&quot;</code>来代替：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;*&quot;</span>&gt;</span>我是Default<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;*&quot;</span>&gt;</span>我是Default<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>最后我们再来看看，它如何实现遍历，假如我们有一个存放书籍信息的List需要显示，那么如何快速生成一个列表呢？我们可以使用<code>th:each</code>来进行遍历操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">&quot;list&quot;</span>, Arrays.asList(<span class="hljs-string">&quot;伞兵一号的故事&quot;</span>, <span class="hljs-string">&quot;倒一杯卡布奇诺&quot;</span>, <span class="hljs-string">&quot;玩游戏要啸着玩&quot;</span>, <span class="hljs-string">&quot;十七张牌前的电脑屏幕&quot;</span>));<br>    engine.process(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    Context context = <span class="hljs-keyword">new</span> Context();<br>    context.setVariable(<span class="hljs-string">&quot;list&quot;</span>, Arrays.asList(<span class="hljs-string">&quot;伞兵一号的故事&quot;</span>, <span class="hljs-string">&quot;倒一杯卡布奇诺&quot;</span>, <span class="hljs-string">&quot;玩游戏要啸着玩&quot;</span>, <span class="hljs-string">&quot;十七张牌前的电脑屏幕&quot;</span>));<br>    engine.process(<span class="hljs-string">"test.html"</span>, context, resp.getWriter());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;title : $&#123;list&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;title : $&#123;list&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>></span><br></code></pre></td></tr></table></figure><p><code>th:each</code>中需要填写 “单个元素名称 : ${列表}”，这样，所有的列表项都可以使用遍历的单个元素，只要使用了<code>th:each</code>，都会被循环添加。因此最后生成的结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《伞兵一号的故事》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《倒一杯卡布奇诺》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《玩游戏要啸着玩》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《十七张牌前的电脑屏幕》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《伞兵一号的故事》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《倒一杯卡布奇诺》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《玩游戏要啸着玩》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>《十七张牌前的电脑屏幕》<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>></span><br></code></pre></td></tr></table></figure><p>我们还可以获取当前循环的迭代状态，只需要在最后添加<code>iterStat</code>即可，从中可以获取很多信息，比如当前的顺序：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;title, iterStat : $&#123;list&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;title, iterStat : $&#123;list&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>></span><br></code></pre></td></tr></table></figure><p>状态变量在<code>th:each</code>属性中定义，并包含以下数据：</p><ul><li>当前<em>迭代索引</em>，以0开头。这是<code>index</code>属性。</li><li>当前<em>迭代索引</em>，以1开头。这是<code>count</code>属性。</li><li>迭代变量中的元素总量。这是<code>size</code>属性。</li><li>每个迭代的<em>迭代变量</em>。这是<code>current</code>属性。</li><li>当前迭代是偶数还是奇数。这些是<code>even/odd</code>布尔属性。</li><li>当前迭代是否是第一个迭代。这是<code>first</code>布尔属性。</li><li>当前迭代是否是最后一个迭代。这是<code>last</code>布尔属性。</li></ul><p>通过了解了流程控制语法，现在我们就可以很轻松地使用Thymeleaf来快速替换页面中的内容了。</p><h3 id="Thymeleaf模板布局"><a href="#Thymeleaf模板布局" class="headerlink" title="Thymeleaf模板布局"></a>Thymeleaf模板布局</h3><p>在某些网页中，我们会发现，整个网站的页面，除了中间部分的内容会随着我们的页面跳转而变化外，有些部分是一直保持一个状态的，比如打开小破站，我们翻动评论或是切换视频分P的时候，变化的仅仅是对应区域的内容，实际上，其他地方的内容会无论内部页面如何跳转，都不会改变。</p><p>Thymeleaf就可以轻松实现这样的操作，我们只需要将不会改变的地方设定为模板布局，并在不同的页面中插入这些模板布局，就无需每个页面都去编写同样的内容了。现在我们来创建两个页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;title, iterStat : $&#123;list&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;title, iterStat : $&#123;list&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>></span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这个页面的样子是这样的<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这个页面的样子是这样的<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>></span><br></code></pre></td></tr></table></figure><p>接着将模板引擎写成工具类的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> TemplateEngine engine;<br>    <span class="hljs-keyword">static</span>  &#123;<br>        engine = <span class="hljs-keyword">new</span> TemplateEngine();<br>        ClassLoaderTemplateResolver r = <span class="hljs-keyword">new</span> ClassLoaderTemplateResolver();<br>        engine.setTemplateResolver(r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TemplateEngine <span class="hljs-title">getEngine</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> TemplateEngine engine;<br>    <span class="hljs-keyword">static</span>  &#123;<br>        engine = <span class="hljs-keyword">new</span> TemplateEngine();<br>        ClassLoaderTemplateResolver r = <span class="hljs-keyword">new</span> ClassLoaderTemplateResolver();<br>        engine.setTemplateResolver(r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TemplateEngine <span class="hljs-title">getEngine</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> engine;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@WebServlet(&quot;/index2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        ThymeleafUtil.getEngine().process(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@WebServlet(&quot;/index2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        ThymeleafUtil.getEngine().process(<span class="hljs-string">"test2.html"</span>, context, resp.getWriter());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在就有两个Servlet分别对应两个页面了，但是这两个页面实际上是存在重复内容的，我们要做的就是将这些重复内容提取出来。</p><p>我们单独编写一个<code>head.html</code>来存放重复部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;head-title&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;head-title&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>></span><br></code></pre></td></tr></table></figure><p>现在，我们就可以直接将页面中的内容快速替换：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:include</span>=<span class="hljs-string">&quot;head.html::head-title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;title, iterStat : $&#123;list&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:include</span>=<span class="hljs-string">&quot;head.html::head-title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;title, iterStat : $&#123;list&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>我们可以使用<code>th:insert</code>和<code>th:replace</code>和<code>th:include</code>这三种方法来进行页面内容替换，那么<code>th:insert</code>和<code>th:replace</code>（和<code>th:include</code>，自3.0年以来不推荐）有什么区别？</p><ul><li><code>th:insert</code>最简单：它只会插入指定的片段作为标签的主体。</li><li><code>th:replace</code>实际上将标签直接<em>替换</em>为指定的片段。</li><li><code>th:include</code>和<code>th:insert</code>相似，但它没有插入片段，而是只插入此片段<em>的内容</em>。</li></ul><p>你以为这样就完了吗？它还支持参数传递，比如我们现在希望插入二级标题，并且由我们的子页面决定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;head-title&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;head-title&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>稍加修改，就像JS那样添加一个参数名称：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;head-title(sub)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;sub&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;head-title(sub)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题内容，每个页面都有<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;sub&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>现在直接在替换位置添加一个参数即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:include</span>=<span class="hljs-string">&quot;head.html::head-title(&#x27;这个是第1个页面的二级标题&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;title, iterStat : $&#123;list&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:include</span>=<span class="hljs-string">&quot;head.html::head-title(&#x27;这个是第1个页面的二级标题&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;title, iterStat : $&#123;list&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span><br></code></pre></td></tr></table></figure><p>这样，不同的页面还有着各自的二级标题。</p><hr><h2 id="探讨Tomcat类加载机制"><a href="#探讨Tomcat类加载机制" class="headerlink" title="探讨Tomcat类加载机制"></a>探讨Tomcat类加载机制</h2><p>有关JavaWeb的内容，我们就聊到这里，在最后，我们还是来看一下Tomcat到底是如何加载和运行我们的Web应用程序的。</p><p>Tomcat服务器既然要同时运行多个Web应用程序，那么就必须要实现不同应用程序之间的隔离，也就是说，Tomcat需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问，而传统的类加载机制无法做到这一点，同时每个应用程序都有自己的依赖，如果两个应用程序使用了同一个版本的同一个依赖，那么还有必要去重新加载吗，带着诸多问题，Tomcat服务器编写了一套自己的类加载机制。</p><p><img src="https://images2018.cnblogs.com/blog/137084/201805/137084-20180526104342525-959933190.png" alt="img"></p><p>首先我们要知道，Tomcat本身也是一个Java程序，它要做的是去动态加载我们编写的Web应用程序中的类，而要解决以上提到的一些问题，就出现了几个新的类加载器，我们来看看各个加载器的不同之处：</p><ul><li>Common ClassLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Web应用程序访问。</li><li>Catalina ClassLoader：Tomcat容器私有的类加载器，加载路径中的class对于Web应用程序不可见。</li><li>Shared ClassLoader：各个Web应用程序共享的类加载器，加载路径中的class对于所有Web应用程序可见，但是对于Tomcat容器不可见。</li><li>Webapp ClassLoader：各个Web应用程序私有的类加载器，加载路径中的class只对当前Web应用程序可见，每个Web应用程序都有一个自己的类加载器，此加载器可能存在多个实例。</li><li>JasperLoader：JSP类加载器，每个JSP文件都有一个自己的类加载器，也就是说，此加载器可能会存在多个实例。</li></ul><p>通过这样进行划分，就很好地解决了我们上面所提到的问题，但是我们发现，这样的类加载机制，破坏了JDK的<code>双亲委派机制</code>（在JavaSE阶段讲解过），比如Webapp ClassLoader，它只加载自己的class文件，它没有将类交给父类加载器进行加载，也就是说，我们可以随意创建和JDK同包同名的类，岂不是就出问题了？</p><p>难道Tomcat的开发团队没有考虑到这个问题吗？</p><p><img src="https://images0.cnblogs.com/blog2015/449064/201506/141304597074685.jpg" alt="img"></p><p>实际上，WebAppClassLoader的加载机制是这样的：WebAppClassLoader 加载类的时候，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。这样的话，如果定义了同包同名的类，就不会被加载，而如果是自己定义 的类，由于该类并不是JDK内部或是扩展类，所有不会被加载，而是再次回到WebAppClassLoader进行加载，如果还失败，再使用AppClassloader进行加载。</p><hr><h2 id="实战：编写图书管理系统"><a href="#实战：编写图书管理系统" class="headerlink" title="实战：编写图书管理系统"></a>实战：编写图书管理系统</h2><p>图书管理系统需要再次迎来升级，现在，我们可以直接访问网站来操作图书，这里我们给大家提供一个前端模板直接编写，省去编写前端的时间。</p><p>本次实战使用到的框架：Servlet+Mybatis+Thymeleaf</p><p>注意在编写的时候，为了使得整体的代码简洁高效，我们严格遵守三层架构模式：</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/08/1535337833-4838-1359192395-1143.png" alt="img"></p><p>就是说，表示层只做UI，包括接受请求和相应，给模板添加上下文，以及进行页面的解析，最后响应给浏览器；业务逻辑层才是用于进行数据处理的地方，表示层需要向逻辑层索要数据，才能将数据添加到模板的上下文中；数据访问层一般就是连接数据库，包括增删改查等基本的数据库操作，业务逻辑层如果需要从数据库取数据，就需要向数据访问层请求数据。</p><p>当然，贯穿三大层次的当属实体类了，我们还需要创建对应的实体类进行数据的封装，以便于在三层架构中进行数据传递。</p><p>接下来，明确我们要实现的功能，也就是项目需求：</p><ul><li>图书管理员的登陆和退出（只有登陆之后才能进入管理页面）</li><li>图书的列表浏览（包括书籍是否被借出的状态也要进行显示）以及图书的添加和删除</li><li>学生的列表浏览</li><li>查看所有的借阅列表，添加借阅信息</li></ul><hr><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>首先祝贺各位顺利完成了JavaWeb相关知识的学习。</p><p>本教程创作的动力离不开各位观众姥爷们的支持，我们也会在后面为大家录制更多的Java技术栈教程，如果您喜欢本系列视频的话，直接用三连狠狠的砸向UP主吧！</p><p>虽然我们现在已经学会了如何去编写一个网站，但是实际上，这样的开发模式已经过时（不过拿去当毕设当期末设计直接无敌好吧），我们还需要继续深入了解更加现代化的开发模式，这样我们才有机会参与到企业的项目开发当中。</p><p>希望在后续的视频中，还能看到各位的身影，完结撒花！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/16/2.html/"/>
      <url>/2022/03/16/2.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Java与数据库"><a href="#Java与数据库" class="headerlink" title="Java与数据库"></a>Java与数据库</h1><p>通过Java如何去使用数据库来帮助我们存储数据呢，这将是本章节讨论的重点。</p><h2 id="初识JDBC"><a href="#初识JDBC" class="headerlink" title="初识JDBC"></a>初识JDBC</h2><p>JDBC是什么？JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。</p><p>我们可以发现，JDK自带了一个<code>java.sql</code>包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为<code>数据库驱动</code>。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>那么我们首先来进行一些准备工作，以便开始JDBC的学习：</p><ul><li>将idea连接到我们的数据库，以便以后调试。</li><li>将mysql驱动jar依赖导入到项目中（推荐6.0版本以上，这里用到是8.0）</li><li>向Jetbrians申请一个学生/教师授权，用于激活idea终极版（进行JavaWeb开发需要用到，一般申请需要3-7天时间审核）不是大学生的话…emmm…懂的都懂。</li><li>教育授权申请地址：<a href="https://www.jetbrains.com/shop/eform/students">https://www.jetbrains.com/shop/eform/students</a></li></ul><p>一个Java程序并不是一个人的战斗，我们可以在别人开发的基础上继续向上开发，其他的开发者可以将自己编写的Java代码打包为<code>jar</code>，我们只需要导入这个<code>jar</code>作为依赖，即可直接使用别人的代码，就像我们直接去使用JDK提供的类一样。</p><h3 id="使用JDBC连接数据库"><a href="#使用JDBC连接数据库" class="headerlink" title="使用JDBC连接数据库"></a>使用JDBC连接数据库</h3><p><strong>注意：</strong>6.0版本以上，不用手动加载驱动，我们直接使用即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//1. 通过DriverManager来获得数据库连接</span><br><span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;连接URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>     <span class="hljs-comment">//2. 创建一个用于执行SQL的Statement对象</span><br>     Statement statement = connection.createStatement())&#123;   <span class="hljs-comment">//注意前两步都放在try()中，因为在最后需要释放资源！</span><br>    <span class="hljs-comment">//3. 执行SQL语句，并得到结果集</span><br>    ResultSet set = statement.executeQuery(<span class="hljs-string">&quot;select * from 表名&quot;</span>);<br>    <span class="hljs-comment">//4. 查看结果</span><br>    <span class="hljs-keyword">while</span> (set.next())&#123;<br>        ...<br>    &#125;<br>&#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//1. 通过DriverManager来获得数据库连接</span><br><span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;连接URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>     <span class="hljs-comment">//2. 创建一个用于执行SQL的Statement对象</span><br>     Statement statement = connection.createStatement())&#123;   <span class="hljs-comment">//注意前两步都放在try()中，因为在最后需要释放资源！</span><br>    <span class="hljs-comment">//3. 执行SQL语句，并得到结果集</span><br>    ResultSet set = statement.executeQuery(<span class="hljs-string">&quot;select * from 表名&quot;</span>);<br>    <span class="hljs-comment">//4. 查看结果</span><br>    <span class="hljs-keyword">while</span> (set.next())&#123;<br>        ...<br>    &#125;<br>&#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//5. 释放资源，try-with-resource语法会自动帮助我们close</span><br></code></pre></td></tr></table></figure><p>其中，连接的URL如果记不住格式，我们可以打开idea的数据库连接配置，复制一份即可。（其实idea本质也是使用的JDBC，整个idea程序都是由Java编写的，实际上idea就是一个Java程序）</p><h3 id="了解DriverManager"><a href="#了解DriverManager" class="headerlink" title="了解DriverManager"></a>了解DriverManager</h3><p>我们首先来了解一下DriverManager是什么东西，它其实就是管理我们的数据库驱动的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDriver</span><span class="hljs-params">(java.sql.Driver driver,</span></span><br><span class="hljs-params"><span class="hljs-function">        DriverAction da)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br><br>    <span class="hljs-comment">/* Register the driver if it has not already been added to our list */</span><br>    <span class="hljs-keyword">if</span>(driver != <span class="hljs-keyword">null</span>) &#123;<br>        registeredDrivers.addIfAbsent(<span class="hljs-keyword">new</span> DriverInfo(driver, da));    <span class="hljs-comment">//在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// This is for compatibility with the original DriverManager</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br><br>    println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDriver</span><span class="hljs-params">(java.sql.Driver driver,</span></span><br><span class="hljs-params"><span class="hljs-function">        DriverAction da)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br><br>    <span class="hljs-comment">/* Register the driver if it has not already been added to our list */</span><br>    <span class="hljs-keyword">if</span>(driver != <span class="hljs-keyword">null</span>) &#123;<br>        registeredDrivers.addIfAbsent(<span class="hljs-keyword">new</span> DriverInfo(driver, da));    <span class="hljs-comment">//在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// This is for compatibility with the original DriverManager</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br><br>    println(<span class="hljs-string">"registerDriver: "</span> + driver);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过调用getConnection()来进行数据库的链接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url,</span></span><br><span class="hljs-params"><span class="hljs-function">    String user, String password)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    java.util.Properties info = <span class="hljs-keyword">new</span> java.util.Properties();<br><br>    <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>) &#123;<br>        info.put(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (password != <span class="hljs-keyword">null</span>) &#123;<br>        info.put(<span class="hljs-string">&quot;password&quot;</span>, password);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url,</span></span><br><span class="hljs-params"><span class="hljs-function">    String user, String password)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    java.util.Properties info = <span class="hljs-keyword">new</span> java.util.Properties();<br><br>    <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>) &#123;<br>        info.put(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (password != <span class="hljs-keyword">null</span>) &#123;<br>        info.put(<span class="hljs-string">&quot;password&quot;</span>, password);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));   <span class="hljs-comment">//内部有实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以手动为驱动管理器添加一个日志打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">static</span> &#123;<br>    DriverManager.setLogWriter(<span class="hljs-keyword">new</span> PrintWriter(System.out));   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">static</span> &#123;<br>    DriverManager.setLogWriter(<span class="hljs-keyword">new</span> PrintWriter(System.out));   <span class="hljs-comment">//这里直接设定为控制台输出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们执行的数据库操作日志会在控制台实时打印。</p><h3 id="了解Connection"><a href="#了解Connection" class="headerlink" title="了解Connection"></a>了解Connection</h3><p>Connection是数据库的连接对象，可以通过连接对象来创建一个Statement用于执行SQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function">Statement <span class="hljs-title">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function">Statement <span class="hljs-title">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException</span>;<br></code></pre></td></tr></table></figure><p>我们发现除了普通的Statement，还存在PreparedStatement：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function">PreparedStatement <span class="hljs-title">prepareStatement</span><span class="hljs-params">(String sql)</span></span><br><span class="hljs-function">    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function">PreparedStatement <span class="hljs-title">prepareStatement</span><span class="hljs-params">(String sql)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> SQLException</span>;<br></code></pre></td></tr></table></figure><p>在后面我们会详细介绍PreparedStatement的使用，它能够有效地预防SQL注入式攻击。</p><p>它还支持事务的处理，也放到后面来详细进行讲解。</p><h3 id="了解Statement"><a href="#了解Statement" class="headerlink" title="了解Statement"></a>了解Statement</h3><p>我们发现，我们之前使用了<code>executeQuery()</code>方法来执行<code>select</code>语句，此方法返回给我们一个ResultSet对象，查询得到的数据，就存放在ResultSet中！</p><p>Statement除了执行这样的DQL语句外，我们还可以使用<code>executeUpdate()</code>方法来执行一个DML或是DDL语句，它会返回一个int类型，表示执行后受影响的行数，可以通过它来判断DML语句是否执行成功。</p><p>也可以通过<code>excute()</code>来执行任意的SQL语句，它会返回一个<code>boolean</code>来表示执行结果是一个ResultSet还是一个int，我们可以通过使用<code>getResultSet()</code>或是<code>getUpdateCount()</code>来获取。</p><h3 id="执行DML操作"><a href="#执行DML操作" class="headerlink" title="执行DML操作"></a>执行DML操作</h3><p>我们通过几个例子来向数据库中插入数据。</p><h3 id="执行DQL操作"><a href="#执行DQL操作" class="headerlink" title="执行DQL操作"></a>执行DQL操作</h3><p>执行DQL操作会返回一个ResultSet对象，我们来看看如何从ResultSet中去获取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//首先要明确，select返回的数据类似于一个excel表格</span><br><span class="hljs-keyword">while</span> (set.next())&#123;<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//首先要明确，select返回的数据类似于一个excel表格</span><br><span class="hljs-keyword">while</span> (set.next())&#123;<br>    <span class="hljs-comment">//每调用一次next()就会向下移动一行，首次调用会移动到第一行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在移动行数后，就可以通过set中提供的方法，来获取每一列的数据。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F202005062358238.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZ2lubw%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638091193&t=bf37a5cb988d0a641d00c7e325d06ce7" alt="img"></p><h3 id="执行批处理操作"><a href="#执行批处理操作" class="headerlink" title="执行批处理操作"></a>执行批处理操作</h3><p>当我们要执行很多条语句时，可以不用一次一次地提交，而是一口气全部交给数据库处理，这样会节省很多的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection();<br>         Statement statement = connection.createStatement())&#123;<br><br>        statement.addBatch(<span class="hljs-string">&quot;insert into user values (&#x27;f&#x27;, 1234)&quot;</span>);<br>        statement.addBatch(<span class="hljs-string">&quot;insert into user values (&#x27;e&#x27;, 1234)&quot;</span>);   <span class="hljs-comment">//添加每一条批处理语句</span><br>        statement.executeBatch();   <span class="hljs-comment">//一起执行</span><br><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection();<br>         Statement statement = connection.createStatement())&#123;<br><br>        statement.addBatch(<span class="hljs-string">&quot;insert into user values (&#x27;f&#x27;, 1234)&quot;</span>);<br>        statement.addBatch(<span class="hljs-string">&quot;insert into user values (&#x27;e&#x27;, 1234)&quot;</span>);   <span class="hljs-comment">//添加每一条批处理语句</span><br>        statement.executeBatch();   <span class="hljs-comment">//一起执行</span><br><br>    &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将查询结果映射为对象"><a href="#将查询结果映射为对象" class="headerlink" title="将查询结果映射为对象"></a>将查询结果映射为对象</h3><p>既然我们现在可以从数据库中获取数据了，那么现在就可以将这些数据转换为一个类来进行操作，首先定义我们的实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    Integer sid;<br>    String name;<br>    String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(Integer sid, String name, String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sid = sid;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我叫：&quot;</span>+name+<span class="hljs-string">&quot;，学号为：&quot;</span>+sid+<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    Integer sid;<br>    String name;<br>    String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(Integer sid, String name, String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sid = sid;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我叫：&quot;</span>+name+<span class="hljs-string">&quot;，学号为：&quot;</span>+sid+<span class="hljs-string">"，我的性别是："</span>+sex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来进行一个转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">while</span> (set.next())&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(set.getInt(<span class="hljs-number">1</span>), set.getString(<span class="hljs-number">2</span>), set.getString(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">while</span> (set.next())&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(set.getInt(<span class="hljs-number">1</span>), set.getString(<span class="hljs-number">2</span>), set.getString(<span class="hljs-number">3</span>));<br>    student.say();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>列的下标是从1开始的。</p><p>我们也可以利用反射机制来将查询结果映射为对象，使用反射的好处是，无论什么类型都可以通过我们的方法来进行实体类型映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">convert</span><span class="hljs-params">(ResultSet set, Class&lt;T&gt; clazz)</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Constructor&lt;T&gt; constructor = clazz.getConstructor(clazz.getConstructors()[<span class="hljs-number">0</span>].getParameterTypes());   <span class="hljs-comment">//默认获取第一个构造方法</span><br>        Class&lt;?&gt;[] param = constructor.getParameterTypes();  <span class="hljs-comment">//获取参数列表</span><br>        Object[] object = <span class="hljs-keyword">new</span> Object[param.length];  <span class="hljs-comment">//存放参数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; param.length; i++) &#123;   <span class="hljs-comment">//是从1开始的</span><br>            object[i] = set.getObject(i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(object[i].getClass() != param[i])<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">&quot;错误的类型转换：&quot;</span>+object[i].getClass()+<span class="hljs-string">&quot; -&gt; &quot;</span>+param[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> constructor.newInstance(object);<br>    &#125; <span class="hljs-keyword">catch</span> (ReflectiveOperationException | SQLException e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">convert</span><span class="hljs-params">(ResultSet set, Class&lt;T&gt; clazz)</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Constructor&lt;T&gt; constructor = clazz.getConstructor(clazz.getConstructors()[<span class="hljs-number">0</span>].getParameterTypes());   <span class="hljs-comment">//默认获取第一个构造方法</span><br>        Class&lt;?&gt;[] param = constructor.getParameterTypes();  <span class="hljs-comment">//获取参数列表</span><br>        Object[] object = <span class="hljs-keyword">new</span> Object[param.length];  <span class="hljs-comment">//存放参数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; param.length; i++) &#123;   <span class="hljs-comment">//是从1开始的</span><br>            object[i] = set.getObject(i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(object[i].getClass() != param[i])<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">&quot;错误的类型转换：&quot;</span>+object[i].getClass()+<span class="hljs-string">&quot; -&gt; &quot;</span>+param[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> constructor.newInstance(object);<br>    &#125; <span class="hljs-keyword">catch</span> (ReflectiveOperationException | SQLException e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以通过我们的方法来将查询结果转换为一个对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">while</span> (set.next())&#123;<br>    Student student = convert(set, Student.class);<br>    <span class="hljs-keyword">if</span>(student != <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">while</span> (set.next())&#123;<br>    Student student = convert(set, Student.class);<br>    <span class="hljs-keyword">if</span>(student != <span class="hljs-keyword">null</span>) student.say();<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，在后面我们会学习Mybatis框架，它对JDBC进行了深层次的封装，而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换。</p><h3 id="实现登陆与SQL注入攻击"><a href="#实现登陆与SQL注入攻击" class="headerlink" title="实现登陆与SQL注入攻击"></a>实现登陆与SQL注入攻击</h3><p>在使用之前，我们先来看看如果我们想模拟登陆一个用户，我们该怎么去写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>     Statement statement = connection.createStatement();<br>     Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>    ResultSet res = statement.executeQuery(<span class="hljs-string">&quot;select * from user where username=&#x27;&quot;</span>+scanner.nextLine()+<span class="hljs-string">&quot;&#x27;and pwd=&#x27;&quot;</span>+scanner.nextLine()+<span class="hljs-string">&quot;&#x27;;&quot;</span>);<br>    <span class="hljs-keyword">while</span> (res.next())&#123;<br>        String username = res.getString(<span class="hljs-number">1</span>);<br>        System.out.println(username+<span class="hljs-string">&quot; 登陆成功！&quot;</span>);<br>    &#125;<br>&#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>     Statement statement = connection.createStatement();<br>     Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>    ResultSet res = statement.executeQuery(<span class="hljs-string">&quot;select * from user where username=&#x27;&quot;</span>+scanner.nextLine()+<span class="hljs-string">&quot;&#x27;and pwd=&#x27;&quot;</span>+scanner.nextLine()+<span class="hljs-string">&quot;&#x27;;&quot;</span>);<br>    <span class="hljs-keyword">while</span> (res.next())&#123;<br>        String username = res.getString(<span class="hljs-number">1</span>);<br>        System.out.println(username+<span class="hljs-string">&quot; 登陆成功！&quot;</span>);<br>    &#125;<br>&#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>用户可以通过自己输入用户名和密码来登陆，乍一看好像没啥问题，那如果我输入的是以下内容呢：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sql">Test<br><span class="hljs-number">1111</span><span class="hljs-string">&#x27; or 1=1; -- </span><br><span class="hljs-string"><code class="language-hljs sql">Test<br><span class="hljs-number">1111</span><span class="hljs-string">&#x27; or 1=1; -- </span><br><span class="hljs-string"># Test 登陆成功！</span><br></code></pre></td></tr></table></figure><p>1=1一定是true，那么我们原本的SQL语句会变为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Test&#x27;</span> <span class="hljs-keyword">and</span> pwd<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1111&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment"><code class="language-hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Test&#x27;</span> <span class="hljs-keyword">and</span> pwd<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1111&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment">-- &#x27;</span><br></code></pre></td></tr></table></figure><p>我们发现，如果允许这样的数据插入，那么我们原有的SQL语句结构就遭到了破坏，使得用户能够随意登陆别人的账号。因此我们可能需要限制用户的输入来防止用户输入一些SQL语句关键字，但是关键字非常多，这并不是解决问题的最好办法。</p><h3 id="使用PreparedStatement"><a href="#使用PreparedStatement" class="headerlink" title="使用PreparedStatement"></a>使用PreparedStatement</h3><p>我们发现，如果单纯地使用Statement来执行SQL命令，会存在严重的SQL注入攻击漏洞！而这种问题，我们可以使用PreparedStatement来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>         PreparedStatement statement = connection.prepareStatement(<span class="hljs-string">&quot;select * from user where username= ? and pwd=?;&quot;</span>);<br>         Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br><br>        statement.setString(<span class="hljs-number">1</span>, scanner.nextLine());<br>        statement.setString(<span class="hljs-number">2</span>, scanner.nextLine());<br>        System.out.println(statement);    <span class="hljs-comment">//打印查看一下最终执行的</span><br>        ResultSet res = statement.executeQuery();<br>        <span class="hljs-keyword">while</span> (res.next())&#123;<br>            String username = res.getString(<span class="hljs-number">1</span>);<br>            System.out.println(username+<span class="hljs-string">&quot; 登陆成功！&quot;</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>         PreparedStatement statement = connection.prepareStatement(<span class="hljs-string">&quot;select * from user where username= ? and pwd=?;&quot;</span>);<br>         Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br><br>        statement.setString(<span class="hljs-number">1</span>, scanner.nextLine());<br>        statement.setString(<span class="hljs-number">2</span>, scanner.nextLine());<br>        System.out.println(statement);    <span class="hljs-comment">//打印查看一下最终执行的</span><br>        ResultSet res = statement.executeQuery();<br>        <span class="hljs-keyword">while</span> (res.next())&#123;<br>            String username = res.getString(<span class="hljs-number">1</span>);<br>            System.out.println(username+<span class="hljs-string">&quot; 登陆成功！&quot;</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，我们需要提前给到PreparedStatement一个SQL语句，并且使用<code>?</code>作为占位符，它会预编译一个SQL语句，通过直接将我们的内容进行替换的方式来填写数据。使用这种方式，我们之前的例子就失效了！我们来看看实际执行的SQL语句是什么：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs n1ql">com.mysql.cj.jdbc.ClientPreparedStatement: <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username= <span class="hljs-string">&#x27;Test&#x27;</span> <span class="hljs-keyword">and</span> pwd=<span class="hljs-string">&#x27;123456&#x27;</span><span class="hljs-string"><code class="language-hljs n1ql">com.mysql.cj.jdbc.ClientPreparedStatement: <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username= <span class="hljs-string">&#x27;Test&#x27;</span> <span class="hljs-keyword">and</span> pwd=<span class="hljs-string">&#x27;123456&#x27;</span><span class="hljs-string">&#x27; or 1=1; -- &#x27;</span>;<br></code></pre></td></tr></table></figure><p>我们发现，我们输入的参数一旦出现<code>&#39;</code>时，会被变为转义形式<code>\&#39;</code>，而最外层有一个真正的<code>&#39;</code>来将我们输入的内容进行包裹，因此它能够有效地防止SQL注入攻击！</p><h3 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h3><p>JDBC默认的事务处理行为是自动提交，所以前面我们执行一个SQL语句就会被直接提交（相当于没有启动事务），所以JDBC需要进行事务管理时，首先要通过Connection对象调用setAutoCommit(false) 方法, 将SQL语句的提交（commit）由驱动程序转交给应用程序负责。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">con.setAutoCommit();   <span class="hljs-comment">//关闭自动提交后相当于开启事务。</span><br><span class="hljs-comment">// SQL语句</span><br><span class="hljs-comment">// SQL语句</span><br><span class="hljs-comment"><code class="language-hljs java">con.setAutoCommit();   <span class="hljs-comment">//关闭自动提交后相当于开启事务。</span><br><span class="hljs-comment">// SQL语句</span><br><span class="hljs-comment">// SQL语句</span><br><span class="hljs-comment">// SQL语句</span><br>con.commit();或 con.rollback();<br></code></pre></td></tr></table></figure><p>一旦关闭自动提交，那么现在执行所有的操作如果在最后不进行<code>commit()</code>来提交事务的话，那么所有的操作都会丢失，只有提交之后，所有的操作才会被保存！也可以使用<code>rollback()</code>来手动回滚之前的全部操作！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>         Statement statement = connection.createStatement())&#123;<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;</span>);<br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;</span>);<br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;</span>);<br><br>        connection.commit();   <span class="hljs-comment">//如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>         Statement statement = connection.createStatement())&#123;<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;</span>);<br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;</span>);<br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;</span>);<br><br>        connection.commit();   <span class="hljs-comment">//如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效</span><br>    &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来接着尝试一下使用回滚操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>         Statement statement = connection.createStatement())&#123;<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;</span>);<br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;</span>);<br><br>        connection.rollback();   <span class="hljs-comment">//回滚，撤销前面全部操作</span><br><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;</span>);<br><br>        connection.commit();   <span class="hljs-comment">//提交事务（注意，回滚之前的内容都没了）</span><br><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>         Statement statement = connection.createStatement())&#123;<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;</span>);<br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;</span>);<br><br>        connection.rollback();   <span class="hljs-comment">//回滚，撤销前面全部操作</span><br><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;</span>);<br><br>        connection.commit();   <span class="hljs-comment">//提交事务（注意，回滚之前的内容都没了）</span><br><br>    &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，我们也可以去创建一个回滚点来实现定点回滚：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>         Statement statement = connection.createStatement())&#123;<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;</span>);<br>        <br>        Savepoint savepoint = connection.setSavepoint();   <span class="hljs-comment">//创建回滚点</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;</span>);<br><br>        connection.rollback(savepoint);   <span class="hljs-comment">//回滚到回滚点，撤销前面全部操作</span><br><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;</span>);<br><br>        connection.commit();   <span class="hljs-comment">//提交事务（注意，回滚之前的内容都没了）</span><br><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>         Statement statement = connection.createStatement())&#123;<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;</span>);<br>        <br>        Savepoint savepoint = connection.setSavepoint();   <span class="hljs-comment">//创建回滚点</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;</span>);<br><br>        connection.rollback(savepoint);   <span class="hljs-comment">//回滚到回滚点，撤销前面全部操作</span><br><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;</span>);<br><br>        connection.commit();   <span class="hljs-comment">//提交事务（注意，回滚之前的内容都没了）</span><br><br>    &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过开启事务，我们就可以更加谨慎地进行一些操作了，如果我们想从事务模式切换为原有的自动提交模式，我们可以直接将其设置回去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>         Statement statement = connection.createStatement())&#123;<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;</span>);<br>        connection.setAutoCommit(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//重新开启自动提交，开启时把之前的事务模式下的内容给提交了</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;d&#x27;, 1234)&quot;</span>);<br>        <span class="hljs-comment">//没有commit也成功了！</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;URL&quot;</span>,<span class="hljs-string">&quot;用户名&quot;</span>,<span class="hljs-string">&quot;密码&quot;</span>);<br>         Statement statement = connection.createStatement())&#123;<br><br>        connection.setAutoCommit(<span class="hljs-keyword">false</span>);  <span class="hljs-comment">//关闭自动提交，现在将变为我们手动提交</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;</span>);<br>        connection.setAutoCommit(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//重新开启自动提交，开启时把之前的事务模式下的内容给提交了</span><br>        statement.executeUpdate(<span class="hljs-string">&quot;insert into user values (&#x27;d&#x27;, 1234)&quot;</span>);<br>        <span class="hljs-comment">//没有commit也成功了！</span><br>    &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>通过学习JDBC，我们现在就可以通过Java来访问和操作我们的数据库了！为了更好地衔接，我们还会接着讲解主流持久层框架——Mybatis，加深JDBC的记忆。</p><hr><h2 id="使用Lombok"><a href="#使用Lombok" class="headerlink" title="使用Lombok"></a>使用Lombok</h2><p>我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get/set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！</p><p>通过使用Lombok（小辣椒）就可以解决这样的问题！</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14004711543%2F1000&refer=http%3A%2F%2Finews.gtimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638080575&t=91a3937a42d14fe8129b3761bbdef82c" alt="img"></p><p>我们来看看，使用原生方式和小辣椒方式编写类的区别，首先是传统方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(Integer sid, String name, String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sid = sid;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getSid</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-comment">//长！</span><br>        <span class="hljs-keyword">return</span> sid;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSid</span><span class="hljs-params">(Integer sid)</span> </span>&#123;     <span class="hljs-comment">//到！</span><br>        <span class="hljs-keyword">this</span>.sid = sid;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-comment">//爆！</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-comment">//炸！</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(Integer sid, String name, String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sid = sid;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getSid</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-comment">//长！</span><br>        <span class="hljs-keyword">return</span> sid;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSid</span><span class="hljs-params">(Integer sid)</span> </span>&#123;     <span class="hljs-comment">//到！</span><br>        <span class="hljs-keyword">this</span>.sid = sid;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-comment">//爆！</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-comment">//炸！</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而使用Lombok之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！</p><h3 id="配置Lombok"><a href="#配置Lombok" class="headerlink" title="配置Lombok"></a>配置Lombok</h3><ul><li>首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：<a href="https://projectlombok.org/download">https://projectlombok.org/download</a></li><li>然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。</li><li>重启IDEA</li></ul><p>Lombok是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理。</p><p>Java的编译过程可以分成三个阶段：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL29wZW5qZGsuamF2YS5uZXQvZ3JvdXBzL2NvbXBpbGVyL2RvYy9jb21waWxhdGlvbi1vdmVydmlldy9qYXZhYy1mbG93LnBuZw?x-oss-process=image/format,png" alt="img"></p><ol><li>所有源文件会被解析成语法树。</li><li>调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。</li><li>最后，语法树会被分析并转化成类文件。</li></ol><p>实际上在上述的第二阶段，会执行*<a href="https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/core/AnnotationProcessor.java">lombok.core.AnnotationProcessor</a>*，它所做的工作就是我们上面所说的，修改语法树。</p><h3 id="使用Lombok-1"><a href="#使用Lombok-1" class="headerlink" title="使用Lombok"></a>使用Lombok</h3><p>我们通过实战来演示一下Lombok的实用注解：</p><ul><li>我们通过添加<code>@Getter</code>和<code>@Setter</code>来为当前类的所有字段生成get/set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。<ul><li>我们还可以使用@Accessors来控制生成Getter和Setter的样式。 </li></ul></li><li>我们通过添加<code>@ToString</code>来为当前类生成预设的toString方法。</li><li>我们可以通过添加<code>@EqualsAndHashCode</code>来快速生成比较和哈希值方法。</li><li>我们可以通过添加<code>@AllArgsConstructor</code>和<code>@NoArgsConstructor</code>来快速生成全参构造和无参构造。</li><li>我们可以添加<code>@RequiredArgsConstructor</code>来快速生成参数只包含<code>final</code>或被标记为<code>@NonNull</code>的成员字段。</li><li>使用<code>@Data</code>能代表<code>@Setter</code>、<code>@Getter</code>、<code>@RequiredArgsConstructor</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code>全部注解。<ul><li>一旦使用<code>@Data</code>就不建议此类有继承关系，因为<code>equal</code>方法可能不符合预期结果（尤其是仅比较子类属性）。</li></ul></li><li>使用<code>@Value</code>与<code>@Data</code>类似，但是并不会生成setter并且成员属性都是final的。</li><li>使用<code>@SneakyThrows</code>来自动生成try-catch代码块。</li><li>使用<code>@Cleanup</code>作用与局部变量，在最后自动调用其<code>close()</code>方法（可以自由更换）</li><li>使用<code>@Builder</code>来快速生成建造者模式。<ul><li>通过使用<code>@Builder.Default</code>来指定默认值。</li><li>通过使用<code>@Builder.ObtainVia</code>来指定默认值的获取方式。</li></ul></li></ul><hr><h2 id="认识Mybatis"><a href="#认识Mybatis" class="headerlink" title="认识Mybatis"></a>认识Mybatis</h2><p>在前面JDBC的学习中，虽然我们能够通过JDBC来连接和操作数据库，但是哪怕只是完成一个SQL语句的执行，都需要编写大量的代码，更不用说如果我还需要进行实体类映射，将数据转换为我们可以直接操作的实体类型，JDBC很方便，但是还不够方便，我们需要一种更加简洁高效的方式来和数据库进行交互。</p><p><strong>再次强调：</strong>学习厉害的框架或是厉害的技术，并不是为了一定要去使用它，而是它们能够使得我们在不同的开发场景下，合理地使用这些技术，以灵活地应对需要解决的问题。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F26720164-60462fc7927f8784.jpg&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638550660&t=a0923b35afbaed1a168b74eb45ad2b4f" alt="img"></p><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p><p>我们依然使用传统的jar依赖方式，从最原始开始讲起，不使用Maven，有关Maven内容我们会在后面统一讲解！全程围绕官方文档讲解！</p><p>这一块内容很多很杂，再次强调要多实践！</p><h3 id="XML语言概述"><a href="#XML语言概述" class="headerlink" title="XML语言概述"></a>XML语言概述</h3><p>在开始介绍Mybatis之前，XML语言发明最初是用于数据的存储和传输，它可以长这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">outer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿伟<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>怎么又在玩电动啊<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">inner</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sex</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">sex</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">inner</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">outer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿伟<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>怎么又在玩电动啊<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">inner</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sex</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">sex</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">inner</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">outer</span>></span><br></code></pre></td></tr></table></figure><p>如果你学习过前端知识，你会发现它和HTML几乎长得一模一样！但是请注意，虽然它们长得差不多，但是他们的意义却不同，HTML主要用于通过编排来展示数据，而XML主要是存放数据，它更像是一个配置文件！当然，浏览器也是可以直接打开XML文件的。</p><p>一个XML文件存在以下的格式规范：</p><ul><li>必须存在一个根节点，将所有的子标签全部包含。</li><li>可以但不必须包含一个头部声明（主要是可以设定编码格式）</li><li>所有的标签必须成对出现，可以嵌套但不能交叉嵌套</li><li>区分大小写。</li><li>标签中可以存在属性，比如上面的<code>type=&quot;1&quot;</code>就是<code>inner</code>标签的一个属性，属性的值由单引号或双引号包括。</li></ul><p>XML文件也可以使用注释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-comment"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-comment"><!-- 注释内容 --></span><br></code></pre></td></tr></table></figure><p>通过IDEA我们可以使用<code>Ctrl</code>+<code>/</code>来快速添加注释文本（不仅仅适用于XML，还支持很多种类型的文件）</p><p>那如果我们的内容中出现了<code>&lt;</code>或是<code>&gt;</code>字符，那该怎么办呢？我们就可以使用XML的转义字符来代替：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.jxdoc.com%2Fpic%2F28d1ff67caaedd3383c4d358%2F1-332-jpg_6_0_______-505-0-0-505.jpg&refer=http%3A%2F%2Fimg.jxdoc.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639322216&t=88d1ea1adb9cbf1611eaf4c9fa16b8b0" alt="img"></p><p>如果嫌一个一个改太麻烦，也可以使用CD来快速创建不解析区域：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">test</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>&lt;![CDATA[我看你&lt;&gt;&lt;&gt;&lt;&gt;是一点都不懂哦&gt;&gt;&gt;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">test</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>&lt;![CDATA[我看你&lt;&gt;&lt;&gt;&lt;&gt;是一点都不懂哦&gt;&gt;&gt;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">test</span>></span><br></code></pre></td></tr></table></figure><p>那么，我们现在了解了XML文件的定义，现在该如何去解析一个XML文件呢？比如我们希望将定义好的XML文件读取到Java程序中，这时该怎么做呢？</p><p>JDK为我们内置了一个叫做<code>org.w3c</code>的XML解析库，我们来看看如何使用它来进行XML文件内容解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// 创建DocumentBuilderFactory对象</span><br>DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();<br><span class="hljs-comment">// 创建DocumentBuilder对象</span><br><span class="hljs-keyword">try</span> &#123;<br>    DocumentBuilder builder = factory.newDocumentBuilder();<br>    Document d = builder.parse(<span class="hljs-string">&quot;file:mappers/test.xml&quot;</span>);<br>    <span class="hljs-comment">// 每一个标签都作为一个节点</span><br>    NodeList nodeList = d.getElementsByTagName(<span class="hljs-string">&quot;test&quot;</span>);  <span class="hljs-comment">// 可能有很多个名字为test的标签</span><br>    Node rootNode = nodeList.item(<span class="hljs-number">0</span>); <span class="hljs-comment">// 获取首个</span><br><br>    NodeList childNodes = rootNode.getChildNodes(); <span class="hljs-comment">// 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点</span><br>    <span class="hljs-comment">//节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childNodes.getLength(); i++) &#123;<br>        Node child = childNodes.item(i);<br>        <span class="hljs-keyword">if</span>(child.getNodeType() == Node.ELEMENT_NODE)  <span class="hljs-comment">//过滤换行符之类的内容，因为它们都被认为是一个文本节点</span><br>        System.out.println(child.getNodeName() + <span class="hljs-string">&quot;：&quot;</span> +child.getFirstChild().getNodeValue());<br>        <span class="hljs-comment">// 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点）</span><br>    &#125;<br>&#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">// 创建DocumentBuilderFactory对象</span><br>DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();<br><span class="hljs-comment">// 创建DocumentBuilder对象</span><br><span class="hljs-keyword">try</span> &#123;<br>    DocumentBuilder builder = factory.newDocumentBuilder();<br>    Document d = builder.parse(<span class="hljs-string">&quot;file:mappers/test.xml&quot;</span>);<br>    <span class="hljs-comment">// 每一个标签都作为一个节点</span><br>    NodeList nodeList = d.getElementsByTagName(<span class="hljs-string">&quot;test&quot;</span>);  <span class="hljs-comment">// 可能有很多个名字为test的标签</span><br>    Node rootNode = nodeList.item(<span class="hljs-number">0</span>); <span class="hljs-comment">// 获取首个</span><br><br>    NodeList childNodes = rootNode.getChildNodes(); <span class="hljs-comment">// 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点</span><br>    <span class="hljs-comment">//节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childNodes.getLength(); i++) &#123;<br>        Node child = childNodes.item(i);<br>        <span class="hljs-keyword">if</span>(child.getNodeType() == Node.ELEMENT_NODE)  <span class="hljs-comment">//过滤换行符之类的内容，因为它们都被认为是一个文本节点</span><br>        System.out.println(child.getNodeName() + <span class="hljs-string">&quot;：&quot;</span> +child.getFirstChild().getNodeValue());<br>        <span class="hljs-comment">// 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点）</span><br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，学习和使用XML只是为了更好地去认识Mybatis的工作原理，以及如何使用XML来作为Mybatis的配置文件，这是在开始之前必须要掌握的内容（使用Java读取XML内容不要求掌握，但是需要知道Mybatis就是通过这种方式来读取配置文件的）</p><p>不仅仅是Mybatis，包括后面的Spring等众多框架都会用到XML来作为框架的配置文件！</p><h3 id="初次使用Mybatis"><a href="#初次使用Mybatis" class="headerlink" title="初次使用Mybatis"></a>初次使用Mybatis</h3><p>那么我们首先来感受一下Mybatis给我们带来的便捷，就从搭建环境开始，中文文档网站：<a href="https://mybatis.org/mybatis-3/zh/configuration.html">https://mybatis.org/mybatis-3/zh/configuration.html</a></p><p>我们需要导入Mybatis的依赖，Jar包需要在github上下载，如果卡得一匹，连不上可以在视频简介处从分享的文件中获取。同样地放入到项目的根目录下，右键作为依赖即可！（依赖变多之后，我们可以将其放到一个单独的文件夹，不然会很繁杂）</p><p>依赖导入完成后，我们就可以编写Mybatis的配置文件了（现在不是在Java代码中配置了，而是通过一个XML文件去配置，这样就使得硬编码的部分大大减少，项目后期打包成Jar运行不方便修复，但是通过配置文件，我们随时都可以去修改，就变得很方便了，同时代码量也大幅度减少，配置文件填写完成后，我们只需要关心项目的业务逻辑而不是如何去读取配置文件）我们按照官方文档给定的提示，在项目根目录下新建名为<code>mybatis-config.xml</code>的文件，并填写以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;驱动类（含包名）&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;数据库连接URL&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;用户名&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;密码&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;驱动类（含包名）&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;数据库连接URL&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;用户名&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;密码&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>></span><br></code></pre></td></tr></table></figure><p>我们发现，在最上方还引入了一个叫做DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用Mybatis提前帮助我们规定好的标签来进行配置（因为只有这样Mybatis才能正确识别我们配置的内容）</p><p>通过进行配置，我们就告诉了Mybatis我们链接数据库的一些信息，包括URL、用户名、密码等，这样Mybatis就知道该链接哪个数据库、使用哪个账号进行登陆了（也可以不使用配置文件，这里不做讲解，还请各位小伙伴自行阅读官方文档）</p><p>配置文件完成后，我们需要在Java程序启动时，让Mybatis对配置文件进行读取并得到一个<code>SqlSessionFactory</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>    SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>    SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br><span class="hljs-comment">//暂时还没有业务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！那么现在我们来看看，<code>SqlSessionFactory</code>对象是什么东西：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.h5w3.com%2Fwp-content%2Fuploads%2F2021%2F01%2F1460000039107464.png&refer=http%3A%2F%2Fwww.h5w3.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639372889&t=f37deb63f29f0dc2f8b6a3517a68b86c" alt="img"></p><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过<code>SqlSessionFactory</code>来创建多个新的会话，<code>SqlSession</code>对象，每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的<code>Statement</code>对象，会话之间相互隔离，没有任何关联。</p><p>而通过<code>SqlSession</code>就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。</p><p>我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段，在查询语句返回结果后，Mybatis就会自动将对应的结果填入到对象的对应字段上。首先编写实体类，，直接使用Lombok是不是就很方便了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sid;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sid;   <span class="hljs-comment">//名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失</span><br>    String name;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>在根目录下重新创建一个mapper文件夹，新建名为<code>TestMapper.xml</code>的文件作为我们的映射器，并填写以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;TestMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.entity.Student&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;TestMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.entity.Student&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>></span><br></code></pre></td></tr></table></figure><p>其中namespace就是命名空间，每个Mapper都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。我们在里面写入了一个select标签，表示添加一个select操作，同时id作为操作的名称，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为<code>Student</code>类，然后就在标签中写入我们的查询语句即可。</p><p>编写好后，我们在配置文件中添加这个Mapper映射器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:mappers/TestMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--    这里用的是url，也可以使用其他类型，我们会在后面讲解    --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:mappers/TestMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--    这里用的是url，也可以使用其他类型，我们会在后面讲解    --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>></span><br></code></pre></td></tr></table></figure><p>最后在程序中使用我们定义好的Mapper即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>    SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>        List&lt;Student&gt; student = sqlSession.selectList(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>    SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>        List&lt;Student&gt; student = sqlSession.selectList(<span class="hljs-string">"selectStudent"</span>);<br>        student.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会发现，Mybatis非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！</p><h3 id="配置Mybatis"><a href="#配置Mybatis" class="headerlink" title="配置Mybatis"></a>配置Mybatis</h3><p>在了解了Mybatis为我们带来的便捷之后，现在我们就可以正式地去学习使用Mybatis了！</p><p>由于<code>SqlSessionFactory</code>一般只需要创建一次，因此我们可以创建一个工具类来集中创建<code>SqlSession</code>，这样会更加方便一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">//在类加载时就进行创建</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取一个新的会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SqlSession对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSession</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoCommit)</span></span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">//在类加载时就进行创建</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取一个新的会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SqlSession对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSession</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoCommit)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession(autoCommit);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们只需要在main方法中这样写即可查询结果了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        List&lt;Student&gt; student = sqlSession.selectList(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        List&lt;Student&gt; student = sqlSession.selectList(<span class="hljs-string">"selectStudent"</span>);<br>        student.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之前我们演示了，如何创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过<code>SqlSession</code>来执行对应的方法，能不能再方便一点呢？</p><p>现在，我们可以通过<code>namespace</code>来绑定到一个接口上，利用接口的特性，我们可以直接指明方法的行为，而实际实现则是由Mybatis来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestMapper</span> </span>&#123;<br>    <span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectStudent</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestMapper</span> </span>&#123;<br>    <span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectStudent</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将Mapper文件的命名空间修改为我们的接口，建议同时将其放到同名包中，作为内部资源：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.entity.Student&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.entity.Student&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>></span><br></code></pre></td></tr></table></figure><p>作为内部资源后，我们需要修改一下配置文件中的mapper定义，不使用url而是resource表示是Jar内部的文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/test/mapper/TestMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/test/mapper/TestMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>></span><br></code></pre></td></tr></table></figure><p>现在我们就可以直接通过<code>SqlSession</code>获取对应的实现类，通过接口中定义的行为来直接获取结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        List<Student> student = testMapper.selectStudent();<br>        student.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么肯定有人好奇，TestMapper明明是一个我们自己定义接口啊，Mybatis也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？我们可以通过调用<code>getClass()</code>方法来看看实现类是个什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><code class="language-hljs java">TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>System.out.println(testMapper.getClass());<br></code></pre></td></tr></table></figure><p>我们发现，实现类名称很奇怪，名称为<code>com.sun.proxy.$Proxy4</code>，它是通过动态代理生成的，相当于动态生成了一个实现类，而不是预先定义好的，有关Mybatis这一部分的原理，我们放在最后一节进行讲解。</p><p>接下来，我们再来看配置文件，之前我们并没有对配置文件进行一个详细的介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java">&lt;configuration&gt;<br>    &lt;environments <span class="hljs-keyword">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>        &lt;environment id=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>            &lt;transactionManager type=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;<br>            &lt;dataSource type=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;<br>                &lt;property name=<span class="hljs-string">&quot;driver&quot;</span> value=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;<br>                &lt;property name=<span class="hljs-string">&quot;url&quot;</span> value=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>/&gt;<br>                &lt;property name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;test&quot;</span>/&gt;<br>                &lt;property name=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;123456&quot;</span>/&gt;<br>            &lt;/dataSource&gt;<br>        &lt;/environment&gt;<br>    &lt;/environments&gt;<br>    &lt;mappers&gt;<br>        &lt;mapper resource=<span class="hljs-string"><code class="language-hljs java">&lt;configuration&gt;<br>    &lt;environments <span class="hljs-keyword">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>        &lt;environment id=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>            &lt;transactionManager type=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;<br>            &lt;dataSource type=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;<br>                &lt;property name=<span class="hljs-string">&quot;driver&quot;</span> value=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;<br>                &lt;property name=<span class="hljs-string">&quot;url&quot;</span> value=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>/&gt;<br>                &lt;property name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;test&quot;</span>/&gt;<br>                &lt;property name=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;123456&quot;</span>/&gt;<br>            &lt;/dataSource&gt;<br>        &lt;/environment&gt;<br>    &lt;/environments&gt;<br>    &lt;mappers&gt;<br>        &lt;mapper resource=<span class="hljs-string">"com/test/mapper/TestMapper.xml"</span>/><br>    </mappers><br></configuration><br></code></pre></td></tr></table></figure><p>首先就从<code>environments</code>标签说起，一般情况下，我们在开发中，都需要指定一个数据库的配置信息，包含连接URL、用户、密码等信息，而<code>environment</code>就是用于进行这些配置的！实际情况下可能会不止有一个数据库连接信息，比如开发过程中我们一般会使用本地的数据库，而如果需要将项目上传到服务器或是防止其他人的电脑上运行时，我们可能就需要配置另一个数据库的信息，因此，我们可以提前定义好所有的数据库信息，该什么时候用什么即可！</p><p>在<code>environments</code>标签上有一个default属性，来指定默认的环境，当然如果我们希望使用其他环境，可以修改这个默认环境，也可以在创建工厂时选择环境：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>        .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>), <span class="hljs-string"><code class="language-hljs java">sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>        .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>), <span class="hljs-string">"环境ID"</span>);<br></code></pre></td></tr></table></figure><p>我们还可以给类型起一个别名，以简化Mapper的编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">&lt;!-- 需要在environments的上方 --&gt;<br>&lt;typeAliases&gt;<br>    &lt;typeAlias type=<span class="hljs-string">&quot;com.test.entity.Student&quot;</span> alias=<span class="hljs-string"><code class="language-hljs java">&lt;!-- 需要在environments的上方 --&gt;<br>&lt;typeAliases&gt;<br>    &lt;typeAlias type=<span class="hljs-string">&quot;com.test.entity.Student&quot;</span> alias=<span class="hljs-string">"Student"</span>/><br></typeAliases><br></code></pre></td></tr></table></figure><p>现在Mapper就可以直接使用别名了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>></span><br></code></pre></td></tr></table></figure><p>如果这样还是很麻烦，我们也可以直接让Mybatis去扫描一个包，并将包下的所有类自动起别名（别名为首字母小写的类名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java">&lt;typeAliases&gt;<br>    &lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string"><code class="language-hljs java">&lt;typeAliases&gt;<br>    &lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string">"com.test.entity"</span>/><br></typeAliases><br></code></pre></td></tr></table></figure><p>也可以为指定实体类添加一个注解，来指定别名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Alias(&quot;lbwnb&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Alias(&quot;lbwnb&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，Mybatis也包含许多的基础配置，通过使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>></span><br></code></pre></td></tr></table></figure><p>所有的配置项可以在中文文档处查询，本文不会进行详细介绍，在后面我们会提出一些比较重要的配置项。</p><p>有关配置文件的介绍就暂时到这里为止，我们讨论的重心应该是Mybatis的应用，而不是配置文件，所以省略了一部分内容的讲解。</p><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p>在了解了Mybatis的一些基本配置之后，我们就可以正式来使用Mybatis来进行数据库操作了！</p><p>在前面我们演示了如何快速进行查询，我们只需要编写一个对应的映射器既可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>></span><br></code></pre></td></tr></table></figure><p>当然，如果你不喜欢使用实体类，那么这些属性还可以被映射到一个Map上：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Map&quot;</span>&gt;</span><br>    select * from student<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Map&quot;</span>&gt;</span><br>    select * from student<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>></span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestMapper</span> </span>&#123;<br>    <span class="hljs-function">List&lt;Map&gt; <span class="hljs-title">selectStudent</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestMapper</span> </span>&#123;<br>    <span class="hljs-function">List&lt;Map&gt; <span class="hljs-title">selectStudent</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Map中就会以键值对的形式来存放这些结果了。</p><p>通过设定一个<code>resultType</code>属性，让Mybatis知道查询结果需要映射为哪个实体类，要求字段名称保持一致。那么如果我们不希望按照这样的规则来映射呢？我们可以自定义<code>resultMap</code>来设定映射规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Test&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Test&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>></span><br></code></pre></td></tr></table></figure><p>通过指定映射规则，我们现在名称和性别一栏就发生了交换，因为我们将其映射字段进行了交换。</p><p>如果一个类中存在多个构造方法，那么很有可能会出现这样的错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java">### Exception in thread <span class="hljs-string">&quot;main&quot;</span> org.apache.ibatis.exceptions.PersistenceException: <br>### Error querying database.  Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String]<br>### The error may exist in com/test/mapper/TestMapper.xml<br>### The error may involve com.test.mapper.TestMapper.getStudentBySid<br>### The error occurred <span class="hljs-keyword">while</span> handling results<br>### SQL: select * from student where sid = ?<br>### Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String]<br>at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:<span class="hljs-number"><code class="language-hljs java">### Exception in thread <span class="hljs-string">&quot;main&quot;</span> org.apache.ibatis.exceptions.PersistenceException: <br>### Error querying database.  Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String]<br>### The error may exist in com/test/mapper/TestMapper.xml<br>### The error may involve com.test.mapper.TestMapper.getStudentBySid<br>### The error occurred <span class="hljs-keyword">while</span> handling results<br>### SQL: select * from student where sid = ?<br>### Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String]<br>at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:<span class="hljs-number">30</span>)<br>...<br></code></pre></td></tr></table></figure><p>这时就需要使用<code>constructor</code>标签来指定构造方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Integer&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;String&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Integer&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;String&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>></span><br></code></pre></td></tr></table></figure><p>值得注意的是，指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值，有关<code>resultMap</code>的内容，后面还会继续讲解。</p><p>如果数据库中存在一个带下划线的字段，我们可以通过设置让其映射为以驼峰命名的字段，比如<code>my_test</code>映射为<code>myTest</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>></span><br></code></pre></td></tr></table></figure><p>如果不设置，默认为不开启，也就是默认需要名称保持一致。</p><p>我们接着来看看条件查询，既然是条件查询，那么肯定需要我们传入查询条件，比如现在我们想通过sid字段来通过学号查找信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function">Student <span class="hljs-title">getStudentBySid</span><span class="hljs-params">(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function">Student <span class="hljs-title">getStudentBySid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    select * from student where sid = #&#123;sid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    select * from student where sid = #&#123;sid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>></span><br></code></pre></td></tr></table></figure><p>我们通过使用<code>#&#123;xxx&#125;</code>或是<code>$&#123;xxx&#125;</code>来填入我们给定的属性，实际上Mybatis本质也是通过<code>PreparedStatement</code>首先进行一次预编译，有效地防止SQL注入问题，但是如果使用<code>$&#123;xxx&#125;</code>就不再是通过预编译，而是直接传值，因此我们一般都使用<code>#&#123;xxx&#125;</code>来进行操作。</p><p>使用<code>parameterType</code>属性来指定参数类型（非必须，可以不用，推荐不用）</p><p>接着我们来看插入、更新和删除操作，其实与查询操作差不多，不过需要使用对应的标签，比如插入操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addStudent&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addStudent&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>></span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span></span>;<br></code></pre></td></tr></table></figure><p>我们这里使用的是一个实体类，我们可以直接使用实体类里面对应属性替换到SQL语句中，只需要填写属性名称即可，和条件查询是一样的。</p><h3 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h3><p>一个老师可以教授多个学生，那么能否一次性将老师的学生全部映射给此老师的对象呢，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tid;<br>    String name;<br>    List<Student> studentList;<br>&#125;<br></code></pre></td></tr></table></figure><p>映射为Teacher对象时，同时将其教授的所有学生一并映射为List列表，显然这是一种一对多的查询，那么这时就需要进行复杂查询了。而我们之前编写的都非常简单，直接就能完成映射，因此我们现在需要使用<code>resultMap</code>来自定义映射规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacherByTid&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;asTeacher&quot;</span>&gt;</span><br>        select *, teacher.name as tname from student inner join teach on student.sid = teach.sid<br>                              inner join teacher on teach.tid = teacher.tid where teach.tid = #&#123;tid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;asTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;studentList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacherByTid&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;asTeacher&quot;</span>&gt;</span><br>        select *, teacher.name as tname from student inner join teach on student.sid = teach.sid<br>                              inner join teacher on teach.tid = teacher.tid where teach.tid = #&#123;tid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;asTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;studentList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>></span><br></code></pre></td></tr></table></figure><p>可以看到，我们的查询结果是一个多表联查的结果，而联查的数据就是我们需要映射的数据（比如这里是一个老师有N个学生，联查的结果也是这一个老师对应N个学生的N条记录），其中<code>id</code>标签用于在多条记录中辨别是否为同一个对象的数据，比如上面的查询语句得到的结果中，<code>tid</code>这一行始终为<code>1</code>，因此所有的记录都应该是<code>tid=1</code>的教师的数据，而不应该变为多个教师的数据，如果不加id进行约束，那么会被识别成多个教师的数据！</p><p>通过使用collection来表示将得到的所有结果合并为一个集合，比如上面的数据中每个学生都有单独的一条记录，因此tid相同的全部学生的记录就可以最后合并为一个List，得到最终的映射结果，当然，为了区分，最好也设置一个id，只不过这个例子中可以当做普通的<code>result</code>使用。</p><p>了解了一对多，那么多对一又该如何查询呢，比如每个学生都有一个对应的老师，现在Student新增了一个Teacher对象，那么现在又该如何去处理呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> Teacher teacher;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> Teacher teacher;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tid;<br>    String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们希望的是，每次查询到一个Student对象时都带上它的老师，同样的，我们也可以使用<code>resultMap</code>来实现（先修改一下老师的类定义，不然会很麻烦）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;test2&quot;</span>&gt;</span><br>    select *, teacher.name as tname from student left join teach on student.sid = teach.sid<br>                                                 left join teacher on teach.tid = teacher.tid<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;test2&quot;</span>&gt;</span><br>    select *, teacher.name as tname from student left join teach on student.sid = teach.sid<br>                                                 left join teacher on teach.tid = teacher.tid<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>></span><br></code></pre></td></tr></table></figure><p>通过使用<code>association</code>进行关联，形成多对一的关系，实际上和一对多是同理的，都是对查询结果的一种处理方式罢了。</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>我们可以在获取<code>SqlSession</code>关闭自动提交来开启事务模式，和JDBC其实都差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">false</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>        testMapper.addStudent(<span class="hljs-keyword">new</span> Student().setSex(<span class="hljs-string">&quot;男&quot;</span>).setName(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">false</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>        testMapper.addStudent(<span class="hljs-keyword">new</span> Student().setSex(<span class="hljs-string">&quot;男&quot;</span>).setName(<span class="hljs-string">"小王"</span>));<br><br>        testMapper.selectStudent().forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的，现在我们来试一下在最后提交事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><code class="language-hljs java">sqlSession.commit();<br></code></pre></td></tr></table></figure><p>在事务提交后，我们的内容才会被写入到数据库中。现在我们来试试看回滚操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">false</span>))&#123;<br>    TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>    testMapper.addStudent(<span class="hljs-keyword">new</span> Student().setSex(<span class="hljs-string">&quot;男&quot;</span>).setName(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">false</span>))&#123;<br>    TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>    testMapper.addStudent(<span class="hljs-keyword">new</span> Student().setSex(<span class="hljs-string">&quot;男&quot;</span>).setName(<span class="hljs-string">"小王"</span>));<br><br>    testMapper.selectStudent().forEach(System.out::println);<br>    sqlSession.rollback();<br>    sqlSession.commit();<br>&#125;<br></code></pre></td></tr></table></figure><p>回滚操作也印证成功。</p><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p><p>我们直接使用官网的例子进行讲解。</p><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 </p><p>其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，我们就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高。</p><p>因此Mybatis内置了一个缓存机制，我们查询时，如果缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fresource.shangmayuan.com%2Fdroxy-blog%2F2021%2F03%2F02%2F071d25e4f9d841e0ac9df54038d98fd0-2.png&refer=http%3A%2F%2Fresource.shangmayuan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639463836&t=38cf5a85386f76cfd22ca3c6dcc5b6bb" alt="img"></p><p>Mybatis存在一级缓存和二级缓存，我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存（一级缓存无法关闭，只能调整），我们来看看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        Student student2 = testMapper.getStudentBySid(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        Student student2 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        System.out.println(student1 == student2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，两次得到的是同一个Student对象，也就是说我们第二次查询并没有重新去构造对象，而是直接得到之前创建好的对象。如果还不是很明显，我们可以修改一下实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我被构造了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我被构造了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过前面的学习得知Mybatis在映射为对象时，在只有一个构造方法的情况下，无论你构造方法写成什么样子，都会去调用一次构造方法，如果存在多个构造方法，那么就会去找匹配的构造方法。我们可以通过查看构造方法来验证对象被创建了几次。</p><p>结果显而易见，只创建了一次，也就是说当第二次进行同样的查询时，会直接使用第一次的结果，因为第一次的结果已经被缓存了。</p><p>那么如果我修改了数据库中的内容，缓存还会生效吗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        testMapper.addStudent(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">&quot;小李&quot;</span>).setSex(<span class="hljs-string">&quot;男&quot;</span>));<br>        Student student2 = testMapper.getStudentBySid(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        testMapper.addStudent(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">&quot;小李&quot;</span>).setSex(<span class="hljs-string">&quot;男&quot;</span>));<br>        Student student2 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        System.out.println(student1 == student2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，当我们进行了插入操作后，缓存就没有生效了，我们再次进行查询得到的是一个新创建的对象。</p><p>也就是说，一级缓存，在进行DML操作后，会使得缓存失效，也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。还有一种情况就是，当前会话结束后，也会清理全部的缓存，因为已经不会再用到了。但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>        Student student2;<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession2 = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class);<br>            student2 = testMapper2.getStudentBySid(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>        Student student2;<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession2 = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class);<br>            student2 = testMapper2.getStudentBySid(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        System.out.println(student1 == student2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，也就是说，其他会话缓存是不会更新的！</p><p>一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，因此我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/></span><br></code></pre></td></tr></table></figure><p>可见二级缓存是Mapper级别的，也就是说，当一个会话失效时，它的缓存依然会存在于二级缓存中，因此如果我们再次创建一个新的会话会直接使用之前的缓存，我们首先根据官方文档进行一些配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span></span><br><span class="hljs-tag">  <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">readOnly</span>=<span class="hljs-string"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span></span><br><span class="hljs-tag">  <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">readOnly</span>=<span class="hljs-string">"true"</span>/></span><br></code></pre></td></tr></table></figure><p>我们来编写一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        student = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession2 = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class);<br>        Student student2 = testMapper2.getStudentBySid(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        student = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession2 = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class);<br>        Student student2 = testMapper2.getStudentBySid(<span class="hljs-number">1</span>);<br>        System.out.println(student2 == student);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，上面的代码中首先是第一个会话在进行读操作，完成后会结束会话，而第二个操作重新创建了一个新的会话，再次执行了同样的查询，我们发现得到的依然是缓存的结果。</p><p>那么如果我不希望某个方法开启缓存呢？我们可以添加useCache属性来关闭缓存：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    select * from student where sid = #&#123;sid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    select * from student where sid = #&#123;sid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>></span><br></code></pre></td></tr></table></figure><p>我们也可以使用flushCache=”false”在每次执行后都清空缓存，通过这这个我们还可以控制DML操作完成之后不清空缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    select * from student where sid = #&#123;sid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    select * from student where sid = #&#123;sid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>></span><br></code></pre></td></tr></table></figure><p>添加了二级缓存之后，会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库，因此我们再来执行上面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>        Student student2;<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession2 = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class);<br>            student2 = testMapper2.getStudentBySid(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br><br>        Student student2;<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession2 = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class);<br>            student2 = testMapper2.getStudentBySid(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        Student student1 = testMapper.getStudentBySid(<span class="hljs-number">1</span>);<br>        System.out.println(student1 == student2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的结果就会是同一个对象了，因为现在是优先从二级缓存中获取。</p><p>读取顺序：二级缓存 =&gt; 一级缓存 =&gt; 数据库</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F2176079-2e6599c454e7af19.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639471352&t=c7c1d6b11de1ad9af91e092590c58d83" alt="img"></p><p>虽然缓存机制给我们提供了很大的性能提升，但是缓存存在一个问题，我们之前在<code>计算机组成原理</code>中可能学习过缓存一致性问题，也就是说当多个CPU在操作自己的缓存时，可能会出现各自的缓存内容不同步的问题，而Mybatis也会这样，我们来看看这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            System.out.println(testMapper.getStudentBySid(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            System.out.println(testMapper.getStudentBySid(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在循环地每三秒读取一次，而在这个过程中，我们使用IDEA手动修改数据库中的数据，将1号同学的学号改成100，那么理想情况下，下一次读取将无法获取到小明，因为小明的学号已经发生变化了。</p><p>但是结果却是依然能够读取，并且sid并没有发生改变，这也证明了Mybatis的缓存在生效，因为我们是从外部进行修改，Mybatis不知道我们修改了数据，所以依然在使用缓存中的数据，但是这样很明显是不正确的，因此，如果存在多台服务器或者是多个程序都在使用Mybatis操作同一个数据库，并且都开启了缓存，需要解决这个问题，要么就得关闭Mybatis的缓存来保证一致性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>></span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    select * from student where sid = #&#123;sid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    select * from student where sid = #&#123;sid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>></span><br></code></pre></td></tr></table></figure><p>要么就需要实现缓存共用，也就是让所有的Mybatis都使用同一个缓存进行数据存取，在后面，我们会继续学习Redis、Ehcache、Memcache等缓存框架，通过使用这些工具，就能够很好地解决缓存一致性问题。</p><h3 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h3><p>在之前的开发中，我们已经体验到Mybatis为我们带来的便捷了，我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的SQL语句，极大的简化了我们之前JDBC那样的代码编写模式。那么，能否实现无需xml映射器配置，而是直接使用注解在接口上进行配置呢？答案是可以的，也是现在推荐的一种方式（也不是说XML就不要去用了，由于Java 注解的表达能力和灵活性十分有限，可能相对于XML配置某些功能实现起来会不太好办，但是在大部分场景下，直接使用注解开发已经绰绰有余了）</p><p>首先我们来看一下，使用XML进行映射器编写时，我们需要现在XML中定义映射规则和SQL语句，然后再将其绑定到一个接口的方法定义上，然后再使用接口来执行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addStudent&quot;</span>&gt;</span><br>    insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addStudent&quot;</span>&gt;</span><br>    insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>></span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span></span>;<br></code></pre></td></tr></table></figure><p>而现在，我们可以直接使用注解来实现，每个操作都有一个对应的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Insert(&quot;insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Insert(&quot;insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span></span>;<br></code></pre></td></tr></table></figure><p>当然，我们还需要修改一下配置文件中的映射器注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">&lt;mappers&gt;<br>    &lt;mapper <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.test.mapper.MyMapper&quot;</span>/&gt;<br>    &lt;!--  也可以直接注册整个包下的 &lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string"><code class="language-hljs java">&lt;mappers&gt;<br>    &lt;mapper <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.test.mapper.MyMapper&quot;</span>/&gt;<br>    &lt;!--  也可以直接注册整个包下的 &lt;<span class="hljs-keyword">package</span> name=<span class="hljs-string">"com.test.mapper"</span>/>  --><br></mappers><br></code></pre></td></tr></table></figure><p>通过直接指定Class，来让Mybatis知道我们这里有一个通过注解实现的映射器。</p><p>我们接着来看一下，如何使用注解进行自定义映射规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Results(&#123;</span><br><span class="hljs-meta">        @Result(id = true, column = &quot;sid&quot;, property = &quot;sid&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;sex&quot;, property = &quot;name&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;name&quot;, property = &quot;sex&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Select(&quot;select * from student&quot;)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Results(&#123;</span><br><span class="hljs-meta">        @Result(id = true, column = &quot;sid&quot;, property = &quot;sid&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;sex&quot;, property = &quot;name&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;name&quot;, property = &quot;sex&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Select(&quot;select * from student&quot;)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>直接通过<code>@Results</code>注解，就可以直接进行配置了，此注解的value是一个<code>@Result</code>注解数组，每个<code>@Result</code>注解都都一个单独的字段配置，其实就是我们之前在XML映射器中写的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>></span><br></code></pre></td></tr></table></figure><p>现在我们就可以通过注解来自定义映射规则了。那么如何使用注解来完成复杂查询呢？我们还是使用一个老师多个学生的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Results(&#123;</span><br><span class="hljs-meta">        @Result(id = true, column = &quot;tid&quot;, property = &quot;tid&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;tid&quot;, property = &quot;studentList&quot;, many =</span><br><span class="hljs-meta">            @Many(select = &quot;getStudentByTid&quot;)</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Select(&quot;select * from teacher where tid = #&#123;tid&#125;&quot;)</span><br><span class="hljs-function">Teacher <span class="hljs-title">getTeacherBySid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tid)</span></span>;<br><br><span class="hljs-meta">@Select(&quot;select * from student inner join teach on student.sid = teach.sid where tid = #&#123;tid&#125;&quot;)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getStudentByTid</span><span class="hljs-params">(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Results(&#123;</span><br><span class="hljs-meta">        @Result(id = true, column = &quot;tid&quot;, property = &quot;tid&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;tid&quot;, property = &quot;studentList&quot;, many =</span><br><span class="hljs-meta">            @Many(select = &quot;getStudentByTid&quot;)</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Select(&quot;select * from teacher where tid = #&#123;tid&#125;&quot;)</span><br><span class="hljs-function">Teacher <span class="hljs-title">getTeacherBySid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tid)</span></span>;<br><br><span class="hljs-meta">@Select(&quot;select * from student inner join teach on student.sid = teach.sid where tid = #&#123;tid&#125;&quot;)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getStudentByTid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tid)</span></span>;<br></code></pre></td></tr></table></figure><p>我们发现，多出了一个子查询，而这个子查询是单独查询该老师所属学生的信息，而子查询结果作为<code>@Result</code>注解的一个many结果，代表子查询的所有结果都归入此集合中（也就是之前的collection标签）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;asTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;studentList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;asTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;studentList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>></span><br></code></pre></td></tr></table></figure><p>同理，<code>@Result</code>也提供了<code>@One</code>子注解来实现一对一的关系表示，类似于之前的<code>assocation</code>标签：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Results(&#123;</span><br><span class="hljs-meta">        @Result(id = true, column = &quot;sid&quot;, property = &quot;sid&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;sex&quot;, property = &quot;name&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;name&quot;, property = &quot;sex&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;sid&quot;, property = &quot;teacher&quot;, one =</span><br><span class="hljs-meta">            @One(select = &quot;getTeacherBySid&quot;)</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Select(&quot;select * from student&quot;)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Results(&#123;</span><br><span class="hljs-meta">        @Result(id = true, column = &quot;sid&quot;, property = &quot;sid&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;sex&quot;, property = &quot;name&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;name&quot;, property = &quot;sex&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;sid&quot;, property = &quot;teacher&quot;, one =</span><br><span class="hljs-meta">            @One(select = &quot;getTeacherBySid&quot;)</span><br><span class="hljs-meta">        )</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Select(&quot;select * from student&quot;)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>如果现在我希望直接使用注解编写SQL语句但是我希望映射规则依然使用XML来实现，这时该怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@ResultMap(&quot;test&quot;)</span><br><span class="hljs-meta">@Select(&quot;select * from student&quot;)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@ResultMap(&quot;test&quot;)</span><br><span class="hljs-meta">@Select(&quot;select * from student&quot;)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>提供了<code>@ResultMap</code>注解，直接指定ID即可，这样我们就可以使用XML中编写的映射规则了，这里就不再演示了。</p><p>那么如果出现之前的两个构造方法的情况，且没有任何一个构造方法匹配的话，该怎么处理呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一号构造方法&quot;</span>+sid);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid, String name)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是二号构造方法&quot;</span>+sid+name);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一号构造方法&quot;</span>+sid);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid, String name)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是二号构造方法&quot;</span>+sid+name);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过<code>@ConstructorArgs</code>注解来指定构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@ConstructorArgs(&#123;</span><br><span class="hljs-meta">        @Arg(column = &quot;sid&quot;, javaType = int.class),</span><br><span class="hljs-meta">        @Arg(column = &quot;name&quot;, javaType = String.class)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)</span><br><span class="hljs-function">Student <span class="hljs-title">getStudentBySidAndSex</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;sid&quot;)</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@ConstructorArgs(&#123;</span><br><span class="hljs-meta">        @Arg(column = &quot;sid&quot;, javaType = int.class),</span><br><span class="hljs-meta">        @Arg(column = &quot;name&quot;, javaType = String.class)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)</span><br><span class="hljs-function">Student <span class="hljs-title">getStudentBySidAndSex</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;sid&quot;)</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta">@Param("sex")</span> String sex)</span></span>;<br></code></pre></td></tr></table></figure><p>得到的结果和使用<code>constructor</code>标签效果一致，这里就不多做讲解了。</p><p>我们发现，当参数列表中出现两个以上的参数时，会出现错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)</span><br><span class="hljs-function">Student <span class="hljs-title">getStudentBySidAndSex</span><span class="hljs-params">(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)</span><br><span class="hljs-function">Student <span class="hljs-title">getStudentBySidAndSex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid, String sex)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> org.apache.ibatis.exceptions.PersistenceException: <br>### Error querying database.  Cause: org.apache.ibatis.binding.BindingException: Parameter <span class="hljs-string">&#x27;sid&#x27;</span> not found. Available parameters are [arg1, arg0, param1, param2]<br>### Cause: org.apache.ibatis.binding.BindingException: Parameter <span class="hljs-string">&#x27;sid&#x27;</span> not found. Available parameters are [arg1, arg0, param1, param2]<br>at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:<span class="hljs-number">30</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:<span class="hljs-number">153</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:<span class="hljs-number">145</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:<span class="hljs-number">140</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:<span class="hljs-number">76</span>)<br>at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:<span class="hljs-number">87</span>)<br>at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:<span class="hljs-number">145</span>)<br>at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:<span class="hljs-number">86</span>)<br>at com.sun.proxy.$Proxy6.getStudentBySidAndSex(Unknown Source)<br>at com.test.Main.main(Main.java:<span class="hljs-number"><code class="language-hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> org.apache.ibatis.exceptions.PersistenceException: <br>### Error querying database.  Cause: org.apache.ibatis.binding.BindingException: Parameter <span class="hljs-string">&#x27;sid&#x27;</span> not found. Available parameters are [arg1, arg0, param1, param2]<br>### Cause: org.apache.ibatis.binding.BindingException: Parameter <span class="hljs-string">&#x27;sid&#x27;</span> not found. Available parameters are [arg1, arg0, param1, param2]<br>at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:<span class="hljs-number">30</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:<span class="hljs-number">153</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:<span class="hljs-number">145</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:<span class="hljs-number">140</span>)<br>at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:<span class="hljs-number">76</span>)<br>at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:<span class="hljs-number">87</span>)<br>at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:<span class="hljs-number">145</span>)<br>at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:<span class="hljs-number">86</span>)<br>at com.sun.proxy.$Proxy6.getStudentBySidAndSex(Unknown Source)<br>at com.test.Main.main(Main.java:<span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><p>原因是Mybatis不明确到底哪个参数是什么，因此我们可以添加<code>@Param</code>来指定参数名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)</span><br><span class="hljs-function">Student <span class="hljs-title">getStudentBySidAndSex</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;sid&quot;)</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)</span><br><span class="hljs-function">Student <span class="hljs-title">getStudentBySidAndSex</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;sid&quot;)</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta">@Param("sex")</span> String sex)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>探究：</strong>要是我两个参数一个是基本类型一个是对象类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">System.out.println(testMapper.addStudent(<span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">&quot;小陆&quot;</span>).setSex(<span class="hljs-string"><code class="language-hljs java">System.out.println(testMapper.addStudent(<span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">&quot;小陆&quot;</span>).setSex(<span class="hljs-string">"男"</span>)));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Insert(&quot;insert into student(sid, name, sex) values(#&#123;sid&#125;, #&#123;name&#125;, #&#123;sex&#125;)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;sid&quot;)</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Insert(&quot;insert into student(sid, name, sex) values(#&#123;sid&#125;, #&#123;name&#125;, #&#123;sex&#125;)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;sid&quot;)</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta">@Param("student")</span>  Student student)</span></span>;<br></code></pre></td></tr></table></figure><p>那么这个时候，就出现问题了，Mybatis就不能明确这些属性是从哪里来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java">### SQL: <span class="hljs-function">insert into <span class="hljs-title">student</span><span class="hljs-params">(sid, name, sex)</span> <span class="hljs-title">values</span><span class="hljs-params">(?, ?, ?)</span></span><br><span class="hljs-function">### Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;name&#x27; not found. Available parameters are [student, param1, sid, param2]</span><br><span class="hljs-function">at org.apache.ibatis.exceptions.ExceptionFactory.<span class="hljs-title">wrapException</span><span class="hljs-params">(ExceptionFactory.java:<span class="hljs-number">30</span>)</span></span><br><span class="hljs-function">at org.apache.ibatis.session.defaults.DefaultSqlSession.<span class="hljs-title">update</span><span class="hljs-params">(DefaultSqlSession.java:<span class="hljs-number">196</span>)</span></span><br><span class="hljs-function">at org.apache.ibatis.session.defaults.DefaultSqlSession.<span class="hljs-title">insert</span><span class="hljs-params">(DefaultSqlSession.java:<span class="hljs-number">181</span>)</span></span><br><span class="hljs-function">at org.apache.ibatis.binding.MapperMethod.<span class="hljs-title">execute</span><span class="hljs-params">(MapperMethod.java:<span class="hljs-number">62</span>)</span></span><br><span class="hljs-function">at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.<span class="hljs-title">invoke</span><span class="hljs-params">(MapperProxy.java:<span class="hljs-number">145</span>)</span></span><br><span class="hljs-function">at org.apache.ibatis.binding.MapperProxy.<span class="hljs-title">invoke</span><span class="hljs-params">(MapperProxy.java:<span class="hljs-number">86</span>)</span></span><br><span class="hljs-function">at com.sun.proxy.$Proxy6.<span class="hljs-title">addStudent</span><span class="hljs-params">(Unknown Source)</span></span><br><span class="hljs-function">at com.test.Main.<span class="hljs-title">main</span><span class="hljs-params">(Main.java:<span class="hljs-number"><code class="language-hljs java">### SQL: <span class="hljs-function">insert into <span class="hljs-title">student</span><span class="hljs-params">(sid, name, sex)</span> <span class="hljs-title">values</span><span class="hljs-params">(?, ?, ?)</span></span><br><span class="hljs-function">### Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;name&#x27; not found. Available parameters are [student, param1, sid, param2]</span><br><span class="hljs-function">at org.apache.ibatis.exceptions.ExceptionFactory.<span class="hljs-title">wrapException</span><span class="hljs-params">(ExceptionFactory.java:<span class="hljs-number">30</span>)</span></span><br><span class="hljs-function">at org.apache.ibatis.session.defaults.DefaultSqlSession.<span class="hljs-title">update</span><span class="hljs-params">(DefaultSqlSession.java:<span class="hljs-number">196</span>)</span></span><br><span class="hljs-function">at org.apache.ibatis.session.defaults.DefaultSqlSession.<span class="hljs-title">insert</span><span class="hljs-params">(DefaultSqlSession.java:<span class="hljs-number">181</span>)</span></span><br><span class="hljs-function">at org.apache.ibatis.binding.MapperMethod.<span class="hljs-title">execute</span><span class="hljs-params">(MapperMethod.java:<span class="hljs-number">62</span>)</span></span><br><span class="hljs-function">at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.<span class="hljs-title">invoke</span><span class="hljs-params">(MapperProxy.java:<span class="hljs-number">145</span>)</span></span><br><span class="hljs-function">at org.apache.ibatis.binding.MapperProxy.<span class="hljs-title">invoke</span><span class="hljs-params">(MapperProxy.java:<span class="hljs-number">86</span>)</span></span><br><span class="hljs-function">at com.sun.proxy.$Proxy6.<span class="hljs-title">addStudent</span><span class="hljs-params">(Unknown Source)</span></span><br><span class="hljs-function">at com.test.Main.<span class="hljs-title">main</span><span class="hljs-params">(Main.java:<span class="hljs-number">16</span>)</span></span><br></code></pre></td></tr></table></figure><p>那么我们就通过参数名称.属性的方式去让Mybatis知道我们要用的是哪个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Insert(&quot;insert into student(sid, name, sex) values(#&#123;sid&#125;, #&#123;student.name&#125;, #&#123;student.sex&#125;)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;sid&quot;)</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Insert(&quot;insert into student(sid, name, sex) values(#&#123;sid&#125;, #&#123;student.name&#125;, #&#123;student.sex&#125;)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;sid&quot;)</span> <span class="hljs-keyword">int</span> sid, <span class="hljs-meta">@Param("student")</span>  Student student)</span></span>;<br></code></pre></td></tr></table></figure><p>那么如何通过注解控制缓存机制呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@CacheNamespace(readWrite = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from student&quot;)</span><br>    <span class="hljs-meta">@Options(useCache = false)</span><br>    <span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@CacheNamespace(readWrite = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from student&quot;)</span><br>    <span class="hljs-meta">@Options(useCache = false)</span><br>    <span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">getAllStudent</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>使用<code>@CacheNamespace</code>注解直接定义在接口上即可，然后我们可以通过使用<code>@Options</code>来控制单个操作的缓存启用。</p><h3 id="探究Mybatis的动态代理机制"><a href="#探究Mybatis的动态代理机制" class="headerlink" title="探究Mybatis的动态代理机制"></a>探究Mybatis的动态代理机制</h3><p>在探究动态代理机制之前，我们要先聊聊什么是代理：其实顾名思义，就好比我开了个大棚，里面栽种的西瓜，那么西瓜成熟了是不是得去卖掉赚钱，而我们的西瓜非常多，一个人肯定卖不过来，肯定就要去多找几个开水果摊的帮我们卖，这就是一种代理。实际上是由水果摊老板在帮我们卖瓜，我们只告诉老板卖多少钱，而至于怎么卖的是由水果摊老板决定的。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F2020112311143434.png%3Fx-oss-process%26%2361%3Bimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhdHR5MTkyMA%26%2361%3B%26%2361%3B%2Csize_16%2Ccolor_FFFFFF%2Ct_7&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639472394&t=b5590551c75049e91fc497b9920bdb83" alt="img"></p><p>那么现在我们来尝试实现一下这样的类结构，首先定义一个接口用于规范行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shopper</span> </span>&#123;<br><br>    <span class="hljs-comment">//卖瓜行为</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saleWatermelon</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shopper</span> </span>&#123;<br><br>    <span class="hljs-comment">//卖瓜行为</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saleWatermelon</span><span class="hljs-params">(String customer)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后需要实现一下卖瓜行为，也就是我们要告诉老板卖多少钱，这里就直接写成成功出售：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shopper</span></span>&#123;<br><br>    <span class="hljs-comment">//卖瓜行为的实现</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saleWatermelon</span><span class="hljs-params">(String customer)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shopper</span></span>&#123;<br><br>    <span class="hljs-comment">//卖瓜行为的实现</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saleWatermelon</span><span class="hljs-params">(String customer)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"成功出售西瓜给 ===> "</span>+customer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后老板代理后肯定要用自己的方式去出售这些西瓜，成交之后再按照我们告诉老板的价格进行出售：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shopper</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Shopper impl;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShopperProxy</span><span class="hljs-params">(Shopper impl)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.impl = impl;<br>    &#125;<br><br>    <span class="hljs-comment">//代理卖瓜行为</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saleWatermelon</span><span class="hljs-params">(String customer)</span> </span>&#123;<br>        <span class="hljs-comment">//首先进行 代理商讨价还价行为</span><br>        System.out.println(customer + <span class="hljs-string">&quot;：哥们，这瓜多少钱一斤啊？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：两块钱一斤。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：给我挑一个。&quot;</span>);<br><br>        impl.saleWatermelon(customer);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shopper</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Shopper impl;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShopperProxy</span><span class="hljs-params">(Shopper impl)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.impl = impl;<br>    &#125;<br><br>    <span class="hljs-comment">//代理卖瓜行为</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saleWatermelon</span><span class="hljs-params">(String customer)</span> </span>&#123;<br>        <span class="hljs-comment">//首先进行 代理商讨价还价行为</span><br>        System.out.println(customer + <span class="hljs-string">&quot;：哥们，这瓜多少钱一斤啊？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：两块钱一斤。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：给我挑一个。&quot;</span>);<br><br>        impl.saleWatermelon(customer);   <span class="hljs-comment">//讨价还价成功，进行我们告诉代理商的卖瓜行为</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来试试看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Shopper shopper = <span class="hljs-keyword">new</span> ShopperProxy(<span class="hljs-keyword">new</span> ShopperImpl());<br>        shopper.saleWatermelon(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Shopper shopper = <span class="hljs-keyword">new</span> ShopperProxy(<span class="hljs-keyword">new</span> ShopperImpl());<br>        shopper.saleWatermelon(<span class="hljs-string">"小强"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的操作称为静态代理，也就是说我们需要提前知道接口的定义并进行实现才可以完成代理，而Mybatis这样的是无法预知代理接口的，我们就需要用到动态代理。</p><p>JDK提供的反射框架就为我们很好地解决了动态代理的问题，在这里相当于对JavaSE阶段反射的内容进行一个补充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>    Object target;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShopperProxy</span><span class="hljs-params">(Object target)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        String customer = (String) args[<span class="hljs-number">0</span>];<br>        System.out.println(customer + <span class="hljs-string">&quot;：哥们，这瓜多少钱一斤啊？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：两块钱一斤。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：行，给我挑一个。&quot;</span>);<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>    Object target;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShopperProxy</span><span class="hljs-params">(Object target)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        String customer = (String) args[<span class="hljs-number">0</span>];<br>        System.out.println(customer + <span class="hljs-string">&quot;：哥们，这瓜多少钱一斤啊？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：两块钱一斤。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：行，给我挑一个。&quot;</span>);<br>        <span class="hljs-keyword">return</span> method.invoke(target, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过实现InvocationHandler来成为一个动态代理，我们发现它提供了一个invoke方法，用于调用被代理对象的方法并完成我们的代理工作。现在就可以通过<code> Proxy.newProxyInstance</code>来生成一个动态代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Shopper impl = <span class="hljs-keyword">new</span> ShopperImpl();<br>    Shopper shopper = (Shopper) Proxy.newProxyInstance(impl.getClass().getClassLoader(),<br>            impl.getClass().getInterfaces(), <span class="hljs-keyword">new</span> ShopperProxy(impl));<br>    shopper.saleWatermelon(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Shopper impl = <span class="hljs-keyword">new</span> ShopperImpl();<br>    Shopper shopper = (Shopper) Proxy.newProxyInstance(impl.getClass().getClassLoader(),<br>            impl.getClass().getInterfaces(), <span class="hljs-keyword">new</span> ShopperProxy(impl));<br>    shopper.saleWatermelon(<span class="hljs-string">"小强"</span>);<br>  System.out.println(shopper.getClass());<br>&#125;<br></code></pre></td></tr></table></figure><p>通过打印类型我们发现，就是我们之前看到的那种奇怪的类：<code>class com.sun.proxy.$Proxy0</code>，因此Mybatis其实也是这样的来实现的（肯定有人问了：Mybatis是直接代理接口啊，你这个不还是要把接口实现了吗？）那我们来改改，现在我们不代理任何类了，直接做接口实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        String customer = (String) args[<span class="hljs-number">0</span>];<br>        System.out.println(customer + <span class="hljs-string">&quot;：哥们，这瓜多少钱一斤啊？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：两块钱一斤。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：行，给我挑一个。&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        String customer = (String) args[<span class="hljs-number">0</span>];<br>        System.out.println(customer + <span class="hljs-string">&quot;：哥们，这瓜多少钱一斤啊？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：两块钱一斤。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;</span>);<br>        System.out.println(customer + <span class="hljs-string">&quot;：行，给我挑一个。&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Shopper shopper = (Shopper) Proxy.newProxyInstance(Shopper.class.getClassLoader(),<br>            <span class="hljs-keyword">new</span> Class[]&#123; Shopper.class &#125;,   <span class="hljs-comment">//因为本身就是接口，所以直接用就行</span><br>            <span class="hljs-keyword">new</span> ShopperProxy());<br>    shopper.saleWatermelon(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Shopper shopper = (Shopper) Proxy.newProxyInstance(Shopper.class.getClassLoader(),<br>            <span class="hljs-keyword">new</span> Class[]&#123; Shopper.class &#125;,   <span class="hljs-comment">//因为本身就是接口，所以直接用就行</span><br>            <span class="hljs-keyword">new</span> ShopperProxy());<br>    shopper.saleWatermelon(<span class="hljs-string">"小强"</span>);<br>    System.out.println(shopper.getClass());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以去看看Mybatis的源码。</p><p>Mybatis的学习差不多就到这里为止了，不过，同样类型的框架还有很多，Mybatis属于半自动框架，SQL语句依然需要我们自己编写，虽然存在一定的麻烦，但是会更加灵活，而后面我们还会学习JPA，它是全自动的框架，你几乎见不到SQL的影子！</p><hr><h2 id="使用JUnit进行单元测试"><a href="#使用JUnit进行单元测试" class="headerlink" title="使用JUnit进行单元测试"></a>使用JUnit进行单元测试</h2><p>首先一问：我们为什么需要单元测试？</p><p>随着我们的项目逐渐变大，比如我们之前编写的图书管理系统，我们都是边在写边在测试，而我们当时使用的测试方法，就是直接在主方法中运行测试，但是，在很多情况下，我们的项目可能会很庞大，不可能每次都去完整地启动一个项目来测试某一个功能，这样显然会降低我们的开发效率，因此，我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试，而不是启动整个项目。</p><p>同时，在我们项目的维护过程中，难免会涉及到一些原有代码的修改，很有可能出现改了代码导致之前的功能出现问题（牵一发而动全身），而我们又不一定能立即察觉到，因此，我们可以提前保存一些测试用例，每次完成代码后都可以跑一遍测试用例，来确保之前的功能没有因为后续的修改而出现问题。</p><p>我们还可以利用单元测试来评估某个模块或是功能的耗时和性能，快速排查导致程序运行缓慢的问题，这些都可以通过单元测试来完成，可见单元测试对于开发的重要性。</p><h3 id="尝试JUnit"><a href="#尝试JUnit" class="headerlink" title="尝试JUnit"></a>尝试JUnit</h3><p>首先需要导入JUnit依赖，我们在这里使用Junit4进行介绍，最新的Junit5放到Maven板块一起讲解，Jar包已经放在视频下方简介中，直接去下载即可。同时IDEA需要安装JUnit插件（默认是已经捆绑安装的，因此无需多余配置）</p><p>现在我们创建一个新的类，来编写我们的单元测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是测试用例1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是测试用例1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"我是测试用例2"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以点击类前面的测试按钮，或是单个方法前的测试按钮，如果点击类前面的测试按钮，会执行所有的测试用例。</p><p>运行测试后，我们发现控制台得到了一个测试结果，显示为绿色表示测试通过。</p><p>只需要通过打上<code>@Test</code>注解，即可将一个方法标记为测试案例，我们可以直接运行此测试案例，但是我们编写的测试方法有以下要求：</p><ul><li>方法必须是public的</li><li>不能是静态方法</li><li>返回值必须是void</li><li>必须是没有任何参数的方法</li></ul><p>对于一个测试案例来说，我们肯定希望测试的结果是我们所期望的一个值，因此，如果测试的结果并不是我们所期望的结果，那么这个测试就应该没有成功通过！</p><p>我们可以通过断言工具类来进行判定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是测试案例！&quot;</span>);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是测试案例！&quot;</span>);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">//参数1是期盼值，参数2是实际测试结果值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过运行代码后，我们发现测试过程中抛出了一个错误，并且IDEA给我们显示了期盼结果和测试结果，那么现在我们来测试一个案例，比如我们想查看冒泡排序的编写是否正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br><br>    <span class="hljs-comment">//错误的冒泡排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">int</span> tmp = arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// arr[j+1] = tmp;</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    Assert.assertArrayEquals(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br><br>    <span class="hljs-comment">//错误的冒泡排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">int</span> tmp = arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// arr[j+1] = tmp;</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    Assert.assertArrayEquals(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;, arr);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过测试，我们发现得到的结果并不是我们想要的结果，因此现在我们需要去修改为正确的冒泡排序，修改后，测试就能正确通过了。我们还可以再通过一个案例来更加深入地了解测试，现在我们想测试从数据库中取数据是否为我们预期的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>        Student student = mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><br>        Assert.assertEquals(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">&quot;小明&quot;</span>).setSex(<span class="hljs-string">&quot;男&quot;</span>).setSid(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = MybatisUtil.getSession(<span class="hljs-keyword">true</span>))&#123;<br>        TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>        Student student = mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><br>        Assert.assertEquals(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">&quot;小明&quot;</span>).setSex(<span class="hljs-string">&quot;男&quot;</span>).setSid(<span class="hljs-number">1</span>), student);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如果我们在进行所有的测试之前需要做一些前置操作该怎么办呢，一种办法是在所有的测试用例前面都加上前置操作，但是这样显然是很冗余的，因为一旦发生修改就需要挨个进行修改，因此我们需要更加智能的方法，我们可以通过<code>@Before</code>注解来添加测试用例开始之前的前置操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;测试前置正在初始化...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                    .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;测试初始化完成，正在开始测试案例...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            Student student = mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><br>            Assert.assertEquals(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">&quot;小明&quot;</span>).setSex(<span class="hljs-string">&quot;男&quot;</span>).setSid(<span class="hljs-number">1</span>), student);<br>            System.out.println(<span class="hljs-string">&quot;测试用例1通过！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            Student student = mapper.getStudentBySidAndSex(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;女&quot;</span>);<br><br>            Assert.assertEquals(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">&quot;小红&quot;</span>).setSex(<span class="hljs-string">&quot;女&quot;</span>).setSid(<span class="hljs-number">2</span>), student);<br>            System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;测试前置正在初始化...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                    .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;测试初始化完成，正在开始测试案例...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            Student student = mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><br>            Assert.assertEquals(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">&quot;小明&quot;</span>).setSex(<span class="hljs-string">&quot;男&quot;</span>).setSid(<span class="hljs-number">1</span>), student);<br>            System.out.println(<span class="hljs-string">&quot;测试用例1通过！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            Student student = mapper.getStudentBySidAndSex(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;女&quot;</span>);<br><br>            Assert.assertEquals(<span class="hljs-keyword">new</span> Student().setName(<span class="hljs-string">&quot;小红&quot;</span>).setSex(<span class="hljs-string">&quot;女&quot;</span>).setSid(<span class="hljs-number">2</span>), student);<br>            System.out.println(<span class="hljs-string">"测试用例2通过！"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，在所有的测试完成之后，我们还想添加一个收尾的动作，那么只需要使用<code>@After</code>注解即可添加结束动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@After</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@After</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">"测试结束，收尾工作正在进行..."</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>有关JUnit的使用我们就暂时只介绍这么多。</p><hr><h2 id="JUL日志系统"><a href="#JUL日志系统" class="headerlink" title="JUL日志系统"></a>JUL日志系统</h2><p>首先一问：我们为什么需要日志系统？</p><p>我们之前一直都在使用<code>System.out.println</code>来打印信息，但是，如果项目中存在大量的控制台输出语句，会显得很凌乱，而且日志的粒度是不够细的，假如我们现在希望，项目只在debug的情况下打印某些日志，而在实际运行时不打印日志，采用直接输出的方式就很难实现了，因此我们需要使用日志框架来规范化日志输出。</p><p>而JDK为我们提供了一个自带的日志框架，位于<code>java.util.logging</code>包下，我们可以使用此框架来实现日志的规范化打印，使用起来非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 首先获取日志打印器</span><br>        Logger logger = Logger.getLogger(Main.class.getName());<br>      <span class="hljs-comment">// 调用info来输出一个普通的信息，直接填写字符串即可</span><br>        logger.info(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 首先获取日志打印器</span><br>        Logger logger = Logger.getLogger(Main.class.getName());<br>      <span class="hljs-comment">// 调用info来输出一个普通的信息，直接填写字符串即可</span><br>        logger.info(<span class="hljs-string">"我是普通的日志"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在主类中使用日志打印，得到日志的打印结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs tex"><code class="language-hljs tex">十一月 15, 2021 12:55:37 下午 com.test.Main main<br>信息: 我是普通的日志<br></code></pre></td></tr></table></figure><p>我们发现，通过日志输出的结果会更加规范。</p><h3 id="JUL日志讲解"><a href="#JUL日志讲解" class="headerlink" title="JUL日志讲解"></a>JUL日志讲解</h3><p>日志分为7个级别，详细信息我们可以在Level类中查看：</p><ul><li> SEVERE（最高值）- 一般用于代表严重错误</li><li>WARNING  - 一般用于表示某些警告，但是不足以判断为错误</li><li> INFO （默认级别）  -  常规消息</li><li> CONFIG</li><li> FINE</li><li> FINER</li><li> FINEST（最低值）</li></ul><p>我们之前通过<code>info</code>方法直接输出的结果就是使用的默认级别的日志，我们可以通过<code>log</code>方法来设定该条日志的输出级别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    logger.log(Level.SEVERE, <span class="hljs-string">&quot;严重的错误&quot;</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;我就是错误&quot;</span>));<br>    logger.log(Level.WARNING, <span class="hljs-string">&quot;警告的内容&quot;</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">&quot;普通的信息&quot;</span>);<br>    logger.log(Level.CONFIG, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    logger.log(Level.SEVERE, <span class="hljs-string">&quot;严重的错误&quot;</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;我就是错误&quot;</span>));<br>    logger.log(Level.WARNING, <span class="hljs-string">&quot;警告的内容&quot;</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">&quot;普通的信息&quot;</span>);<br>    logger.log(Level.CONFIG, <span class="hljs-string">"级别低于普通信息"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，级别低于默认级别的日志信息，无法输出到控制台，我们可以通过设置来修改日志的打印级别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Logger logger = Logger.getLogger(Main.class.getName());<br><br>    <span class="hljs-comment">//修改日志级别</span><br>    logger.setLevel(Level.CONFIG);<br>    <span class="hljs-comment">//不使用父日志处理器</span><br>    logger.setUseParentHandlers(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-comment">//使用自定义日志处理器</span><br>    ConsoleHandler handler = <span class="hljs-keyword">new</span> ConsoleHandler();<br>    handler.setLevel(Level.CONFIG);<br>    logger.addHandler(handler);<br><br>    logger.log(Level.SEVERE, <span class="hljs-string">&quot;严重的错误&quot;</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;我就是错误&quot;</span>));<br>    logger.log(Level.WARNING, <span class="hljs-string">&quot;警告的内容&quot;</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">&quot;普通的信息&quot;</span>);<br>    logger.log(Level.CONFIG, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Logger logger = Logger.getLogger(Main.class.getName());<br><br>    <span class="hljs-comment">//修改日志级别</span><br>    logger.setLevel(Level.CONFIG);<br>    <span class="hljs-comment">//不使用父日志处理器</span><br>    logger.setUseParentHandlers(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-comment">//使用自定义日志处理器</span><br>    ConsoleHandler handler = <span class="hljs-keyword">new</span> ConsoleHandler();<br>    handler.setLevel(Level.CONFIG);<br>    logger.addHandler(handler);<br><br>    logger.log(Level.SEVERE, <span class="hljs-string">&quot;严重的错误&quot;</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;我就是错误&quot;</span>));<br>    logger.log(Level.WARNING, <span class="hljs-string">&quot;警告的内容&quot;</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">&quot;普通的信息&quot;</span>);<br>    logger.log(Level.CONFIG, <span class="hljs-string">"级别低于普通信息"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>每个<code>Logger</code>都有一个父日志打印器，我们可以通过<code>getParent()</code>来获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    System.out.println(logger.getParent().getClass());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，得到的是<code>java.util.logging.LogManager$RootLogger</code>这个类，它默认使用的是ConsoleHandler，且日志级别为INFO，由于每一个日志打印器都会直接使用父类的处理器，因此我们之前需要关闭父类然后使用我们自己的处理器。</p><p>我们通过使用自己日志处理器来自定义级别的信息打印到控制台，当然，日志处理器不仅仅只有控制台打印，我们也可以使用文件处理器来处理日志信息，我们继续添加一个处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//添加输出到本地文件</span><br>FileHandler fileHandler = <span class="hljs-keyword">new</span> FileHandler(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-comment">//添加输出到本地文件</span><br>FileHandler fileHandler = <span class="hljs-keyword">new</span> FileHandler(<span class="hljs-string">"test.log"</span>);<br>fileHandler.setLevel(Level.WARNING);<br>logger.addHandler(fileHandler);<br></code></pre></td></tr></table></figure><p>注意，这个时候就有两个日志处理器了，因此控制台和文件的都会生效。如果日志的打印格式我们不喜欢，我们还可以自定义打印格式，比如我们控制台处理器就默认使用的是<code>SimpleFormatter</code>，而文件处理器则是使用的<code>XMLFormatter</code>，我们可以自定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//使用自定义日志处理器(控制台)</span><br>ConsoleHandler handler = <span class="hljs-keyword">new</span> ConsoleHandler();<br>handler.setLevel(Level.CONFIG);<br>handler.setFormatter(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">//使用自定义日志处理器(控制台)</span><br>ConsoleHandler handler = <span class="hljs-keyword">new</span> ConsoleHandler();<br>handler.setLevel(Level.CONFIG);<br>handler.setFormatter(<span class="hljs-keyword">new</span> XMLFormatter());<br>logger.addHandler(handler);<br></code></pre></td></tr></table></figure><p>我们可以直接配置为想要的打印格式，如果这些格式还不能满足你，那么我们也可以自行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    logger.setUseParentHandlers(<span class="hljs-keyword">false</span>);<br><br>    <span class="hljs-comment">//为了让颜色变回普通的颜色，通过代码块在初始化时将输出流设定为System.out</span><br>    ConsoleHandler handler = <span class="hljs-keyword">new</span> ConsoleHandler()&#123;&#123;<br>        setOutputStream(System.out);<br>    &#125;&#125;;<br>    <span class="hljs-comment">//创建匿名内部类实现自定义的格式</span><br>    handler.setFormatter(<span class="hljs-keyword">new</span> Formatter() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">format</span><span class="hljs-params">(LogRecord record)</span> </span>&#123;<br>            SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);<br>            String time = format.format(<span class="hljs-keyword">new</span> Date(record.getMillis()));  <span class="hljs-comment">//格式化日志时间</span><br>            String level = record.getLevel().getName();  <span class="hljs-comment">// 获取日志级别名称</span><br>            <span class="hljs-comment">// String level = record.getLevel().getLocalizedName();   // 获取本地化名称（语言跟随系统）</span><br>            String thread = String.format(<span class="hljs-string">&quot;%10s&quot;</span>, Thread.currentThread().getName());  <span class="hljs-comment">//线程名称（做了格式化处理，留出10格空间）</span><br>            <span class="hljs-keyword">long</span> threadID = record.getThreadID();   <span class="hljs-comment">//线程ID</span><br>            String className = String.format(<span class="hljs-string">&quot;%-20s&quot;</span>, record.getSourceClassName());  <span class="hljs-comment">//发送日志的类名</span><br>            String msg = record.getMessage();   <span class="hljs-comment">//日志消息</span><br><br>          <span class="hljs-comment">//\033[33m作为颜色代码，30~37都有对应的颜色，38是没有颜色，IDEA能显示，但是某些地方可能不支持</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\033[38m&quot;</span> + time + <span class="hljs-string">&quot;  \033[33m&quot;</span> + level + <span class="hljs-string">&quot; \033[35m&quot;</span> + threadID<br>                    + <span class="hljs-string">&quot;\033[38m --- [&quot;</span> + thread + <span class="hljs-string">&quot;] \033[36m&quot;</span> + className + <span class="hljs-string">&quot;\033[38m : &quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>    &#125;);<br>    logger.addHandler(handler);<br><br>    logger.info(<span class="hljs-string">&quot;我是测试消息1...&quot;</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">&quot;我是测试消息2...&quot;</span>);<br>    logger.log(Level.WARNING, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    logger.setUseParentHandlers(<span class="hljs-keyword">false</span>);<br><br>    <span class="hljs-comment">//为了让颜色变回普通的颜色，通过代码块在初始化时将输出流设定为System.out</span><br>    ConsoleHandler handler = <span class="hljs-keyword">new</span> ConsoleHandler()&#123;&#123;<br>        setOutputStream(System.out);<br>    &#125;&#125;;<br>    <span class="hljs-comment">//创建匿名内部类实现自定义的格式</span><br>    handler.setFormatter(<span class="hljs-keyword">new</span> Formatter() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">format</span><span class="hljs-params">(LogRecord record)</span> </span>&#123;<br>            SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);<br>            String time = format.format(<span class="hljs-keyword">new</span> Date(record.getMillis()));  <span class="hljs-comment">//格式化日志时间</span><br>            String level = record.getLevel().getName();  <span class="hljs-comment">// 获取日志级别名称</span><br>            <span class="hljs-comment">// String level = record.getLevel().getLocalizedName();   // 获取本地化名称（语言跟随系统）</span><br>            String thread = String.format(<span class="hljs-string">&quot;%10s&quot;</span>, Thread.currentThread().getName());  <span class="hljs-comment">//线程名称（做了格式化处理，留出10格空间）</span><br>            <span class="hljs-keyword">long</span> threadID = record.getThreadID();   <span class="hljs-comment">//线程ID</span><br>            String className = String.format(<span class="hljs-string">&quot;%-20s&quot;</span>, record.getSourceClassName());  <span class="hljs-comment">//发送日志的类名</span><br>            String msg = record.getMessage();   <span class="hljs-comment">//日志消息</span><br><br>          <span class="hljs-comment">//\033[33m作为颜色代码，30~37都有对应的颜色，38是没有颜色，IDEA能显示，但是某些地方可能不支持</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\033[38m&quot;</span> + time + <span class="hljs-string">&quot;  \033[33m&quot;</span> + level + <span class="hljs-string">&quot; \033[35m&quot;</span> + threadID<br>                    + <span class="hljs-string">&quot;\033[38m --- [&quot;</span> + thread + <span class="hljs-string">&quot;] \033[36m&quot;</span> + className + <span class="hljs-string">&quot;\033[38m : &quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>    &#125;);<br>    logger.addHandler(handler);<br><br>    logger.info(<span class="hljs-string">&quot;我是测试消息1...&quot;</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">&quot;我是测试消息2...&quot;</span>);<br>    logger.log(Level.WARNING, <span class="hljs-string">"我是测试消息3..."</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志可以设置过滤器，如果我们不希望某些日志信息被输出，我们可以配置过滤规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Logger logger = Logger.getLogger(Main.class.getName());<br><br>    <span class="hljs-comment">//自定义过滤规则</span><br>    logger.setFilter(record -&gt; !record.getMessage().contains(<span class="hljs-string">&quot;普通&quot;</span>));<br><br>    logger.log(Level.SEVERE, <span class="hljs-string">&quot;严重的错误&quot;</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;我就是错误&quot;</span>));<br>    logger.log(Level.WARNING, <span class="hljs-string">&quot;警告的内容&quot;</span>);<br>    logger.log(Level.INFO, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Logger logger = Logger.getLogger(Main.class.getName());<br><br>    <span class="hljs-comment">//自定义过滤规则</span><br>    logger.setFilter(record -&gt; !record.getMessage().contains(<span class="hljs-string">&quot;普通&quot;</span>));<br><br>    logger.log(Level.SEVERE, <span class="hljs-string">&quot;严重的错误&quot;</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;我就是错误&quot;</span>));<br>    logger.log(Level.WARNING, <span class="hljs-string">&quot;警告的内容&quot;</span>);<br>    logger.log(Level.INFO, <span class="hljs-string">"普通的信息"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，整个日志的输出流程如下：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20210310214730384.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4NjIzMzc1%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639566412&t=aec06446b8338134a3dbddfaba9bde69" alt="img"></p><h3 id="Properties配置文件"><a href="#Properties配置文件" class="headerlink" title="Properties配置文件"></a>Properties配置文件</h3><p>Properties文件是Java的一种配置文件，我们之前学习了XML，但是我们发现XML配置文件读取实在是太麻烦，那么能否有一种简单一点的配置文件呢？我们可以使用Properties文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-attr">name</span>=<span class="hljs-string">Test</span><br><span class="hljs-attr">desc</span>=<span class="hljs-string"><code class="language-hljs properties"><span class="hljs-attr">name</span>=<span class="hljs-string">Test</span><br><span class="hljs-attr">desc</span>=<span class="hljs-string">Description</span><br></code></pre></td></tr></table></figure><p>该文件配置很简单，格式为<code>配置项=配置值</code>，我们可以直接通过<code>Properties</code>类来将其读取为一个类似于Map一样的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Properties properties = <span class="hljs-keyword">new</span> Properties();<br>    properties.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Properties properties = <span class="hljs-keyword">new</span> Properties();<br>    properties.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.properties"</span>));<br>    System.out.println(properties);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，<code>Properties</code>类是继承自<code>Hashtable</code>，而<code>Hashtable</code>是实现的Map接口，也就是说，<code>Properties</code>本质上就是一个Map一样的结构，它会把所有的配置项映射为一个Map，这样我们就可以快速地读取对应配置的值了。</p><p>我们也可以将已经存在的Properties对象放入输出流进行保存，我们这里就不保存文件了，而是直接打印到控制台，我们只需要提供输出流即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Properties properties = <span class="hljs-keyword">new</span> Properties();<br>  <span class="hljs-comment">// properties.setProperty(&quot;test&quot;, &quot;lbwnb&quot;);  //和put效果一样</span><br>    properties.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    properties.store(System.out, <span class="hljs-string">&quot;????&quot;</span>);<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Properties properties = <span class="hljs-keyword">new</span> Properties();<br>  <span class="hljs-comment">// properties.setProperty(&quot;test&quot;, &quot;lbwnb&quot;);  //和put效果一样</span><br>    properties.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    properties.store(System.out, <span class="hljs-string">&quot;????&quot;</span>);<br>  <span class="hljs-comment">//properties.storeToXML(System.out, "????");  保存为XML格式</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过<code>System.getProperties()</code>获取系统的参数，我们来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.getProperties().store(System.out, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.getProperties().store(System.out, <span class="hljs-string">"系统信息："</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编写日志配置文件"><a href="#编写日志配置文件" class="headerlink" title="编写日志配置文件"></a>编写日志配置文件</h3><p>我们可以通过进行配置文件来规定日志打印器的一些默认值：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-comment"># RootLogger 的默认处理器为</span><br><span class="hljs-attr">handlers</span>= <span class="hljs-string">java.util.logging.ConsoleHandler</span><br><span class="hljs-comment"># RootLogger 的默认的日志级别</span><br><span class="hljs-meta">.level</span>= <span class="hljs-string"><code class="language-hljs properties"><span class="hljs-comment"># RootLogger 的默认处理器为</span><br><span class="hljs-attr">handlers</span>= <span class="hljs-string">java.util.logging.ConsoleHandler</span><br><span class="hljs-comment"># RootLogger 的默认的日志级别</span><br><span class="hljs-meta">.level</span>= <span class="hljs-string">CONFIG</span><br></code></pre></td></tr></table></figure><p>我们来尝试使用配置文件来进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//获取日志管理器</span><br>    LogManager manager = LogManager.getLogManager();<br>    <span class="hljs-comment">//读取我们自己的配置文件</span><br>    manager.readConfiguration(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;logging.properties&quot;</span>));<br>    <span class="hljs-comment">//再获取日志打印器</span><br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    logger.log(Level.CONFIG, <span class="hljs-string">&quot;我是一条日志信息&quot;</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//获取日志管理器</span><br>    LogManager manager = LogManager.getLogManager();<br>    <span class="hljs-comment">//读取我们自己的配置文件</span><br>    manager.readConfiguration(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;logging.properties&quot;</span>));<br>    <span class="hljs-comment">//再获取日志打印器</span><br>    Logger logger = Logger.getLogger(Main.class.getName());<br>    logger.log(Level.CONFIG, <span class="hljs-string">&quot;我是一条日志信息&quot;</span>);   <span class="hljs-comment">//通过自定义配置文件，我们发现默认级别不再是INFO了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以去修改<code>ConsoleHandler</code>的默认配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-comment"># 指定默认日志级别</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string">ALL</span><br><span class="hljs-comment"># 指定默认日志消息格式</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.formatter</span> = <span class="hljs-string">java.util.logging.SimpleFormatter</span><br><span class="hljs-comment"># 指定默认的字符集</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.encoding</span> = <span class="hljs-string"><code class="language-hljs properties"><span class="hljs-comment"># 指定默认日志级别</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string">ALL</span><br><span class="hljs-comment"># 指定默认日志消息格式</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.formatter</span> = <span class="hljs-string">java.util.logging.SimpleFormatter</span><br><span class="hljs-comment"># 指定默认的字符集</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.encoding</span> = <span class="hljs-string">UTF-8</span><br></code></pre></td></tr></table></figure><p>其实，我们阅读<code>ConsoleHandler</code>的源码就会发现，它就是通过读取配置文件来进行某些参数设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// Private method to configure a ConsoleHandler from LogManager</span><br><span class="hljs-comment">// properties and/or default values as specified in the class</span><br><span class="hljs-comment">// javadoc.</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">()</span> </span>&#123;<br>    LogManager manager = LogManager.getLogManager();<br>    String cname = getClass().getName();<br><br>    setLevel(manager.getLevelProperty(cname +<span class="hljs-string">&quot;.level&quot;</span>, Level.INFO));<br>    setFilter(manager.getFilterProperty(cname +<span class="hljs-string">&quot;.filter&quot;</span>, <span class="hljs-keyword">null</span>));<br>    setFormatter(manager.getFormatterProperty(cname +<span class="hljs-string">&quot;.formatter&quot;</span>, <span class="hljs-keyword">new</span> SimpleFormatter()));<br>    <span class="hljs-keyword">try</span> &#123;<br>        setEncoding(manager.getStringProperty(cname +<span class="hljs-string">&quot;.encoding&quot;</span>, <span class="hljs-keyword">null</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            setEncoding(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex2) &#123;<br>            <span class="hljs-comment">// doing a setEncoding with null should always work.</span><br>            <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Private method to configure a ConsoleHandler from LogManager</span><br><span class="hljs-comment">// properties and/or default values as specified in the class</span><br><span class="hljs-comment">// javadoc.</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">()</span> </span>&#123;<br>    LogManager manager = LogManager.getLogManager();<br>    String cname = getClass().getName();<br><br>    setLevel(manager.getLevelProperty(cname +<span class="hljs-string">&quot;.level&quot;</span>, Level.INFO));<br>    setFilter(manager.getFilterProperty(cname +<span class="hljs-string">&quot;.filter&quot;</span>, <span class="hljs-keyword">null</span>));<br>    setFormatter(manager.getFormatterProperty(cname +<span class="hljs-string">&quot;.formatter&quot;</span>, <span class="hljs-keyword">new</span> SimpleFormatter()));<br>    <span class="hljs-keyword">try</span> &#123;<br>        setEncoding(manager.getStringProperty(cname +<span class="hljs-string">&quot;.encoding&quot;</span>, <span class="hljs-keyword">null</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            setEncoding(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex2) &#123;<br>            <span class="hljs-comment">// doing a setEncoding with null should always work.</span><br>            <span class="hljs-comment">// assert false;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用Lombok快速开启日志"><a href="#使用Lombok快速开启日志" class="headerlink" title="使用Lombok快速开启日志"></a>使用Lombok快速开启日志</h3><p>我们发现，如果我们现在需要全面使用日志系统，而不是传统的直接打印，那么就需要在每个类都去编写获取Logger的代码，这样显然是很冗余的，能否简化一下这个流程呢？</p><p>前面我们学习了Lombok，我们也体会到Lombok给我们带来的便捷，我们可以通过一个注解快速生成构造方法、Getter和Setter，同样的，Logger也是可以使用Lombok快速生成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;自动生成的Logger名称：&quot;</span>+log.getName());<br>        log.info(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;自动生成的Logger名称：&quot;</span>+log.getName());<br>        log.info(<span class="hljs-string">"我是日志信息"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要添加一个<code>@Log</code>注解即可，添加后，我们可以直接使用一个静态变量log，而它就是自动生成的Logger。我们也可以手动指定名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Log(topic = &quot;打工是不可能打工的&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;自动生成的Logger名称：&quot;</span>+log.getName());<br>        log.info(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Log(topic = &quot;打工是不可能打工的&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;自动生成的Logger名称：&quot;</span>+log.getName());<br>        log.info(<span class="hljs-string">"我是日志信息"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Mybatis日志系统"><a href="#Mybatis日志系统" class="headerlink" title="Mybatis日志系统"></a>Mybatis日志系统</h3><p>Mybatis也有日志系统，它详细记录了所有的数据库操作等，但是我们在前面的学习中没有开启它，现在我们学习了日志之后，我们就可以尝试开启Mybatis的日志系统，来监控所有的数据库操作，要开启日志系统，我们需要进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"STDOUT_LOGGING"</span> /></span><br></code></pre></td></tr></table></figure><p><code>logImpl</code>包括很多种配置项，包括 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING，而默认情况下是未配置，也就是说不打印。我们这里将其设定为STDOUT_LOGGING表示直接使用标准输出将日志信息打印到控制台，我们编写一个测试案例来看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                    .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            System.out.println(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男&quot;</span>));<br>            System.out.println(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                    .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            System.out.println(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男&quot;</span>));<br>            System.out.println(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">"男"</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，两次获取学生信息，只有第一次打开了数据库连接，而第二次并没有。</p><p>现在我们学习了日志系统，那么我们来尝试使用日志系统输出Mybatis的日志信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"JDK_LOGGING"</span> /></span><br></code></pre></td></tr></table></figure><p>将其配置为JDK_LOGGING表示使用JUL进行日志打印，因为Mybatis的日志级别都比较低，因此我们需要设置一下<code>logging.properties</code>默认的日志级别：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-attr">handlers</span>= <span class="hljs-string">java.util.logging.ConsoleHandler</span><br><span class="hljs-meta">.level</span>= <span class="hljs-string">ALL</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string"><code class="language-hljs properties"><span class="hljs-attr">handlers</span>= <span class="hljs-string">java.util.logging.ConsoleHandler</span><br><span class="hljs-meta">.level</span>= <span class="hljs-string">ALL</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string">ALL</span><br></code></pre></td></tr></table></figure><p>代码编写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                    .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>            LogManager manager = LogManager.getLogManager();<br>            manager.readConfiguration(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;logging.properties&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            log.info(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男&quot;</span>).toString());<br>            log.info(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string"><code class="language-hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                    .build(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));<br>            LogManager manager = LogManager.getLogManager();<br>            manager.readConfiguration(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;logging.properties&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper mapper = sqlSession.getMapper(TestMapper.class);<br>            log.info(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男&quot;</span>).toString());<br>            log.info(mapper.getStudentBySidAndSex(<span class="hljs-number">1</span>, <span class="hljs-string">"男"</span>).toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们发现，这样的日志信息根本没法看，因此我们需要修改一下日志的打印格式，我们自己创建一个格式化类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFormatter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Formatter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">format</span><span class="hljs-params">(LogRecord record)</span> </span>&#123;<br>        SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);<br>        String time = format.format(<span class="hljs-keyword">new</span> Date(record.getMillis()));  <span class="hljs-comment">//格式化日志时间</span><br>        <span class="hljs-keyword">return</span> time + <span class="hljs-string">&quot; : &quot;</span> + record.getMessage() + <span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFormatter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Formatter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">format</span><span class="hljs-params">(LogRecord record)</span> </span>&#123;<br>        SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);<br>        String time = format.format(<span class="hljs-keyword">new</span> Date(record.getMillis()));  <span class="hljs-comment">//格式化日志时间</span><br>        <span class="hljs-keyword">return</span> time + <span class="hljs-string">&quot; : &quot;</span> + record.getMessage() + <span class="hljs-string">"\n"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在再来修改一下默认的格式化实现：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-attr">handlers</span>= <span class="hljs-string">java.util.logging.ConsoleHandler</span><br><span class="hljs-meta">.level</span>= <span class="hljs-string">ALL</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string">ALL</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.formatter</span> = <span class="hljs-string"><code class="language-hljs properties"><span class="hljs-attr">handlers</span>= <span class="hljs-string">java.util.logging.ConsoleHandler</span><br><span class="hljs-meta">.level</span>= <span class="hljs-string">ALL</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.level</span> = <span class="hljs-string">ALL</span><br><span class="hljs-meta">java.util.logging.ConsoleHandler.formatter</span> = <span class="hljs-string">com.test.TestFormatter</span><br></code></pre></td></tr></table></figure><p>现在就好看多了，当然，我们还可以继续为Mybatis添加文件日志，这里就不做演示了。</p><hr><h2 id="使用Maven管理项目"><a href="#使用Maven管理项目" class="headerlink" title="使用Maven管理项目"></a>使用Maven管理项目</h2><p><strong>注意：</strong>开始之前，看看你C盘空间够不够，最好预留2GB空间以上！</p><p><strong>吐槽：</strong>很多电脑预装系统C盘都给得巨少，就算不装软件，一些软件的缓存文件也能给你塞满，建议有时间重装一下系统重新分配一下磁盘空间。</p><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p><p>通过Maven，可以帮助我们做：</p><ul><li>项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。</li><li>依赖管理，项目使用到哪些依赖，可以快速完成导入。</li></ul><p>我们之前并没有讲解如何将我们的项目打包为Jar文件运行，同时，我们导入依赖的时候，每次都要去下载对应的Jar包，这样其实是很麻烦的，并且还有可能一个Jar包依赖于另一个Jar包，就像之前使用JUnit一样，因此我们需要一个更加方便的包管理机制。</p><p>Maven也需要安装环境，但是IDEA已经自带了Maven环境，因此我们不需要再去进行额外的环境安装（无IDEA也能使用Maven，但是配置过程很麻烦，并且我们现在使用的都是IDEA的集成开发环境，所以这里就不讲解Maven命令行操作了）我们直接创建一个新的Maven项目即可。</p><h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h3><p>我们可以来看一下，一个Maven项目和我们普通的项目有什么区别：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F910235ebc812ba94abb0f762e3914f67.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639621411&t=2a62e7ef9b056d8cbe772e34fea0cc6f" alt="img"></p><p>那么首先，我们需要了解一下POM文件，它相当于是我们整个Maven项目的配置文件，它也是使用XML编写的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>MavenTest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>MavenTest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>></span><br></code></pre></td></tr></table></figure><p>我们可以看到，Maven的配置文件是以<code>project</code>为根节点，而<code>modelVersion</code>定义了当前模型的版本，一般是4.0.0，我们不用去修改。</p><p><code>groupId</code>、<code>artifactId</code>、<code>version</code>这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的Maven坐标，因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入。</p><ul><li><code>groupId</code> 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是<code>org.example</code>，一个组下面可以有很多个项目。</li><li><code>artifactId</code> 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。</li><li><code>version</code> 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号）</li></ul><p><code>properties</code>中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为1.8，无需进行修改。</p><h3 id="Maven依赖导入"><a href="#Maven依赖导入" class="headerlink" title="Maven依赖导入"></a>Maven依赖导入</h3><p>现在我们尝试使用Maven来帮助我们快速导入依赖，我们需要导入之前的JDBC驱动依赖、JUnit依赖、Mybatis依赖、Lombok依赖，那么如何使用Maven来管理依赖呢？</p><p>我们可以创建一个<code>dependencies</code>节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    //里面填写的就是所有的依赖<br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    //里面填写的就是所有的依赖<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>></span><br></code></pre></td></tr></table></figure><p>那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？我们可以在：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a> 进行查询（可能打不开，建议用流量，或是直接百度某个项目的Maven依赖），我们直接搜索lombok即可，打开后可以看到已经给我们写出了依赖的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>我们直接将其添加到<code>dependencies</code>节点中即可，现在我们来编写一个测试用例看看依赖导入成功了没有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>);<br>        System.out.println(student);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>项目运行成功，表示成功导入了依赖。那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201901%2F20190106202802893827.png&refer=http%3A%2F%2Fimage.bubuko.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639624645&t=75fdf146baa915fbba88918895f92b81" alt="img"></p><p>通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（私服），几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（Maven第一次导入依赖是需要联网的），远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个<code>.m2</code>文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，如果你C盘空间不足，会出现问题！</p><p>在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。</p><p>可能在导入依赖时，小小伙伴们会出现卡顿的问题，我们建议配置一下IDEA自带的Maven插件远程仓库地址，我们打开IDEA的安装目录，找到<code>安装根目录/plugins/maven/lib/maven3/conf</code>文件夹，找到<code>settings.xml</code>文件，打开编辑：</p><p>找到mirros标签，添加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>></span> <br></code></pre></td></tr></table></figure><p>这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了）</p><h3 id="Maven依赖作用域"><a href="#Maven依赖作用域" class="headerlink" title="Maven依赖作用域"></a>Maven依赖作用域</h3><p>除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性：</p><ul><li><strong>type</strong>：依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar</li><li><strong>scope</strong>：依赖的范围（作用域，着重讲解）</li><li><strong>optional</strong>：标记依赖是否可选</li><li><strong>exclusions</strong>：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok）</li></ul><p>我们着重来讲解一下<code>scope</code>属性，它决定了依赖的作用域范围：</p><ul><li><strong>compile</strong> ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。</li><li><strong>provided</strong> ：在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。</li><li><strong>runtime</strong> ：在运行、测试时有效，但是在编译代码时无效。比如我们如果需要自己写一个JDBC实现，那么肯定要用到JDK为我们指定的接口，但是实际上在运行时是不用自带JDK的依赖，因此只保留我们自己写的内容即可。</li><li><strong>test</strong> ：只在测试时有效，例如：JUnit，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入JUnit的依赖：</li></ul><p>同样的，我们可以在网站上搜索Junit的依赖，我们这里导入最新的JUnit5作为依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;测试&quot;</span>);<br>      <span class="hljs-comment">//Assert在JUnit5时名称发生了变化Assertions</span><br>        Assertions.assertArrayEquals(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;测试&quot;</span>);<br>      <span class="hljs-comment">//Assert在JUnit5时名称发生了变化Assertions</span><br>        Assertions.assertArrayEquals(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，一般仅用作测试的依赖如JUnit只保留在测试中即可，那么现在我们再来添加JDBC和Mybatis的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>我们发现，Maven还给我们提供了一个<code>resource</code>文件夹，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的Jar中，比如我们在这里编写一个Mybatis的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JDK_LOGGING&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 需要在environments的上方 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.test.entity&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JDK_LOGGING&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 需要在environments的上方 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.test.entity&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>></span><br></code></pre></td></tr></table></figure><p>现在我们创建一下测试用例，顺便带大家了解一下Junit5的一些比较方便的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;<br><br>    <span class="hljs-comment">//因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory factory;<br><br>    <span class="hljs-comment">//在JUnit5中@Before被废弃，它被细分了：</span><br>    <span class="hljs-meta">@BeforeAll</span> <span class="hljs-comment">// 一次性开启所有测试案例只会执行一次 (方法必须是static)</span><br>    <span class="hljs-comment">// @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                .build(Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis.xml&quot;</span>));<br>    &#125;<br><br><br>    <span class="hljs-meta">@DisplayName(&quot;Mybatis数据库测试&quot;)</span>  <span class="hljs-comment">//自定义测试名称</span><br>    <span class="hljs-meta">@RepeatedTest(3)</span>  <span class="hljs-comment">//自动执行多次测试</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession sqlSession = factory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>            System.out.println(testMapper.getStudentBySid(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;<br><br>    <span class="hljs-comment">//因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory factory;<br><br>    <span class="hljs-comment">//在JUnit5中@Before被废弃，它被细分了：</span><br>    <span class="hljs-meta">@BeforeAll</span> <span class="hljs-comment">// 一次性开启所有测试案例只会执行一次 (方法必须是static)</span><br>    <span class="hljs-comment">// @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br>                .build(Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis.xml&quot;</span>));<br>    &#125;<br><br><br>    <span class="hljs-meta">@DisplayName(&quot;Mybatis数据库测试&quot;)</span>  <span class="hljs-comment">//自定义测试名称</span><br>    <span class="hljs-meta">@RepeatedTest(3)</span>  <span class="hljs-comment">//自动执行多次测试</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession sqlSession = factory.openSession(<span class="hljs-keyword">true</span>))&#123;<br>            TestMapper testMapper = sqlSession.getMapper(TestMapper.class);<br>            System.out.println(testMapper.getStudentBySid(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？我们可以使用第四种作用域：</p><ul><li><strong>system</strong>：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.jntm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lbwnb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span>C://学习资料/4K高清无码/test.jar<span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.jntm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lbwnb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span>C://学习资料/4K高清无码/test.jar<span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>比如上面的例子，如果scope为system，那么我们需要添加一个systemPath来指定jar文件的位置，这里就不再演示了。</p><h3 id="Maven可选依赖"><a href="#Maven可选依赖" class="headerlink" title="Maven可选依赖"></a>Maven可选依赖</h3><p>当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加<code>optional</code>标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>></span><br></code></pre></td></tr></table></figure><p>比如Mybatis的POM文件中，就存在大量的可选依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br> ...<br></code></pre></td></tr></table></figure><p>由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。</p><h3 id="Maven排除依赖"><a href="#Maven排除依赖" class="headerlink" title="Maven排除依赖"></a>Maven排除依赖</h3><p>我们了解了可选依赖，现在我们可以让使用此项目作为依赖的项目默认不使用可选依赖，但是如果存在那种不是可选依赖，但是我们导入此项目有不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>></span><br></code></pre></td></tr></table></figure><p>我们这里演示了排除JUnit的一些依赖，我们可以在外部库中观察排除依赖之后和之前的效果。</p><h3 id="Maven继承关系"><a href="#Maven继承关系" class="headerlink" title="Maven继承关系"></a>Maven继承关系</h3><p>一个Maven项目可以继承自另一个Maven项目，比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。</p><p>我们右键左侧栏，新建一个模块，来创建一个子项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>MavenTest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ChildModel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>MavenTest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ChildModel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>></span><br></code></pre></td></tr></table></figure><p>我们可以看到，IDEA默认给我们添加了一个parent节点，表示此Maven项目是父Maven项目的子项目，子项目直接继承父项目的<code>groupId</code>，子项目会直接继承父项目的所有依赖，除非依赖添加了optional标签，我们来编写一个测试用例尝试一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> lombok.extern.java.Log;<br><br><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        log.info(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">import</span> lombok.extern.java.Log;<br><br><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        log.info(<span class="hljs-string">"我是日志信息"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，子项目也成功继承了Lombok依赖。</p><p>我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理，我们可以将<code>dependencies</code>全部放入<code>dependencyManagement</code>节点，这样父项目就完全作为依赖统一管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>></span><br></code></pre></td></tr></table></figure><p>我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>></span><br></code></pre></td></tr></table></figure><p>当然，父项目如果还存在dependencies节点的话，里面的内依赖依然是直接继承：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>></span><br>      ...<br></code></pre></td></tr></table></figure><h3 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h3><p>我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期，实际上这些是Maven的一些插件，每个插件都有各自的功能，比如：</p><ul><li><code>clean</code>命令，执行后会清理整个<code>target</code>文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。</li><li><code>validate</code>命令可以验证项目的可用性。</li><li><code>compile</code>命令可以将项目编译为.class文件。</li><li><code>install</code>命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用</li><li><code>verify</code>命令可以按顺序执行每个默认生命周期阶段（<code>validate</code>，<code>compile</code>，<code>package</code>等）</li></ul><h3 id="Maven测试项目"><a href="#Maven测试项目" class="headerlink" title="Maven测试项目"></a>Maven测试项目</h3><p>通过使用<code>test</code>命令，可以一键测试所有位于test目录下的测试案例，请注意有以下要求：</p><ul><li>测试类的名称必须是以<code>Test</code>结尾，比如<code>MainTest</code></li><li>测试方法上必须标注<code>@Test</code>注解，实测<code>@RepeatedTest</code>无效</li></ul><p>这是由于JUnit5比较新，我们需要重新配置插件升级到高版本，才能完美的兼容Junit5：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- JUnit 5 requires Surefire version 2.22.0 or higher --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- JUnit 5 requires Surefire version 2.22.0 or higher --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>></span><br></code></pre></td></tr></table></figure><p>现在<code>@RepeatedTest</code>、<code>@BeforeAll</code>也能使用了。</p><h3 id="Maven打包项目"><a href="#Maven打包项目" class="headerlink" title="Maven打包项目"></a>Maven打包项目</h3><p>我们的项目在编写完成之后，要么作为Jar依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行<code>package</code>命令就可以直接对项目的代码进行打包，生成jar文件。</p><p>当然，以上方式仅适用于作为Jar依赖的情况，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，因为我们使用了别人为我们通过的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRefs</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRef</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRefs</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">addClasspath</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addClasspath</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.test.Main<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>make-assembly<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>single<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name"><code class="language-hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRefs</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRef</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRefs</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">addClasspath</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addClasspath</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.test.Main<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>make-assembly<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>single<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>></span><br></code></pre></td></tr></table></figure><p>在打包之前也会执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过，选择<code>执行Maven目标</code>来手动执行Maven命令，输入<code>mvn package -Dmaven.test.skip=true </code>来以跳过测试的方式进行打包。</p><p>最后得到我们的Jar文件，在同级目录下输入<code>java -jar xxxx.jar</code>来运行我们打包好的Jar可执行程序（xxx代表文件名称）</p><ul><li><code>deploy</code>命令用于发布项目到本地仓库和远程仓库，一般情况下用不到，这里就不做讲解了。</li><li><code>site</code>命令用于生成当前项目的发布站点，暂时不需要了解。</li></ul><p>我们之前还讲解了多模块项目，那么多模块下父项目存在一个<code>packing</code>打包类型标签，所有的父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build。</p><hr><h2 id="实战：基于Mybatis-JUL-Lombok-Maven的图书管理系统（带单元测试）"><a href="#实战：基于Mybatis-JUL-Lombok-Maven的图书管理系统（带单元测试）" class="headerlink" title="实战：基于Mybatis+JUL+Lombok+Maven的图书管理系统（带单元测试）"></a>实战：基于Mybatis+JUL+Lombok+Maven的图书管理系统（带单元测试）</h2><p>项目需求：</p><ul><li>在线录入学生信息和书籍信息</li><li>查询书籍信息列表</li><li>查询学生信息列表</li><li>查询借阅信息列表</li><li>完整的日志系统</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/16/1.html/"/>
      <url>/2022/03/16/1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><p>数据库是学习JavaWeb的一个前置，只有了解了数据库的操作和使用，我们才能更好地组织和管理网站应用产生的数据。</p><p><img src="https://img2.baidu.com/it/u=873816781,3605513900&fm=26&fmt=auto" alt="img"></p><h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><p>数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。</p><p>在JavaSE学习阶段中，我们学习了如何使用文件I/O来将数据保存到本地，这样就可以将一个数据持久地存储在本地，即使程序重新打开，我们也能加载回上一次的数据，但是当我们的数据变得非常多的时候，这样的方式就显得不太方便了。同时我们如果需要查找众多数据的中的某一个，就只能加载到内存再进行查找，这样显然是很难受的！</p><p>而数据库就是专门做这事的，我们可以快速查找想要的数据，便捷地插入、修改和删除数据，并且数据库不仅能做这些事，还能提供更多便于管理数据和操作数据的功能！</p><h3 id="常见的数据库"><a href="#常见的数据库" class="headerlink" title="常见的数据库"></a>常见的数据库</h3><p>常见的数据库有很多种，包括但不限于：</p><ul><li>MySQL - 免费，用的最多的，开源数据库，适用于中小型</li><li>Microsoft SQL Server - 收钱的，但是提供技术支持，适用于Windows Server</li><li>Oracle - 收钱的，大型数据库系统</li></ul><p>而我们要学习的是MySQL数据，其实无论学习哪种数据库，SQL语句大部分都是通用的，只有少许语法是不通用的，因此我们只需要学习一种数据库其他的也就差不多都会了。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点：</p><ul><li>属性不可再分</li><li>一个实体的属性可以有很多个</li><li>用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的</li><li>属性取值可以有一定的约束，比如性别只能是男或是女</li></ul><p>实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m）</p><p>MySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile1.renrendoc.com%2Ffileroot_temp2%2F2020-10%2F17%2F763fb9f3-871d-4f1c-abe7-0a5025cf52a5%2F763fb9f3-871d-4f1c-abe7-0a5025cf52a52.gif&refer=http%3A%2F%2Ffile1.renrendoc.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637926750&t=31a308e5d8efd32bae55a40c963f459d" alt="img"></p><p>通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。</p><h2 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h2><p>既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表：</p><ul><li>学生表：用于存放所有学生的数据，学生（<u>学号</u>，姓名，性别）</li><li>教师表：用于存放所有教师的数据，教师（<u>教师号</u>，姓名）</li><li>授课表：用于存放教师与学生的授课信息，授课（学号，教师号）</li></ul><p>其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。</p><p>为了理解起来更加轻松，我们从图形界面操作再讲到SQL语句，请不要着急。我们现在通过Navicat或idea自带的数据库客户端来创建一个数据库和上述三个表。</p><h2 id="数据库的规范化"><a href="#数据库的规范化" class="headerlink" title="数据库的规范化"></a>数据库的规范化</h2><p>要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。</p><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况：</p><ul><li>学生（姓名，电话号码）</li></ul><p>电话号码实际上包括了<code>家用座机电话</code>和<code>移动电话</code>，因此它可以被拆分为：</p><ul><li>学生（姓名，座机号码，手机号码）</li></ul><p>满足第一范式是关系型数据库最基本的要求！</p><h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如：</p><ul><li>学生（<u>学号</u>，姓名，性别）</li></ul><p>学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。</p><h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。</p><ul><li>学生借书情况（<u>借阅编号</u>，学生学号，书籍编号，书籍名称，书籍作者）</li></ul><p>实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表：</p><ul><li>学生借书情况（<u>借阅编号</u>，学生学号，书籍编号）</li><li>书籍（<u>书籍编号</u>，书籍名称，书籍作者）</li></ul><p>这样就消除了传递依赖，从而满足第三范式。</p><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：</p><p>(仓库ID, 存储物品ID) →(管理员ID, 数量)</p><p>(管理员ID, 存储物品ID) → (仓库ID, 数量)</p><p>所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p><p>(仓库ID) → (管理员ID)</p><p>(管理员ID) → (仓库ID)</p><p>即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。</p><hr><h2 id="认识SQL语句"><a href="#认识SQL语句" class="headerlink" title="认识SQL语句"></a>认识SQL语句</h2><p>结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。</p><p>SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用<code>;</code>进行结尾！</p><p>SQL也支持注释，通过使用<code>--</code>或是<code>#</code>来编写注释内容，也可以使用<code>/*</code>来进行多行注释。</p><p>我们要学习的就是以下四种类型的SQL语言：</p><ul><li>数据查询语言（Data Query Language, DQL）基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。</li><li>数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。</li><li>数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。</li><li>DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。</li></ul><p>我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete）</p><hr><h2 id="数据库定义语言（DDL）"><a href="#数据库定义语言（DDL）" class="headerlink" title="数据库定义语言（DDL）"></a>数据库定义语言（DDL）</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>我们可以通过<code>create database</code>来创建一个数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">create</span> database 数据库名<br></code></pre></td></tr></table></figure><p>为了能够支持中文，我们在创建时可以设定编码格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> 数据库名 <span class="hljs-keyword">DEFAULT</span> CHARSET utf8 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> 数据库名 <span class="hljs-keyword">DEFAULT</span> CHARSET utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci;<br></code></pre></td></tr></table></figure><p>如果我们创建错误了，我们可以将此数据库删除，通过使用<code>drop database</code>来删除一个数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">drop</span> database 数据库名<br></code></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>数据库创建完成后，我们一般通过<code>create table</code>语句来创建一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(列名 数据类型[列级约束条件],<br>             列名 数据类型[列级约束条件],<br>             ...<br>             [,表级约束条件])<br></code></pre></td></tr></table></figure><h3 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h3><p>以下的数据类型用于字符串存储：</p><ul><li>char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。</li><li>varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。</li></ul><p>以下数据类型用于存储数字：</p><ul><li>smallint用于存储小的整数，范围在 (-32768，32767)</li><li>int用于存储一般的整数，范围在 (-2147483648，2147483647)</li><li>bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)</li><li>float用于存储单精度小数</li><li>double用于存储双精度的小数</li></ul><p>以下数据类型用于存储时间：</p><ul><li>date存储日期</li><li>time存储时间</li><li>year存储年份</li><li>datetime用于混合存储日期+时间</li></ul><h3 id="列级约束条件"><a href="#列级约束条件" class="headerlink" title="列级约束条件"></a>列级约束条件</h3><p>列级约束有六种：主键Primary key、外键foreign key 、唯一 unique、检查 check （MySQL不支持）、默认default 、非空/空值 not null/ null</p><h3 id="表级约束条件"><a href="#表级约束条件" class="headerlink" title="表级约束条件"></a>表级约束条件</h3><p>表级约束有四种：主键、外键、唯一、检查</p><p>现在我们通过SQL语句来创建我们之前提到的三张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">[<span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>外键名<span class="hljs-operator">&gt;</span>] <span class="hljs-keyword">FOREIGN</span> KEY 字段名 [，字段名<span class="hljs-number">2</span>，…] <span class="hljs-keyword">REFERENCES</span> <span class="hljs-operator">&lt;</span>主表名<span class="hljs-operator">&gt;</span> 主键列<span class="hljs-number">1</span> [，主键列<span class="hljs-number"><code class="language-hljs sql">[<span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>外键名<span class="hljs-operator">&gt;</span>] <span class="hljs-keyword">FOREIGN</span> KEY 字段名 [，字段名<span class="hljs-number">2</span>，…] <span class="hljs-keyword">REFERENCES</span> <span class="hljs-operator">&lt;</span>主表名<span class="hljs-operator">&gt;</span> 主键列<span class="hljs-number">1</span> [，主键列<span class="hljs-number">2</span>，…]<br></code></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>如果我们想修改表结构，我们可以通过<code>alter table</code>来进行修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名[<span class="hljs-keyword">ADD</span> 新列名 数据类型[列级约束条件]]<br> [<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> 列名[restrict<span class="hljs-operator">|</span>cascade]]<br> [<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名[<span class="hljs-keyword">ADD</span> 新列名 数据类型[列级约束条件]]<br> [<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> 列名[restrict<span class="hljs-operator">|</span>cascade]]<br> [<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> 列名 新数据类型]<br></code></pre></td></tr></table></figure><p>我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。</p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>我们可以通过<code>drop table</code>来删除一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名[restrict<span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名[restrict<span class="hljs-operator">|</span>cascade]<br></code></pre></td></tr></table></figure><p>其中restrict和cascade上面的效果一致。</p><hr><h2 id="数据库操纵语言（DML）"><a href="#数据库操纵语言（DML）" class="headerlink" title="数据库操纵语言（DML）"></a>数据库操纵语言（DML）</h2><p>前面我们已经学习了如何使用SQL语句来创建、修改、删除数据库以及表，而如何向数据库中插入、删除、更新数据，将是本版块讨论的重点。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>通过使用<code>insert into</code>语句来向数据库中插入一条数据（一条记录）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, 值<span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, 值<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>我们也可以一次性向数据库中插入多条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>, 值<span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>我们来试试看向我们刚刚创建的表中添加三条数据。</p><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>我们可以通过<code>update</code>语句来更新表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">UPDATE 表名 <span class="hljs-keyword">SET</span> 列名<span class="hljs-operator">=</span>值,... <span class="hljs-keyword"><code class="language-hljs sql">UPDATE 表名 <span class="hljs-keyword">SET</span> 列名<span class="hljs-operator">=</span>值,... <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></table></figure><p>注意，SQL语句中的等于判断是<code>=</code></p><p><strong>警告：</strong>如果忘记添加<code>WHERE</code>字句来限定条件，将使得整个表中此列的所有数据都被修改！</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>我们可以通过使用<code>delete</code>来删除表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名<br></code></pre></td></tr></table></figure><p>通过这种方式，将删除表中全部数据，我们也可以使用<code>where</code>来添加条件，只删除指定的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></table></figure><hr><h2 id="数据库查询语言（DQL）"><a href="#数据库查询语言（DQL）" class="headerlink" title="数据库查询语言（DQL）"></a>数据库查询语言（DQL）</h2><p>数据库的查询是我们整个数据库学习中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。</p><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用<code>select</code>语句来进行单表查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 指定查询某一列数据</span><br><span class="hljs-keyword">SELECT</span> 列名[,列名] <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 会以别名显示此列</span><br><span class="hljs-keyword">SELECT</span> 列名 别名 <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 查询所有的列数据</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 只查询不重复的值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 列名 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 指定查询某一列数据</span><br><span class="hljs-keyword">SELECT</span> 列名[,列名] <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 会以别名显示此列</span><br><span class="hljs-keyword">SELECT</span> 列名 别名 <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 查询所有的列数据</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-comment">-- 只查询不重复的值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 列名 <span class="hljs-keyword">FROM</span> 表名<br></code></pre></td></tr></table></figure><p>我们也可以添加<code>where</code>字句来限定查询目标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></table></figure><h3 id="常用查询条件"><a href="#常用查询条件" class="headerlink" title="常用查询条件"></a>常用查询条件</h3><ul><li>一般的比较运算符，包括=、&gt;、&lt;、&gt;=、&lt;=、!=等。</li><li>是否在集合中：in、not in</li><li>字符模糊匹配：like，not like</li><li>多重条件连接查询：and、or、not</li></ul><p>我们来尝试使用一下上面这几种条件。</p><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>我们可以通过<code>order by</code>来将查询结果进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名 <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名 <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><p>使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。</p><p>我们也可以可以同时添加多个排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名<span class="hljs-number">1</span> <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>, 列名<span class="hljs-number">2</span> <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名<span class="hljs-number">1</span> <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>, 列名<span class="hljs-number">2</span> <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><p>这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。</p><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>聚集函数一般用作统计，包括：</p><ul><li><code>count([distinct]*)</code>统计所有的行数（distinct表示去重再统计，下同）</li><li><code>count([distinct]列名)</code>统计某列的值总和</li><li><code>sum([distinct]列名)</code>求一列的和（注意必须是数字类型的）</li><li><code>avg([distinct]列名)</code>求一列的平均值（注意必须是数字类型）</li><li><code>max([distinct]列名)</code>求一列的最大值</li><li><code>min([distinct]列名)</code>求一列的最小值</li></ul><p>一般聚集函数是这样使用的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> 列名) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> 列名) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <br></code></pre></td></tr></table></figure><h3 id="分组和分页查询"><a href="#分组和分页查询" class="headerlink" title="分组和分页查询"></a>分组和分页查询</h3><p>通过使用<code>group by</code>来对查询结果进行分组，它需要结合聚合函数一起使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列名<br></code></pre></td></tr></table></figure><p>我们还可以添加<code>having</code>来限制分组条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列名 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列名 <span class="hljs-keyword">HAVING</span> 约束条件<br></code></pre></td></tr></table></figure><p>我们可以通过<code>limit</code>来限制查询的数量，只取前n个结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 LIMIT 数量<br></code></pre></td></tr></table></figure><p>我们也可以进行分页：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 LIMIT 起始位置,数量<br></code></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件<br></code></pre></td></tr></table></figure><p>这样，只会从笛卡尔积的结果中得到满足条件的数据。</p><p><strong>注意：</strong>如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。</p><h3 id="自身连接查询"><a href="#自身连接查询" class="headerlink" title="自身连接查询"></a>自身连接查询</h3><p>自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 别名<span class="hljs-number">1</span>, 表名 别名<span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 别名<span class="hljs-number">1</span>, 表名 别名<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。</p><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：</p><ul><li>通过使用<code>inner join</code>进行内连接，只会返回两个表满足条件的交集部分：</li></ul><p><img src="https://img-blog.csdnimg.cn/2019053022120536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg1ODIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>通过使用<code>left join</code>进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用<code>null</code>来代替（右连接<code>right join</code>同理，只是反过来而已，这里就不再介绍了）：</li></ul><p><img src="https://img-blog.csdnimg.cn/20190530221543230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg1ODIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>我们可以将查询的结果作为另一个查询的条件，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 列名 <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> 列名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 列名 <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> 列名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件)<br></code></pre></td></tr></table></figure><p>我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。</p><hr><h2 id="数据库控制语言（DCL）"><a href="#数据库控制语言（DCL）" class="headerlink" title="数据库控制语言（DCL）"></a>数据库控制语言（DCL）</h2><p>庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>我们可以通过<code>create user</code>来创建用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名 identified <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名 identified <span class="hljs-keyword">by</span> 密码;<br></code></pre></td></tr></table></figure><p>也可以不带密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名;<br></code></pre></td></tr></table></figure><p>我们可以通过@来限制用户登录的登录IP地址，<code>%</code>表示匹配所有的IP地址，默认使用的就是任意IP地址。</p><h3 id="登陆用户"><a href="#登陆用户" class="headerlink" title="登陆用户"></a>登陆用户</h3><p>首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql">login <span class="hljs-operator">-</span>u 用户名 <span class="hljs-operator"><code class="language-hljs sql">login <span class="hljs-operator">-</span>u 用户名 <span class="hljs-operator">-</span>p<br></code></pre></td></tr></table></figure><p>输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><p>我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！</p><h3 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h3><p>我们可以通过使用<code>grant</code>来为一个数据库用户进行授权：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span><span class="hljs-operator">|</span>权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2.</span>..(列<span class="hljs-number">1</span>,...) <span class="hljs-keyword">on</span> 数据库.表 <span class="hljs-keyword">to</span> 用户 [<span class="hljs-keyword">with</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span><span class="hljs-operator">|</span>权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2.</span>..(列<span class="hljs-number">1</span>,...) <span class="hljs-keyword">on</span> 数据库.表 <span class="hljs-keyword">to</span> 用户 [<span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> option]<br></code></pre></td></tr></table></figure><p>其中all代表授予所有权限，当数据库和表为<code>*</code>，代表为所有的数据库和表都授权。如果在最后添加了<code>with grant option</code>，那么被授权的用户还能将已获得的授权继续授权给其他用户。</p><p>我们可以使用<code>revoke</code>来收回一个权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span><span class="hljs-operator">|</span>权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2.</span>..(列<span class="hljs-number">1</span>,...) <span class="hljs-keyword">on</span> 数据库.表 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span><span class="hljs-operator">|</span>权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2.</span>..(列<span class="hljs-number">1</span>,...) <span class="hljs-keyword">on</span> 数据库.表 <span class="hljs-keyword">from</span> 用户<br></code></pre></td></tr></table></figure><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。</p><p>我们可以通过<code>create view</code>来创建视图;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 视图名称(列名) <span class="hljs-keyword">as</span> 子查询语句 [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 视图名称(列名) <span class="hljs-keyword">as</span> 子查询语句 [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure><p>WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用<code>select</code>语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。</p><ol><li>若视图是由两个以上基本表导出的，则此视图不允许更新。</li><li>若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。</li><li>若视图的字段来自集函数，则此视图不允许更新。</li><li>若视图定义中含有GROUP BY子句，则此视图不允许更新。</li><li>若视图定义中含有DISTINCT短语，则此视图不允许更新。</li><li>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG(Grade) FROM SC); 　　导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。</li><li>一个不允许更新的视图上定义的视图也不允许更新</li></ol><p>通过<code>drop</code>来删除一个视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> apptest<br></code></pre></td></tr></table></figure><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">CREATE</span> INDEX 索引名称 <span class="hljs-keyword">ON</span> 表名 (列名)<br><span class="hljs-comment">-- 查看表中的索引</span><br><span class="hljs-keyword">show</span> INDEX <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">CREATE</span> INDEX 索引名称 <span class="hljs-keyword">ON</span> 表名 (列名)<br><span class="hljs-comment">-- 查看表中的索引</span><br><span class="hljs-keyword">show</span> INDEX <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></table></figure><p>我们也可以通过下面的命令删除一个索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">drop</span> index 索引名称 <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">drop</span> index 索引名称 <span class="hljs-keyword">on</span> 表名<br></code></pre></td></tr></table></figure><p>虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。</p><hr><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器就像其名字一样，在某种条件下会自动触发，在<code>select</code>/<code>update</code>/<code>delete</code>时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。</p><p>触发器所依附的表称为基本表，当触发器表上发生<code>select</code>/<code>update</code>/<code>delete</code>等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用）</p><p>比如在<code>insert</code>操作时，新的内容会被插入到new表中；在<code>delete</code>操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在<code>update</code>操作时，旧的内容会被移到old表中，新的内容会出现在new表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> 触发器名称 [BEFORE<span class="hljs-operator">|</span>AFTER] [<span class="hljs-keyword">INSERT</span><span class="hljs-operator">|</span>UPDATE<span class="hljs-operator">|</span><span class="hljs-keyword">DELETE</span>] <span class="hljs-keyword">ON</span> 表名<span class="hljs-operator">/</span>视图名 <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> student.sno <span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> 触发器名称 [BEFORE<span class="hljs-operator">|</span>AFTER] [<span class="hljs-keyword">INSERT</span><span class="hljs-operator">|</span>UPDATE<span class="hljs-operator">|</span><span class="hljs-keyword">DELETE</span>] <span class="hljs-keyword">ON</span> 表名<span class="hljs-operator">/</span>视图名 <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> student.sno <span class="hljs-operator">=</span> new.sno<br></code></pre></td></tr></table></figure><p> FOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！</p><p>通过下面的命令来查看触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SHOW</span> TRIGGERS<br></code></pre></td></tr></table></figure><p>如果不需要，我们就可以删除此触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> 触发器名称<br></code></pre></td></tr></table></figure><hr><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword"><code class="language-hljs sql"><span class="hljs-keyword">SHOW</span> ENGINES;<br></code></pre></td></tr></table></figure><p>MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。</p><p>事务具有以下特性：</p><ul><li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>我们通过以下例子来探究以下事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">begin</span>;   #开始事务<br>...<br><span class="hljs-keyword">rollback</span>;  #回滚事务<br><span class="hljs-keyword">savepoint</span> 回滚点;  #添加回滚点<br><span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> 回滚点; #回滚到指定回滚点<br>...<br><span class="hljs-keyword">commit</span>; #提交事务<br><span class="hljs-comment"><code class="language-hljs sql"><span class="hljs-keyword">begin</span>;   #开始事务<br>...<br><span class="hljs-keyword">rollback</span>;  #回滚事务<br><span class="hljs-keyword">savepoint</span> 回滚点;  #添加回滚点<br><span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> 回滚点; #回滚到指定回滚点<br>...<br><span class="hljs-keyword">commit</span>; #提交事务<br><span class="hljs-comment">-- 一旦提交，就无法再进行回滚了！</span><br></code></pre></td></tr></table></figure><hr><h2 id="选学内容"><a href="#选学内容" class="headerlink" title="选学内容"></a>选学内容</h2><p><strong>函数</strong>和<strong>存储过程</strong>并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组SQL语句运行，并且可以反复使用，大大提高工作效率。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/16/0.html/"/>
      <url>/2022/03/16/0.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><p>在JavaSE阶段，我们学习了I/O流，既然I/O流如此强大，那么能否跨越不同的主机进行I/O操作呢？这就要提到Java的网络编程了。</p><p><strong>注意：</strong>本章会涉及到<code>计算机网络</code>相关内容（只会讲解大致内容，不会完整的讲解计算机网络知识）</p><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><p>利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。</p><p><img src="https://pics2.baidu.com/feed/503d269759ee3d6d1356774cd59afe244e4ade3c.jpeg?token=f256bfddbd14418f8f3d3d4964ed4cf5" alt="img"></p><p>比如我们家里的路由器，通过将我们的设备（手机、平板、电脑、电视剧）连接到路由器，来实现对互联网的访问。实际上，我们的路由器连接在互联网上，而我们的设备又连接了路由器，这样我们的设备就可以通过路由器访问到互联网了。通过网络，我们可以直接访问互联网上的另一台主机，比如我们要把QQ的消息发送给我们的朋友，或是通过远程桌面管理来操作另一台电脑，也可以是连接本地网络上的打印机。</p><p>既然我们可以通过网络访问其他计算机，那么如何区别不同的计算机呢？通过IP地址，我们就可以区分不同的计算机了：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo5%2Facf4321f34144b69811bdde9bec045c8.jpg&refer=http%3A%2F%2Fimg.it610.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637820816&t=955be58edb486e7a69cdea2381714252" alt="img"></p><p>每一台电脑在同一个网络上都有一个自己的IP地址，用于区别于其他的电脑，我们可以通过对方主机的IP地址对其进行访问。那么我手机连接的移动流量，能访问到连接家里路由器的电脑吗？（不能，因为他们不属于同一个网络）</p><p>而我们的电脑上可能运行着大量的程序，每一个程序可能都需要通过网络来访问其他计算机，那这时该如何区分呢？我们可以通过端口号来区分：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2068098%2F202008%2F2068098-20200808153937940-609503998.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637821431&t=9dfd5db6c6f75f843d1663f54b2ccb6c" alt="img"></p><p>因此，我们一般看到的是这样的：<code>192.168.0.11:8080</code>，通过<code>IP:端口</code>的形式来访问目标主机上的一个应用程序服务。注意端口号只能是0-65535之间的值！</p><p>IP地址分为IPv4和IPv6，IPv4类似于<code>192.168.0.11</code>，我们上面提到的例子都是使用的IPv4，它一共有四组数字，每组数字占8个bit位，IPv4地址<code>0.0.0.0</code>表示为2进制就是：00000000.00000000.00000000.00000000，共32个bit，最大为<code>255.255.255.255</code>，实际上，IPv4能够表示的所有地址，早就已经被用完了。IPv6能够保存128个bit位，因此它也可以表示更多的IP地址，一个IPv6地址看起来像这样：<code>1030::C9B4:FF12:48AA:1A2B</code>，目前也正在向IPv6的阶段过度。</p><p>TCP和UDP是两种不同的传输层协议：</p><ul><li>TCP：当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠（会进行三次握手，断开也会进行四次挥手），这样才能保证正确收发数据，因此TCP更适合一些可靠的数据传输场景。</li><li>UDP：它是一种无连接协议，数据想发就发，而且不会建立可靠传输，也就是说传输过程中有可能会导致部分数据丢失，但是它比TCP传输更加简单高效，适合视频直播之类的。</li></ul><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20200212%2F0f3d7f77442643c099dddbb159a183f6.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637824557&t=b5d5cb0c013ae945e838e88a345edb9c" alt="img"></p><hr><h2 id="了解Socket技术"><a href="#了解Socket技术" class="headerlink" title="了解Socket技术"></a>了解Socket技术</h2><p>通过Socket技术（它是计算机之间进行<strong>通信</strong>的<strong>一种约定</strong>或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为<code>套接字</code>，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。</p><p>要实现Socket通信，我们必须创建一个数据发送者和一个数据接收者，也就是客户端和服务端，我们需要提前启动服务端，来等待客户端的连接，而客户端只需要随时启动去连接服务端即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        Socket socket = server.accept();  <span class="hljs-comment">//当没有客户端连接时，线程会阻塞，直到有客户端连接为止</span><br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        Socket socket = server.accept();  <span class="hljs-comment">//当没有客户端连接时，线程会阻塞，直到有客户端连接为止</span><br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))&#123;<br>        System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))&#123;<br>        System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        System.out.println(<span class="hljs-string">"服务端连接失败！"</span>);<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上它就是一个TCP连接的建立过程：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.reader8.cn%2Fuploadfile%2Fjiaocheng%2F201401101%2F3039%2F2014013015391315977.jpg&refer=http%3A%2F%2Fwww.reader8.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637838562&t=a22f860adb01fda478ecb76f34c34252" alt="img"></p><p>一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;   <span class="hljs-comment">//无限循环等待客户端连接</span><br>            Socket socket = server.accept();<br>            System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        &#125;<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;   <span class="hljs-comment">//无限循环等待客户端连接</span><br>            Socket socket = server.accept();<br>            System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以多次去连接此服务端了。</p><h2 id="使用Socket进行数据传输"><a href="#使用Socket进行数据传输" class="headerlink" title="使用Socket进行数据传输"></a>使用Socket进行数据传输</h2><p>通过Socket对象，我们就可以获取到对应的I/O流进行网络数据传输：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>             Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>            System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>            OutputStream stream = socket.getOutputStream();<br>            OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(stream);  <span class="hljs-comment">//通过转换流来帮助我们快速写入内容</span><br>            System.out.println(<span class="hljs-string">&quot;请输入要发送给服务端的内容：&quot;</span>);<br>            String text = scanner.nextLine();<br>            writer.write(text+<span class="hljs-string">&#x27;\n&#x27;</span>);   <span class="hljs-comment">//因为对方是readLine()这里加个换行符</span><br>            writer.flush();<br>            System.out.println(<span class="hljs-string">&quot;数据已发送：&quot;</span>+text);<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;服务端连接失败！&quot;</span>);<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>             Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>            System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>            OutputStream stream = socket.getOutputStream();<br>            OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(stream);  <span class="hljs-comment">//通过转换流来帮助我们快速写入内容</span><br>            System.out.println(<span class="hljs-string">&quot;请输入要发送给服务端的内容：&quot;</span>);<br>            String text = scanner.nextLine();<br>            writer.write(text+<span class="hljs-string">&#x27;\n&#x27;</span>);   <span class="hljs-comment">//因为对方是readLine()这里加个换行符</span><br>            writer.flush();<br>            System.out.println(<span class="hljs-string">&quot;数据已发送：&quot;</span>+text);<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;服务端连接失败！&quot;</span>);<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">"客户端断开连接！"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        Socket socket = server.accept();<br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="hljs-comment">//通过</span><br>        System.out.print(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>        System.out.println(reader.readLine());<br>      socket.close();   <span class="hljs-comment">//和服务端TCP连接完成之后，记得关闭socket</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        Socket socket = server.accept();<br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="hljs-comment">//通过</span><br>        System.out.print(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>        System.out.println(reader.readLine());<br>      socket.close();   <span class="hljs-comment">//和服务端TCP连接完成之后，记得关闭socket</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，既然服务端可以读取客户端的内容，客户端也可以在发送后等待服务端给予响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>         Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>        System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>        OutputStream stream = socket.getOutputStream();<br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(stream);  <span class="hljs-comment">//通过转换流来帮助我们快速写入内容</span><br>        System.out.println(<span class="hljs-string">&quot;请输入要发送给服务端的内容：&quot;</span>);<br>        String text = scanner.nextLine();<br>        writer.write(text+<span class="hljs-string">&#x27;\n&#x27;</span>);   <span class="hljs-comment">//因为对方是readLine()这里加个换行符</span><br>        writer.flush();<br>        System.out.println(<span class="hljs-string">&quot;数据已发送：&quot;</span>+text);<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>        System.out.println(<span class="hljs-string">&quot;收到服务器返回：&quot;</span>+reader.readLine());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端连接失败！&quot;</span>);<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>         Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123;<br>        System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>        OutputStream stream = socket.getOutputStream();<br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(stream);  <span class="hljs-comment">//通过转换流来帮助我们快速写入内容</span><br>        System.out.println(<span class="hljs-string">&quot;请输入要发送给服务端的内容：&quot;</span>);<br>        String text = scanner.nextLine();<br>        writer.write(text+<span class="hljs-string">&#x27;\n&#x27;</span>);   <span class="hljs-comment">//因为对方是readLine()这里加个换行符</span><br>        writer.flush();<br>        System.out.println(<span class="hljs-string">&quot;数据已发送：&quot;</span>+text);<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));<br>        System.out.println(<span class="hljs-string">&quot;收到服务器返回：&quot;</span>+reader.readLine());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端连接失败！&quot;</span>);<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">"客户端断开连接！"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        Socket socket = server.accept();<br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="hljs-comment">//通过</span><br>        System.out.print(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>        System.out.println(reader.readLine());<br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(socket.getOutputStream());<br>        writer.write(<span class="hljs-string">&quot;已收到！&quot;</span>);<br>        writer.flush();<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        Socket socket = server.accept();<br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="hljs-comment">//通过</span><br>        System.out.print(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>        System.out.println(reader.readLine());<br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(socket.getOutputStream());<br>        writer.write(<span class="hljs-string">&quot;已收到！&quot;</span>);<br>        writer.flush();<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以手动关闭单向的流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">socket.shutdownOutput();  <span class="hljs-comment">//关闭输出方向的流</span><br>socket.shutdownInput();  <span class="hljs-comment"><code class="language-hljs java">socket.shutdownOutput();  <span class="hljs-comment">//关闭输出方向的流</span><br>socket.shutdownInput();  <span class="hljs-comment">//关闭输入方向的流</span><br></code></pre></td></tr></table></figure><p>如果我们不希望服务端等待太长的时间，我们可以通过调用<code>setSoTimeout()</code>方法来设定IO超时时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">socket.setSoTimeout(<span class="hljs-number"><code class="language-hljs java">socket.setSoTimeout(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java">java.net.SocketTimeoutException: Read timed out<br>at java.net.SocketInputStream.socketRead0(Native Method)<br>at java.net.SocketInputStream.socketRead(SocketInputStream.java:<span class="hljs-number">116</span>)<br>at java.net.SocketInputStream.read(SocketInputStream.java:<span class="hljs-number">171</span>)<br>at java.net.SocketInputStream.read(SocketInputStream.java:<span class="hljs-number">141</span>)<br>at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:<span class="hljs-number">284</span>)<br>at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:<span class="hljs-number">326</span>)<br>at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:<span class="hljs-number">178</span>)<br>at java.io.InputStreamReader.read(InputStreamReader.java:<span class="hljs-number">184</span>)<br>at java.io.BufferedReader.fill(BufferedReader.java:<span class="hljs-number">161</span>)<br>at java.io.BufferedReader.readLine(BufferedReader.java:<span class="hljs-number">324</span>)<br>at java.io.BufferedReader.readLine(BufferedReader.java:<span class="hljs-number">389</span>)<br>at com.test.Main.main(Main.java:<span class="hljs-number"><code class="language-hljs java">java.net.SocketTimeoutException: Read timed out<br>at java.net.SocketInputStream.socketRead0(Native Method)<br>at java.net.SocketInputStream.socketRead(SocketInputStream.java:<span class="hljs-number">116</span>)<br>at java.net.SocketInputStream.read(SocketInputStream.java:<span class="hljs-number">171</span>)<br>at java.net.SocketInputStream.read(SocketInputStream.java:<span class="hljs-number">141</span>)<br>at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:<span class="hljs-number">284</span>)<br>at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:<span class="hljs-number">326</span>)<br>at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:<span class="hljs-number">178</span>)<br>at java.io.InputStreamReader.read(InputStreamReader.java:<span class="hljs-number">184</span>)<br>at java.io.BufferedReader.fill(BufferedReader.java:<span class="hljs-number">161</span>)<br>at java.io.BufferedReader.readLine(BufferedReader.java:<span class="hljs-number">324</span>)<br>at java.io.BufferedReader.readLine(BufferedReader.java:<span class="hljs-number">389</span>)<br>at com.test.Main.main(Main.java:<span class="hljs-number">41</span>)<br></code></pre></td></tr></table></figure><p>我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(); <span class="hljs-comment">//调用无参构造不会自动连接</span><br>     Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123; <br>    socket.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>), <span class="hljs-number">1000</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(); <span class="hljs-comment">//调用无参构造不会自动连接</span><br>     Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in))&#123; <br>    socket.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>), <span class="hljs-number">1000</span>);  <span class="hljs-comment">//手动调用connect方法进行连接</span><br></code></pre></td></tr></table></figure><p>如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用<code>setKeepAlive()</code>方法来防止此类情况发生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">socket.setKeepAlive(<span class="hljs-keyword"><code class="language-hljs java">socket.setKeepAlive(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP/IP连接是否有效。</p><p>TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2Fv2-72f5d4bebca1242a163cbd1ebff3cdbc_b.jpg&refer=http%3A%2F%2Fpic1.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637902504&t=2b8dead347f9d2a5bd72e703fc11b987" alt="img"></p><p>此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">socket.setReceiveBufferSize(<span class="hljs-number">25565</span>);   <span class="hljs-comment">//TCP接收缓冲区</span><br>socket.setSendBufferSize(<span class="hljs-number">25565</span>);    <span class="hljs-comment"><code class="language-hljs java">socket.setReceiveBufferSize(<span class="hljs-number">25565</span>);   <span class="hljs-comment">//TCP接收缓冲区</span><br>socket.setSendBufferSize(<span class="hljs-number">25565</span>);    <span class="hljs-comment">//TCP发送缓冲区</span><br></code></pre></td></tr></table></figure><h2 id="使用Socket传输文件"><a href="#使用Socket传输文件" class="headerlink" title="使用Socket传输文件"></a>使用Socket传输文件</h2><p>既然Socket为我们提供了IO流便于数据传输，那么我们就可以轻松地实现文件传输了。</p><h2 id="使用浏览器访问Socket服务器"><a href="#使用浏览器访问Socket服务器" class="headerlink" title="使用浏览器访问Socket服务器"></a>使用浏览器访问Socket服务器</h2><p>在了解了如何使用Socket传输文件后，我们来看看，浏览器是如何向服务器发起请求的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>            System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>            Socket socket = server.accept();<br>            System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>            InputStream in = socket.getInputStream();  <span class="hljs-comment">//通过</span><br>            System.out.println(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                <span class="hljs-keyword">int</span> i = in.read();<br>                <span class="hljs-keyword">if</span>(i == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>                System.out.print((<span class="hljs-keyword">char</span>) i);<br>            &#125;<br>        &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>            System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>            Socket socket = server.accept();<br>            System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>            InputStream in = socket.getInputStream();  <span class="hljs-comment">//通过</span><br>            System.out.println(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                <span class="hljs-keyword">int</span> i = in.read();<br>                <span class="hljs-keyword">if</span>(i == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>                System.out.print((<span class="hljs-keyword">char</span>) i);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们现在打开浏览器，输入<a href="http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。">http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。</a></p><p>我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-attr">GET</span> <span class="hljs-string">/ HTTP/1.1</span><br><span class="hljs-attr">Host</span>: <span class="hljs-string">127.0.0.1:8080</span><br><span class="hljs-attr">Connection</span>: <span class="hljs-string">keep-alive</span><br><span class="hljs-meta">Cache-Control</span>: <span class="hljs-string">max-age=0</span><br><span class="hljs-meta">sec-ch-ua</span>: <span class="hljs-string">&quot;Chromium&quot;;v=&quot;94&quot;, &quot;Google Chrome&quot;;v=&quot;94&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot;</span><br><span class="hljs-meta">sec-ch-ua-mobile</span>: <span class="hljs-string">?0</span><br><span class="hljs-meta">sec-ch-ua-platform</span>: <span class="hljs-string">&quot;macOS&quot;</span><br><span class="hljs-meta">Upgrade-Insecure-Requests</span>: <span class="hljs-string">1</span><br><span class="hljs-meta">User-Agent</span>: <span class="hljs-string">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36</span><br><span class="hljs-attr">Accept</span>: <span class="hljs-string">text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="hljs-meta">Sec-Fetch-Site</span>: <span class="hljs-string">none</span><br><span class="hljs-meta">Sec-Fetch-Mode</span>: <span class="hljs-string">navigate</span><br><span class="hljs-meta">Sec-Fetch-User</span>: <span class="hljs-string">?1</span><br><span class="hljs-meta">Sec-Fetch-Dest</span>: <span class="hljs-string">document</span><br><span class="hljs-meta">Accept-Encoding</span>: <span class="hljs-string">gzip, deflate, br</span><br><span class="hljs-meta">Accept-Language</span>: <span class="hljs-string"><code class="language-hljs properties"><span class="hljs-attr">GET</span> <span class="hljs-string">/ HTTP/1.1</span><br><span class="hljs-attr">Host</span>: <span class="hljs-string">127.0.0.1:8080</span><br><span class="hljs-attr">Connection</span>: <span class="hljs-string">keep-alive</span><br><span class="hljs-meta">Cache-Control</span>: <span class="hljs-string">max-age=0</span><br><span class="hljs-meta">sec-ch-ua</span>: <span class="hljs-string">&quot;Chromium&quot;;v=&quot;94&quot;, &quot;Google Chrome&quot;;v=&quot;94&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot;</span><br><span class="hljs-meta">sec-ch-ua-mobile</span>: <span class="hljs-string">?0</span><br><span class="hljs-meta">sec-ch-ua-platform</span>: <span class="hljs-string">&quot;macOS&quot;</span><br><span class="hljs-meta">Upgrade-Insecure-Requests</span>: <span class="hljs-string">1</span><br><span class="hljs-meta">User-Agent</span>: <span class="hljs-string">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36</span><br><span class="hljs-attr">Accept</span>: <span class="hljs-string">text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="hljs-meta">Sec-Fetch-Site</span>: <span class="hljs-string">none</span><br><span class="hljs-meta">Sec-Fetch-Mode</span>: <span class="hljs-string">navigate</span><br><span class="hljs-meta">Sec-Fetch-User</span>: <span class="hljs-string">?1</span><br><span class="hljs-meta">Sec-Fetch-Dest</span>: <span class="hljs-string">document</span><br><span class="hljs-meta">Accept-Encoding</span>: <span class="hljs-string">gzip, deflate, br</span><br><span class="hljs-meta">Accept-Language</span>: <span class="hljs-string">zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7</span><br></code></pre></td></tr></table></figure><p>实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。</p><p>既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs properties"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-string"><code class="language-hljs properties"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-string">200 Accpeted</span><br></code></pre></td></tr></table></figure><p>然后就是响应内容（注意一定要换行再写），我们尝试来编写一下支持HTTP协议的响应内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        Socket socket = server.accept();<br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="hljs-comment">//通过</span><br>        System.out.println(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>        <span class="hljs-keyword">while</span> (reader.ready()) System.out.println(reader.readLine());   <span class="hljs-comment">//ready是判断当前流中是否还有可读内容</span><br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(socket.getOutputStream());<br>        writer.write(<span class="hljs-string">&quot;HTTP/1.1 200 Accepted\r\n&quot;</span>);   <span class="hljs-comment">//200是响应码，Http协议规定200为接受请求，400为错误的请求，404为找不到此资源（不止这些，还有很多）</span><br>        writer.write(<span class="hljs-string">&quot;\r\n&quot;</span>);   <span class="hljs-comment">//在请求头写完之后还要进行一次换行，然后写入我们的响应实体（会在浏览器上展示的内容）</span><br>        writer.write(<span class="hljs-string">&quot;lbwnb!&quot;</span>);<br>        writer.flush();<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        Socket socket = server.accept();<br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="hljs-comment">//通过</span><br>        System.out.println(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>        <span class="hljs-keyword">while</span> (reader.ready()) System.out.println(reader.readLine());   <span class="hljs-comment">//ready是判断当前流中是否还有可读内容</span><br>        OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(socket.getOutputStream());<br>        writer.write(<span class="hljs-string">&quot;HTTP/1.1 200 Accepted\r\n&quot;</span>);   <span class="hljs-comment">//200是响应码，Http协议规定200为接受请求，400为错误的请求，404为找不到此资源（不止这些，还有很多）</span><br>        writer.write(<span class="hljs-string">&quot;\r\n&quot;</span>);   <span class="hljs-comment">//在请求头写完之后还要进行一次换行，然后写入我们的响应实体（会在浏览器上展示的内容）</span><br>        writer.write(<span class="hljs-string">&quot;lbwnb!&quot;</span>);<br>        writer.flush();<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以打开浏览器的开发者模式（这里推荐使用Chrome/Edge浏览器，按下F12即可打开），我们来观察一下浏览器的实际请求过程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/23/1.html/"/>
      <url>/2022/02/23/1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h1><p><strong>注意：</strong>这块会涉及到<strong>操作系统</strong>和<strong>计算机组成原理</strong>相关内容。</p><p>I/O简而言之，就是输入输出，那么为什么会有I/O呢？其实I/O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。</p><p>我们可以大致看一下整个计算机的总线结构：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1896043%2F202005%2F1896043-20200507143508957-1866569205.jpg&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637387700&t=e6a5ade66f8e4af2ac64d12e6dd77dec" alt="img"></p><p>常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。</p><p>而我们在程序中，想要读取这些外部连接的I/O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows/Linux/MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。</p><p>JDK提供了一套用于IO操作的框架，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成。而这类IO就是我们所说的BIO，</p><p>字节流一次读取一个字节，也就是一个<code>byte</code>的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个<code>char</code>的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。</p><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>要学习和使用IO，首先就要从最易于理解的读取文件开始说起。</p><h3 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h3><p>首先介绍一下FileInputStream，通过它来获取文件的输入流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;路径&quot;</span>);<br>        <span class="hljs-comment">//路径支持相对路径和绝对路径</span><br>    &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;路径&quot;</span>);<br>        <span class="hljs-comment">//路径支持相对路径和绝对路径</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相对路径是在当前运行的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用<code>/</code>或是<code>\\</code>，但是不能写为<code>\</code>因为它是转义字符！</p><p>在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    FileInputStream inputStream = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//定义可以先放在try外部</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;路径&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//建议在finally中进行，因为这个是任何情况都必须要执行的！</span><br>            <span class="hljs-keyword">if</span>(inputStream != <span class="hljs-keyword">null</span>) inputStream.close();<br>        &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    FileInputStream inputStream = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//定义可以先放在try外部</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;路径&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//建议在finally中进行，因为这个是任何情况都必须要执行的！</span><br>            <span class="hljs-keyword">if</span>(inputStream != <span class="hljs-keyword">null</span>) inputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    <span class="hljs-comment">//注意，这种语法只支持实现了AutoCloseable接口的类！</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;路径&quot;</span>)) &#123;   <span class="hljs-comment">//直接在try()中定义要在完成之后释放的资源</span><br><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;   <span class="hljs-comment">//这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的</span><br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    <span class="hljs-comment">//注意，这种语法只支持实现了AutoCloseable接口的类！</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;路径&quot;</span>)) &#123;   <span class="hljs-comment">//直接在try()中定义要在完成之后释放的资源</span><br><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;   <span class="hljs-comment">//这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的</span><br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">//无需再编写finally语句块，因为在最后自动帮我们调用了close()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后为了方便，我们都使用此语法进行教学。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//test.txt：a</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-comment">//使用read()方法进行字符读取</span><br>        System.out.println((<span class="hljs-keyword">char</span>) inputStream.read());  <span class="hljs-comment">//读取一个字节的数据（英文字母只占1字节，中文占2字节）</span><br>        System.out.println(inputStream.read());   <span class="hljs-comment">//唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//test.txt：a</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-comment">//使用read()方法进行字符读取</span><br>        System.out.println((<span class="hljs-keyword">char</span>) inputStream.read());  <span class="hljs-comment">//读取一个字节的数据（英文字母只占1字节，中文占2字节）</span><br>        System.out.println(inputStream.read());   <span class="hljs-comment">//唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个！我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-keyword">int</span> tmp;<br>        <span class="hljs-keyword">while</span> ((tmp = inputStream.read()) != -<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//通过while循环来一次性读完内容</span><br>            System.out.println((<span class="hljs-keyword">char</span>)tmp);<br>        &#125;<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-keyword">int</span> tmp;<br>        <span class="hljs-keyword">while</span> ((tmp = inputStream.read()) != -<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//通过while循环来一次性读完内容</span><br>            System.out.println((<span class="hljs-keyword">char</span>)tmp);<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性读取的数量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>    System.out.println(inputStream.available());  <span class="hljs-comment">//查看剩余数量</span><br>&#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>    System.out.println(inputStream.available());  <span class="hljs-comment">//查看剩余数量</span><br>&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inputStream.available()];   <span class="hljs-comment">//我们可以提前准备好合适容量的byte数组来存放</span><br>        System.out.println(inputStream.read(bytes));   <span class="hljs-comment">//一次性读取全部内容（返回值是读取的字节数）</span><br>        System.out.println(<span class="hljs-keyword">new</span> String(bytes));   <span class="hljs-comment">//通过String(byte[])构造方法得到字符串</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inputStream.available()];   <span class="hljs-comment">//我们可以提前准备好合适容量的byte数组来存放</span><br>        System.out.println(inputStream.read(bytes));   <span class="hljs-comment">//一次性读取全部内容（返回值是读取的字节数）</span><br>        System.out.println(<span class="hljs-keyword">new</span> String(bytes));   <span class="hljs-comment">//通过String(byte[])构造方法得到字符串</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以控制要读取数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">System.out.println(inputStream.read(bytes, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));   <span class="hljs-comment"><code class="language-hljs java">System.out.println(inputStream.read(bytes, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));   <span class="hljs-comment">//第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1</p><p>通过<code>skip()</code>方法可以跳过指定数量的字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        System.out.println(inputStream.skip(<span class="hljs-number">1</span>));<br>        System.out.println((<span class="hljs-keyword">char</span>) inputStream.read());   <span class="hljs-comment">//跳过了一个字节</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        System.out.println(inputStream.skip(<span class="hljs-number">1</span>));<br>        System.out.println((<span class="hljs-keyword">char</span>) inputStream.read());   <span class="hljs-comment">//跳过了一个字节</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：FileInputStream是不支持<code>reset()</code>的，虽然有这个方法，但是这里先不提及。</p><p>既然有输入流，那么文件输出流也是必不可少的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//输出流也需要在最后调用close()方法，并且同样支持try-with-resource</span><br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>        <span class="hljs-comment">//注意：若此文件不存在，会直接创建这个文件！</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//输出流也需要在最后调用close()方法，并且同样支持try-with-resource</span><br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>        <span class="hljs-comment">//注意：若此文件不存在，会直接创建这个文件！</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出流没有<code>read()</code>操作而是<code>write()</code>操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>        outputStream.write(<span class="hljs-string">&#x27;c&#x27;</span>);   <span class="hljs-comment">//同read一样，可以直接写入内容</span><br>      outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes());   <span class="hljs-comment">//也可以直接写入byte[]</span><br>      outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes(), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">//同上输入流</span><br>      outputStream.flush();  <span class="hljs-comment">//建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>        outputStream.write(<span class="hljs-string">&#x27;c&#x27;</span>);   <span class="hljs-comment">//同read一样，可以直接写入内容</span><br>      outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes());   <span class="hljs-comment">//也可以直接写入byte[]</span><br>      outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes(), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">//同上输入流</span><br>      outputStream.flush();  <span class="hljs-comment">//建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-keyword">true</span>)) &#123;<br>        outputStream.write(<span class="hljs-string">&quot;lb&quot;</span>.getBytes());   <span class="hljs-comment">//现在只会进行追加写入，而不是直接替换原文件内容</span><br>        outputStream.flush();<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-keyword">true</span>)) &#123;<br>        outputStream.write(<span class="hljs-string">&quot;lb&quot;</span>.getBytes());   <span class="hljs-comment">//现在只会进行追加写入，而不是直接替换原文件内容</span><br>        outputStream.flush();<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用输入流和输出流，就可以轻松实现文件的拷贝了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>);<br>        FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;   <span class="hljs-comment">//可以写入多个</span><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>];    <span class="hljs-comment">//使用长度为10的byte[]做传输媒介</span><br>        <span class="hljs-keyword">int</span> tmp;   <span class="hljs-comment">//存储本地读取字节数</span><br>        <span class="hljs-keyword">while</span> ((tmp = inputStream.read(bytes)) != -<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//直到读取完成为止</span><br>            outputStream.write(bytes, <span class="hljs-number">0</span>, tmp);    <span class="hljs-comment">//写入对应长度的数据到输出流</span><br>        &#125;<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>);<br>        FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;   <span class="hljs-comment">//可以写入多个</span><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>];    <span class="hljs-comment">//使用长度为10的byte[]做传输媒介</span><br>        <span class="hljs-keyword">int</span> tmp;   <span class="hljs-comment">//存储本地读取字节数</span><br>        <span class="hljs-keyword">while</span> ((tmp = inputStream.read(bytes)) != -<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//直到读取完成为止</span><br>            outputStream.write(bytes, <span class="hljs-number">0</span>, tmp);    <span class="hljs-comment">//写入对应长度的数据到输出流</span><br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h3><p>字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileReader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br>      reader.skip(<span class="hljs-number">1</span>);   <span class="hljs-comment">//现在跳过的是一个字符</span><br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());   <span class="hljs-comment">//现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileReader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br>      reader.skip(<span class="hljs-number">1</span>);   <span class="hljs-comment">//现在跳过的是一个字符</span><br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());   <span class="hljs-comment">//现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，字符流只支持<code>char[]</code>类型作为存储：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileReader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br>        <span class="hljs-keyword">char</span>[] str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">10</span>];<br>        reader.read(str);<br>        System.out.println(str);   <span class="hljs-comment">//直接读取到char[]中</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileReader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br>        <span class="hljs-keyword">char</span>[] str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">10</span>];<br>        reader.read(str);<br>        System.out.println(str);   <span class="hljs-comment">//直接读取到char[]中</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然有了Reader肯定也有Writer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileWriter writer = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;output.txt&quot;</span>))&#123;<br>      writer.getEncoding();   <span class="hljs-comment">//支持获取编码（不同的文本文件可能会有不同的编码类型）</span><br>       writer.write(<span class="hljs-string">&#x27;牛&#x27;</span>);<br>       writer.append(<span class="hljs-string">&#x27;牛&#x27;</span>);   <span class="hljs-comment">//其实功能和write一样</span><br>      writer.flush();   <span class="hljs-comment">//刷新</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(FileWriter writer = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;output.txt&quot;</span>))&#123;<br>      writer.getEncoding();   <span class="hljs-comment">//支持获取编码（不同的文本文件可能会有不同的编码类型）</span><br>       writer.write(<span class="hljs-string">&#x27;牛&#x27;</span>);<br>       writer.append(<span class="hljs-string">&#x27;牛&#x27;</span>);   <span class="hljs-comment">//其实功能和write一样</span><br>      writer.flush();   <span class="hljs-comment">//刷新</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现不仅有<code>write()</code>方法，还有一个<code>append()</code>方法，但是实际上他们效果是一样的，看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Appends the specified character to this writer.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt;</span><br><span class="hljs-comment"> * behaves in exactly the same way as the invocation</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;pre&gt;</span><br><span class="hljs-comment"> *     out.write(c) &lt;/pre&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  c</span><br><span class="hljs-comment"> *         The 16-bit character to append</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  This writer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  IOException</span><br><span class="hljs-comment"> *          If an I/O error occurs</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Writer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    write(c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Appends the specified character to this writer.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt;</span><br><span class="hljs-comment"> * behaves in exactly the same way as the invocation</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;pre&gt;</span><br><span class="hljs-comment"> *     out.write(c) &lt;/pre&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  c</span><br><span class="hljs-comment"> *         The 16-bit character to append</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  This writer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  IOException</span><br><span class="hljs-comment"> *          If an I/O error occurs</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Writer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    write(c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。</p><p><strong>练习</strong>：尝试一下用Reader和Writer来拷贝纯文本文件</p><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>File类专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);   <span class="hljs-comment">//直接创建文件对象，可以是相对路径，也可以是绝对路径</span><br>    System.out.println(file.exists());   <span class="hljs-comment">//此文件是否存在</span><br>    System.out.println(file.length());   <span class="hljs-comment">//获取文件的大小</span><br>    System.out.println(file.isDirectory());   <span class="hljs-comment">//是否为一个文件夹</span><br>    System.out.println(file.canRead());   <span class="hljs-comment">//是否可读</span><br>    System.out.println(file.canWrite());   <span class="hljs-comment">//是否可写</span><br>    System.out.println(file.canExecute());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);   <span class="hljs-comment">//直接创建文件对象，可以是相对路径，也可以是绝对路径</span><br>    System.out.println(file.exists());   <span class="hljs-comment">//此文件是否存在</span><br>    System.out.println(file.length());   <span class="hljs-comment">//获取文件的大小</span><br>    System.out.println(file.isDirectory());   <span class="hljs-comment">//是否为一个文件夹</span><br>    System.out.println(file.canRead());   <span class="hljs-comment">//是否可读</span><br>    System.out.println(file.canWrite());   <span class="hljs-comment">//是否可写</span><br>    System.out.println(file.canExecute());   <span class="hljs-comment">//是否可执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/&quot;</span>);<br>System.out.println(Arrays.toString(file.list()));   <span class="hljs-comment">//快速获取文件夹下的文件名称列表</span><br><span class="hljs-keyword">for</span> (File f : file.listFiles())&#123;   <span class="hljs-comment">//所有子文件的File对象</span><br>    System.out.println(f.getAbsolutePath());   <span class="hljs-comment"><code class="language-hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/&quot;</span>);<br>System.out.println(Arrays.toString(file.list()));   <span class="hljs-comment">//快速获取文件夹下的文件名称列表</span><br><span class="hljs-keyword">for</span> (File f : file.listFiles())&#123;   <span class="hljs-comment">//所有子文件的File对象</span><br>    System.out.println(f.getAbsolutePath());   <span class="hljs-comment">//获取文件的绝对路径</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-keyword">try</span> (FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(file))&#123;   <span class="hljs-comment">//直接做参数</span><br>    System.out.println(inputStream.available());<br>&#125;<span class="hljs-keyword"><code class="language-hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-keyword">try</span> (FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(file))&#123;   <span class="hljs-comment">//直接做参数</span><br>    System.out.println(inputStream.available());<br>&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习</strong>：尝试拷贝文件夹下的所有文件到另一个文件夹</p><hr><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.wityx.com%2Fimage%2F201908%2F480873DBD936EBA9518F721ACDC22BFE.png&refer=http%3A%2F%2Fwww.wityx.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637457276&t=b4f7d52f08d9d5815baca0b21a01f925" alt="img"></p><h3 id="缓冲字节流"><a href="#缓冲字节流" class="headerlink" title="缓冲字节流"></a>缓冲字节流</h3><p>要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;   <span class="hljs-comment">//传入FileInputStream</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());   <span class="hljs-comment">//操作和原来的流是一样的</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;   <span class="hljs-comment">//传入FileInputStream</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());   <span class="hljs-comment">//操作和原来的流是一样的</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为<code>装饰者模式</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">byte</span>[] buffer;<br>    <span class="hljs-keyword">while</span> ( (buffer = buf) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (bufUpdater.compareAndSet(<span class="hljs-keyword">this</span>, buffer, <span class="hljs-keyword">null</span>)) &#123;  <span class="hljs-comment">//CAS无锁算法，并发会用到，暂时不管</span><br>            InputStream input = in;<br>            in = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (input != <span class="hljs-keyword">null</span>)<br>                input.close();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">byte</span>[] buffer;<br>    <span class="hljs-keyword">while</span> ( (buffer = buf) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (bufUpdater.compareAndSet(<span class="hljs-keyword">this</span>, buffer, <span class="hljs-keyword">null</span>)) &#123;  <span class="hljs-comment">//CAS无锁算法，并发会用到，暂时不管</span><br>            InputStream input = in;<br>            in = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (input != <span class="hljs-keyword">null</span>)<br>                input.close();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Else retry in case a new buf was CASed in fill()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。</p><p>我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The internal buffer array where the data is stored. When necessary,</span><br><span class="hljs-comment"> * it may be replaced by another array of</span><br><span class="hljs-comment"> * a different size.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The internal buffer array where the data is stored. When necessary,</span><br><span class="hljs-comment"> * it may be replaced by another array of</span><br><span class="hljs-comment"> * a different size.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">byte</span> buf[];<br></code></pre></td></tr></table></figure><p>I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持<code>reset()</code>和<code>mark()</code>操作，首先我们来看看<code>mark()</code>方法的介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Marks the current position in this input stream. A subsequent</span><br><span class="hljs-comment"> * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at</span><br><span class="hljs-comment"> * the last marked position so that subsequent reads re-read the same bytes.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to</span><br><span class="hljs-comment"> * allow that many bytes to be read before the mark position gets</span><br><span class="hljs-comment"> * invalidated.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   readlimit   the maximum limit of bytes that can be read before</span><br><span class="hljs-comment"> *                      the mark position becomes invalid.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     java.io.FilterInputStream#in</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     java.io.FilterInputStream#reset()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mark</span><span class="hljs-params">(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Marks the current position in this input stream. A subsequent</span><br><span class="hljs-comment"> * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at</span><br><span class="hljs-comment"> * the last marked position so that subsequent reads re-read the same bytes.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to</span><br><span class="hljs-comment"> * allow that many bytes to be read before the mark position gets</span><br><span class="hljs-comment"> * invalidated.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   readlimit   the maximum limit of bytes that can be read before</span><br><span class="hljs-comment"> *                      the mark position becomes invalid.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     java.io.FilterInputStream#in</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     java.io.FilterInputStream#reset()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> readlimit)</span> </span>&#123;<br>    in.mark(readlimit);<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用<code>mark()</code>之后，输入流会以某种方式保留之后读取的<code>readlimit</code>数量的内容，当读取的内容数量超过<code>readlimit</code>则之后的内容不会被保留，当调用<code>reset()</code>之后，会使得当前的读取位置回到<code>mark()</code>调用时的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        bufferedInputStream.mark(<span class="hljs-number">1</span>);   <span class="hljs-comment">//只保留之后的1个字符</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        bufferedInputStream.reset();   <span class="hljs-comment">//回到mark时的位置</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        bufferedInputStream.mark(<span class="hljs-number">1</span>);   <span class="hljs-comment">//只保留之后的1个字符</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        bufferedInputStream.reset();   <span class="hljs-comment">//回到mark时的位置</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实<code>mark()</code>后保存的读取内容是取<code>readlimit</code>和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由<code>readlimit</code>确定。因此我们限制一下缓冲区大小，再来观察一下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-number">1</span>))&#123;  <span class="hljs-comment">//将缓冲区大小设置为1</span><br>        bufferedInputStream.mark(<span class="hljs-number">1</span>);   <span class="hljs-comment">//只保留之后的1个字符</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());   <span class="hljs-comment">//已经超过了readlimit，继续读取会导致mark失效</span><br>        bufferedInputStream.reset();   <span class="hljs-comment">//mark已经失效，无法reset()</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-number">1</span>))&#123;  <span class="hljs-comment">//将缓冲区大小设置为1</span><br>        bufferedInputStream.mark(<span class="hljs-number">1</span>);   <span class="hljs-comment">//只保留之后的1个字符</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());   <span class="hljs-comment">//已经超过了readlimit，继续读取会导致mark失效</span><br>        bufferedInputStream.reset();   <span class="hljs-comment">//mark已经失效，无法reset()</span><br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-keyword">char</span>) bufferedInputStream.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedOutputStream outputStream = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes());<br>        outputStream.flush();<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedOutputStream outputStream = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes());<br>        outputStream.flush();<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>操作和FileOutputStream一致，这里就不多做介绍了。</p><h3 id="缓冲字符流"><a href="#缓冲字符流" class="headerlink" title="缓冲字符流"></a>缓冲字符流</h3><p>缓存字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用和reader也是一样的，内部也包含一个缓存数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> cb[];<br></code></pre></td></tr></table></figure><p>相比Reader更方便的是，它支持按行读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println(reader.readLine());   <span class="hljs-comment">//按行读取</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println(reader.readLine());   <span class="hljs-comment">//按行读取</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        reader<br>                .lines()<br>                .limit(<span class="hljs-number">2</span>)<br>                .distinct()<br>                .sorted()<br>                .forEach(System.out::println);<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        reader<br>                .lines()<br>                .limit(<span class="hljs-number">2</span>)<br>                .distinct()<br>                .sorted()<br>                .forEach(System.out::println);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它同样也支持<code>mark()</code>和<code>reset()</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        reader.mark(<span class="hljs-number">1</span>);<br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>        reader.reset();<br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        reader.mark(<span class="hljs-number">1</span>);<br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>        reader.reset();<br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedWriter reader = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        reader.newLine();   <span class="hljs-comment">//使用newLine进行换行</span><br>        reader.write(<span class="hljs-string">&quot;汉堡做滴彳亍不彳亍&quot;</span>);   <span class="hljs-comment">//可以直接写入一个字符串</span><br>      reader.flush();   <span class="hljs-comment">//清空缓冲区</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (BufferedWriter reader = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        reader.newLine();   <span class="hljs-comment">//使用newLine进行换行</span><br>        reader.write(<span class="hljs-string">&quot;汉堡做滴彳亍不彳亍&quot;</span>);   <span class="hljs-comment">//可以直接写入一个字符串</span><br>      reader.flush();   <span class="hljs-comment">//清空缓冲区</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;  <span class="hljs-comment">//虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入</span><br>        writer.write(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//以操作Writer的样子写入OutputStream</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(OutputStreamWriter writer = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;  <span class="hljs-comment">//虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入</span><br>        writer.write(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//以操作Writer的样子写入OutputStream</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(InputStreamReader reader = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;  <span class="hljs-comment">//虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取</span><br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(InputStreamReader reader = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;  <span class="hljs-comment">//虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取</span><br>        System.out.println((<span class="hljs-keyword">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。</p><hr><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>打印流其实我们从一开始就在使用了，比如<code>System.out</code>就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用<code>flush()</code>方法。PrintStream也永远不会抛出异常，而是使用内部检查机制<code>checkError()</code>方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> PrintStream out = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> PrintStream out = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>可以看到<code>System.out</code>也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(PrintStream stream = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        stream.println(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//其实System.out就是一个PrintStream</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>(PrintStream stream = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        stream.println(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//其实System.out就是一个PrintStream</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们平时使用的<code>println</code>方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的<code>toString()</code>方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。</p><p><img src="https://img-blog.csdn.net/20180906143936647?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbGkxMzg5Nzc0MTU1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>因此实际上内部还包含这两个内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Track both the text- and character-output streams, so that their buffers</span><br><span class="hljs-comment"> * can be flushed without flushing the entire stream.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> BufferedWriter textOut;<br><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Track both the text- and character-output streams, so that their buffers</span><br><span class="hljs-comment"> * can be flushed without flushing the entire stream.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> BufferedWriter textOut;<br><span class="hljs-keyword">private</span> OutputStreamWriter charOut;<br></code></pre></td></tr></table></figure><p>与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。</p><hr><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (DataInputStream dataInputStream = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println(dataInputStream.readBoolean());   <span class="hljs-comment">//直接将数据读取为任意基本数据类型</span><br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (DataInputStream dataInputStream = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println(dataInputStream.readBoolean());   <span class="hljs-comment">//直接将数据读取为任意基本数据类型</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用于写入基本数据类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (DataOutputStream dataOutputStream = <span class="hljs-keyword">new</span> DataOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        dataOutputStream.writeBoolean(<span class="hljs-keyword">false</span>);<br>    &#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (DataOutputStream dataOutputStream = <span class="hljs-keyword">new</span> DataOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        dataOutputStream.writeBoolean(<span class="hljs-keyword">false</span>);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。</p><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>));<br>         ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        People people = <span class="hljs-keyword">new</span> People(<span class="hljs-string">&quot;lbw&quot;</span>);<br>        outputStream.writeObject(people);<br>      outputStream.flush();<br>        people = (People) inputStream.readObject();<br>        System.out.println(people.name);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;   <span class="hljs-comment">//必须实现Serializable接口才能被序列化</span><br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>));<br>         ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        People people = <span class="hljs-keyword">new</span> People(<span class="hljs-string">&quot;lbw&quot;</span>);<br>        outputStream.writeObject(people);<br>      outputStream.flush();<br>        people = (People) inputStream.readObject();<br>        System.out.println(people.name);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;   <span class="hljs-comment">//必须实现Serializable接口才能被序列化</span><br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">123456</span>;   <span class="hljs-comment">//在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。</span><br><br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">123456</span>;   <span class="hljs-comment">//在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。</span><br><br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当发生版本不匹配时，会无法反序列化为对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java">java.io.InvalidClassException: com.test.Main$People; local <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">incompatible</span>: <span class="hljs-title">stream</span> <span class="hljs-title">classdesc</span> <span class="hljs-title">serialVersionUID</span> </span>= <span class="hljs-number">123456</span>, local <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">serialVersionUID</span> </span>= <span class="hljs-number">1234567</span><br>at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="hljs-number">699</span>)<br>at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="hljs-number">2003</span>)<br>at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="hljs-number">1850</span>)<br>at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="hljs-number">2160</span>)<br>at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="hljs-number">1667</span>)<br>at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number">503</span>)<br>at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number">461</span>)<br>at com.test.Main.main(Main.java:<span class="hljs-number"><code class="language-hljs java">java.io.InvalidClassException: com.test.Main$People; local <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">incompatible</span>: <span class="hljs-title">stream</span> <span class="hljs-title">classdesc</span> <span class="hljs-title">serialVersionUID</span> </span>= <span class="hljs-number">123456</span>, local <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">serialVersionUID</span> </span>= <span class="hljs-number">1234567</span><br>at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="hljs-number">699</span>)<br>at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="hljs-number">2003</span>)<br>at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="hljs-number">1850</span>)<br>at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="hljs-number">2160</span>)<br>at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="hljs-number">1667</span>)<br>at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number">503</span>)<br>at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number">461</span>)<br>at com.test.Main.main(Main.java:<span class="hljs-number">27</span>)<br></code></pre></td></tr></table></figure><p>如果我们不希望某些属性参与到序列化中进行保存，我们可以添加<code>transient</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>));<br>         ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        People people = <span class="hljs-keyword">new</span> People(<span class="hljs-string">&quot;lbw&quot;</span>);<br>        outputStream.writeObject(people);<br>        outputStream.flush();<br>        people = (People) inputStream.readObject();<br>        System.out.println(people.name);  <span class="hljs-comment">//虽然能得到对象，但是name属性并没有保存，因此为null</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1234567</span>;<br><br>    <span class="hljs-keyword">transient</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;output.txt&quot;</span>));<br>         ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        People people = <span class="hljs-keyword">new</span> People(<span class="hljs-string">&quot;lbw&quot;</span>);<br>        outputStream.writeObject(people);<br>        outputStream.flush();<br>        people = (People) inputStream.readObject();<br>        System.out.println(people.name);  <span class="hljs-comment">//虽然能得到对象，但是name属性并没有保存，因此为null</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1234567</span>;<br><br>    <span class="hljs-keyword">transient</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。</p><hr><h2 id="Java-I-O编程实战"><a href="#Java-I-O编程实战" class="headerlink" title="Java I/O编程实战"></a>Java I/O编程实战</h2><h3 id="图书管理系统"><a href="#图书管理系统" class="headerlink" title="图书管理系统"></a>图书管理系统</h3><p>要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/23/0.html/"/>
      <url>/2022/02/23/0.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Java反射和注解"><a href="#Java反射和注解" class="headerlink" title="Java反射和注解"></a>Java反射和注解</h1><p><strong>注意：</strong>本章节涉及到JVM相关底层原理，难度会有一些大。</p><p>反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。</p><p>简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！</p><h2 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h2><p>在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg3.itboth.com%2F60%2F50%2FUrUVN3.png&refer=http%3A%2F%2Fimg3.itboth.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637635409&t=f25ea82c853619c26897ff5b4d041d5b" alt="img"></p><p>在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！</p><p><strong>思考：</strong>既然说和与加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，那么JVM会加载这个类吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span>&#123;    <span class="hljs-comment">//JDK提供的String类也是</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span>&#123;    <span class="hljs-comment">//JDK提供的String类也是</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"我姓🐴，我叫🐴nb"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，会出现以下报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br></code></pre></td></tr></table></figure><p>但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的<code>双亲委派机制</code>在保护Java程序的正常运行：</p><p><img src="https://img-blog.csdnimg.cn/20201217213314510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70" alt="img"></p><p>实际上我们的类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到<code>main</code>方法了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Main.class.getClassLoader());   <span class="hljs-comment">//查看当前类的类加载器</span><br>        System.out.println(Main.class.getClassLoader().getParent());  <span class="hljs-comment">//父加载器</span><br>        System.out.println(Main.class.getClassLoader().getParent().getParent());  <span class="hljs-comment">//爷爷加载器</span><br>        System.out.println(String.class.getClassLoader());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Main.class.getClassLoader());   <span class="hljs-comment">//查看当前类的类加载器</span><br>        System.out.println(Main.class.getClassLoader().getParent());  <span class="hljs-comment">//父加载器</span><br>        System.out.println(Main.class.getClassLoader().getParent().getParent());  <span class="hljs-comment">//爷爷加载器</span><br>        System.out.println(String.class.getClassLoader());   <span class="hljs-comment">//String类的加载器</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。</p><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    Class&lt;String&gt; clazz = String.class;   <span class="hljs-comment">//使用class关键字，通过类名获取</span><br>    Class&lt;?&gt; clazz2 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);   <span class="hljs-comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span><br>    Class&lt;?&gt; clazz3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;cpdd&quot;</span>).getClass();  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>    Class&lt;String&gt; clazz = String.class;   <span class="hljs-comment">//使用class关键字，通过类名获取</span><br>    Class&lt;?&gt; clazz2 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);   <span class="hljs-comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span><br>    Class&lt;?&gt; clazz3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;cpdd&quot;</span>).getClass();  <span class="hljs-comment">//通过实例对象获取</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了<code>?</code>通配符作为返回值，但是实际上都和第一个返回的是同一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java">Class&lt;String&gt; clazz = String.class;   <span class="hljs-comment">//使用class关键字，通过类名获取</span><br>Class&lt;?&gt; clazz2 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);   <span class="hljs-comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span><br>Class&lt;?&gt; clazz3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string"><code class="language-hljs java">Class&lt;String&gt; clazz = String.class;   <span class="hljs-comment">//使用class关键字，通过类名获取</span><br>Class&lt;?&gt; clazz2 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);   <span class="hljs-comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span><br>Class&lt;?&gt; clazz3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"cpdd"</span>).getClass();<br><br>System.out.println(clazz == clazz2);<br>System.out.println(clazz == clazz3);<br></code></pre></td></tr></table></figure><p>通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Class&lt;?&gt; clazz = <span class="hljs-keyword">int</span>.class;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Class&lt;?&gt; clazz = <span class="hljs-keyword">int</span>.class;   <span class="hljs-comment">//基本数据类型有Class对象吗？</span><br>    System.out.println(clazz);<br>&#125;<br></code></pre></td></tr></table></figure><p>迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The &#123;<span class="hljs-doctag">@code</span> Class&#125; instance representing the primitive type</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> int&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   JDK1.1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="hljs-string">&quot;int&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Return the Virtual Machine&#x27;s Class object for the named</span><br><span class="hljs-comment"> * primitive type</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getPrimitiveClass(String name);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The &#123;<span class="hljs-doctag">@code</span> Class&#125; instance representing the primitive type</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> int&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   JDK1.1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="hljs-string">&quot;int&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Return the Virtual Machine&#x27;s Class object for the named</span><br><span class="hljs-comment"> * primitive type</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getPrimitiveClass(String name);   <span class="hljs-comment">//C++实现，并非Java定义</span><br></code></pre></td></tr></table></figure><p>每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Class&lt;?&gt; clazz = <span class="hljs-keyword">int</span>.class;<br>    System.out.println(Integer.TYPE == <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Class&lt;?&gt; clazz = <span class="hljs-keyword">int</span>.class;<br>    System.out.println(Integer.TYPE == <span class="hljs-keyword">int</span>.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println(Integer.TYPE == Integer.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Class&lt;String[]&gt; clazz = String[].class;<br>    System.out.println(clazz.getName());  <span class="hljs-comment">//获取类名称（得到的是包名+类名的完整名称）</span><br>    System.out.println(clazz.getSimpleName());<br>    System.out.println(clazz.getTypeName());<br>    System.out.println(clazz.getClassLoader());   <span class="hljs-comment">//获取它的类加载器</span><br>    System.out.println(clazz.cast(<span class="hljs-keyword">new</span> Integer(<span class="hljs-string">&quot;10&quot;</span>)));   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Class&lt;String[]&gt; clazz = String[].class;<br>    System.out.println(clazz.getName());  <span class="hljs-comment">//获取类名称（得到的是包名+类名的完整名称）</span><br>    System.out.println(clazz.getSimpleName());<br>    System.out.println(clazz.getTypeName());<br>    System.out.println(clazz.getClassLoader());   <span class="hljs-comment">//获取它的类加载器</span><br>    System.out.println(clazz.cast(<span class="hljs-keyword">new</span> Integer(<span class="hljs-string">&quot;10&quot;</span>)));   <span class="hljs-comment">//强制类型转换</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="再谈instanceof"><a href="#再谈instanceof" class="headerlink" title="再谈instanceof"></a>再谈instanceof</h3><p>正常情况下，我们使用instanceof进行类型比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-string">&quot;&quot;</span>;<br>    System.out.println(str <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-string">&quot;&quot;</span>;<br>    System.out.println(str <span class="hljs-keyword">instanceof</span> String);<br>&#125;<br></code></pre></td></tr></table></figure><p>它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-string">&quot;&quot;</span>;<br>    System.out.println(str.getClass() == String.class);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-string">&quot;&quot;</span>;<br>    System.out.println(str.getClass() == String.class);   <span class="hljs-comment">//直接判断是否为这个类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要判断是否为子类或是接口/抽象类的实现，我们可以使用<code>asSubClass()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = <span class="hljs-number">10</span>;<br>    i.getClass().asSubclass(Number.class);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = <span class="hljs-number">10</span>;<br>    i.getClass().asSubclass(Number.class);   <span class="hljs-comment">//当Integer不是Number的子类时，会产生异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取父类信息"><a href="#获取父类信息" class="headerlink" title="获取父类信息"></a>获取父类信息</h3><p>通过<code>getSuperclass()</code>方法，我们可以获取到父类的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = <span class="hljs-number">10</span>;<br>    System.out.println(i.getClass().getSuperclass());<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以通过<code>getGenericSuperclass()</code>获取父类的原始类型的Type：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = <span class="hljs-number">10</span>;<br>    Type type = i.getClass().getGenericSuperclass();<br>    System.out.println(type);<br>    System.out.println(type <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = <span class="hljs-number">10</span>;<br>    Type type = i.getClass().getGenericSuperclass();<br>    System.out.println(type);<br>    System.out.println(type <span class="hljs-keyword">instanceof</span> Class);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。</p><p>同理，我们也可以像上面这样获取父接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; anInterface : i.getClass().getInterfaces()) &#123;<br>        System.out.println(anInterface.getName());<br>    &#125;<br>  <br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; anInterface : i.getClass().getInterfaces()) &#123;<br>        System.out.println(anInterface.getName());<br>    &#125;<br>  <br>  <span class="hljs-keyword">for</span> (Type genericInterface : i.getClass().getGenericInterfaces()) &#123;<br>        System.out.println(genericInterface.getTypeName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="创建类对象"><a href="#创建类对象" class="headerlink" title="创建类对象"></a>创建类对象</h2><p>既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.newInstance();<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.newInstance();<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用<code>newInstance()</code>方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.newInstance();<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String text)</span></span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.newInstance();<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String text)</span></span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为<code>newInstance()</code>只适用于默认无参构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.newInstance();<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.newInstance();<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当默认无参构造的权限不是<code>public</code>时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用<code>newInstance()</code>方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.getConstructor(String.class).newInstance(<span class="hljs-string">&quot;what&#x27;s up&quot;</span>);<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String str)</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.getConstructor(String.class).newInstance(<span class="hljs-string">&quot;what&#x27;s up&quot;</span>);<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String str)</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用<code>getConstructor()</code>方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.getConstructor(String.class).newInstance(<span class="hljs-string">&quot;what&#x27;s up&quot;</span>);<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Student</span><span class="hljs-params">(String str)</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    Student student = clazz.getConstructor(String.class).newInstance(<span class="hljs-string">&quot;what&#x27;s up&quot;</span>);<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Student</span><span class="hljs-params">(String str)</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">Class&lt;Student&gt; clazz = Student.class;<br>Constructor&lt;Student&gt; constructor = clazz.getDeclaredConstructor(String.class);<br>constructor.setAccessible(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//修改访问权限</span><br>Student student = constructor.newInstance(<span class="hljs-string"><code class="language-hljs java">Class&lt;Student&gt; clazz = Student.class;<br>Constructor&lt;Student&gt; constructor = clazz.getDeclaredConstructor(String.class);<br>constructor.setAccessible(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//修改访问权限</span><br>Student student = constructor.newInstance(<span class="hljs-string">"what&#x27;s up"</span>);<br>student.test();<br></code></pre></td></tr></table></figure><p>使用<code>getDeclaredConstructor()</code>方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容）</p><hr><h2 id="调用类的方法"><a href="#调用类的方法" class="headerlink" title="调用类的方法"></a>调用类的方法</h2><p>我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"萨日朗"</span>+str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次我们通过<code>forName(String)</code>来找到这个类并创建一个新的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    Object instance = clazz.newInstance();   <span class="hljs-comment">//创建出学生对象</span><br>    Method method = clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    <br>    method.invoke(instance, <span class="hljs-string">&quot;what&#x27;s up&quot;</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    Object instance = clazz.newInstance();   <span class="hljs-comment">//创建出学生对象</span><br>    Method method = clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    <br>    method.invoke(instance, <span class="hljs-string">&quot;what&#x27;s up&quot;</span>);   <span class="hljs-comment">//通过Method对象的invoke方法来调用方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过调用<code>getMethod()</code>方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的<code>invoke()</code>方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。</p><p>我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。</p><p>同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将<code>test()</code>方法的权限修饰符改为private：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    Object instance = clazz.newInstance();   <span class="hljs-comment">//创建出学生对象</span><br>    Method method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    method.setAccessible(<span class="hljs-keyword">true</span>);<br><br>    method.invoke(instance, <span class="hljs-string">&quot;what&#x27;s up&quot;</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    Object instance = clazz.newInstance();   <span class="hljs-comment">//创建出学生对象</span><br>    Method method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    method.setAccessible(<span class="hljs-keyword">true</span>);<br><br>    method.invoke(instance, <span class="hljs-string">&quot;what&#x27;s up&quot;</span>);   <span class="hljs-comment">//通过Method对象的invoke方法来调用方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    Method method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    <br>    System.out.println(method.getName());   <span class="hljs-comment">//获取方法名称</span><br>    System.out.println(method.getReturnType());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    Method method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    <br>    System.out.println(method.getName());   <span class="hljs-comment">//获取方法名称</span><br>    System.out.println(method.getReturnType());   <span class="hljs-comment">//获取返回值类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">Method method = clazz.getDeclaredMethod(<span class="hljs-string"><code class="language-hljs java">Method method = clazz.getDeclaredMethod(<span class="hljs-string">"test"</span>, String[].class);<br></code></pre></td></tr></table></figure><p>反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。</p><hr><h2 id="修改类的属性"><a href="#修改类的属性" class="headerlink" title="修改类的属性"></a>修改类的属性</h2><p>我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过<code>getField()</code>方法来获取一个类定义的指定字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    Object instance = clazz.newInstance();<br><br>    Field field = clazz.getField(<span class="hljs-string">&quot;i&quot;</span>);   <span class="hljs-comment">//获取类的成员字段i</span><br>    field.set(instance, <span class="hljs-number">100</span>);   <span class="hljs-comment">//将类实例instance的成员字段i设置为100</span><br><br>    Method method = clazz.getMethod(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    Object instance = clazz.newInstance();<br><br>    Field field = clazz.getField(<span class="hljs-string">&quot;i&quot;</span>);   <span class="hljs-comment">//获取类的成员字段i</span><br>    field.set(instance, <span class="hljs-number">100</span>);   <span class="hljs-comment">//将类实例instance的成员字段i设置为100</span><br><br>    Method method = clazz.getMethod(<span class="hljs-string">"test"</span>);<br>    method.invoke(instance);<br>&#125;<br></code></pre></td></tr></table></figure><p>在得到Field之后，我们就可以直接通过<code>set()</code>方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    Object instance = clazz.newInstance();<br><br>    Field field = clazz.getDeclaredField(<span class="hljs-string">&quot;i&quot;</span>);   <span class="hljs-comment">//获取类的成员字段i</span><br>    field.setAccessible(<span class="hljs-keyword">true</span>);<br>    field.set(instance, <span class="hljs-number">100</span>);   <span class="hljs-comment">//将类实例instance的成员字段i设置为100</span><br><br>    Method method = clazz.getMethod(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    Object instance = clazz.newInstance();<br><br>    Field field = clazz.getDeclaredField(<span class="hljs-string">&quot;i&quot;</span>);   <span class="hljs-comment">//获取类的成员字段i</span><br>    field.setAccessible(<span class="hljs-keyword">true</span>);<br>    field.set(instance, <span class="hljs-number">100</span>);   <span class="hljs-comment">//将类实例instance的成员字段i设置为100</span><br><br>    Method method = clazz.getMethod(<span class="hljs-string">"test"</span>);<br>    method.invoke(instance);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段<code>i</code>前面添加<code>final</code>关键字，我们再来看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Integer i = <span class="hljs-number">10</span>;<br><br>    Field field = Integer.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br><br>    Field modifiersField = Field.class.getDeclaredField(<span class="hljs-string">&quot;modifiers&quot;</span>);  <span class="hljs-comment">//这里要获取Field类的modifiers字段进行修改</span><br>    modifiersField.setAccessible(<span class="hljs-keyword">true</span>);<br>    modifiersField.setInt(field,field.getModifiers()&amp;~Modifier.FINAL);  <span class="hljs-comment">//去除final标记</span><br><br>    field.setAccessible(<span class="hljs-keyword">true</span>);<br>    field.set(i, <span class="hljs-number">100</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    Integer i = <span class="hljs-number">10</span>;<br><br>    Field field = Integer.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br><br>    Field modifiersField = Field.class.getDeclaredField(<span class="hljs-string">&quot;modifiers&quot;</span>);  <span class="hljs-comment">//这里要获取Field类的modifiers字段进行修改</span><br>    modifiersField.setAccessible(<span class="hljs-keyword">true</span>);<br>    modifiersField.setInt(field,field.getModifiers()&amp;~Modifier.FINAL);  <span class="hljs-comment">//去除final标记</span><br><br>    field.setAccessible(<span class="hljs-keyword">true</span>);<br>    field.set(i, <span class="hljs-number">100</span>);   <span class="hljs-comment">//强行设置值</span><br><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    List&lt;String&gt; i = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    Field field = ArrayList.class.getDeclaredField(<span class="hljs-string">&quot;size&quot;</span>);<br>    field.setAccessible(<span class="hljs-keyword">true</span>);<br>    field.set(i, <span class="hljs-number">10</span>);<br><br>    i.add(<span class="hljs-string">&quot;测试&quot;</span>);   <span class="hljs-comment">//只添加一个元素</span><br>    System.out.println(i.size());  <span class="hljs-comment">//大小直接变成11</span><br>    i.remove(<span class="hljs-number">10</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException </span>&#123;<br>    List&lt;String&gt; i = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    Field field = ArrayList.class.getDeclaredField(<span class="hljs-string">&quot;size&quot;</span>);<br>    field.setAccessible(<span class="hljs-keyword">true</span>);<br>    field.set(i, <span class="hljs-number">10</span>);<br><br>    i.add(<span class="hljs-string">&quot;测试&quot;</span>);   <span class="hljs-comment">//只添加一个元素</span><br>    System.out.println(i.size());  <span class="hljs-comment">//大小直接变成11</span><br>    i.remove(<span class="hljs-number">10</span>);   <span class="hljs-comment">//瞎移除都不带报错的，淦</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！</p><p>再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！</p><hr><h2 id="自定义ClassLoader加载类"><a href="#自定义ClassLoader加载类" class="headerlink" title="自定义ClassLoader加载类"></a>自定义ClassLoader加载类</h2><p>我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String text;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>&#123;<br>        System.out.println(text+<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String text;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>&#123;<br>        System.out.println(text+<span class="hljs-string">" > 我是测试方法！"</span>+str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过javac命令，手动编译一个.class文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">nagocoler@NagodeMacBook-Pro HelloWorld % javac src/main/java/com/test/Test.java<br></code></pre></td></tr></table></figure><p>编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自己的来让它支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//定义一个自己的ClassLoader</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>&#123;<br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-keyword">byte</span>[] b)&#123;<br>        <span class="hljs-keyword">return</span> defineClass(name, b, <span class="hljs-number">0</span>, b.length);   <span class="hljs-comment">//调用protected方法，支持载入外部class文件</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    MyClassLoader classLoader = <span class="hljs-keyword">new</span> MyClassLoader();<br>    FileInputStream stream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;Test.class&quot;</span>);<br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[stream.available()];<br>    stream.read(bytes);<br>    Class&lt;?&gt; clazz = classLoader.defineClass(<span class="hljs-string">&quot;com.test.Test&quot;</span>, bytes);   <span class="hljs-comment">//类名必须和我们定义的保持一致</span><br>    System.out.println(clazz.getName());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//定义一个自己的ClassLoader</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>&#123;<br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-keyword">byte</span>[] b)&#123;<br>        <span class="hljs-keyword">return</span> defineClass(name, b, <span class="hljs-number">0</span>, b.length);   <span class="hljs-comment">//调用protected方法，支持载入外部class文件</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    MyClassLoader classLoader = <span class="hljs-keyword">new</span> MyClassLoader();<br>    FileInputStream stream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;Test.class&quot;</span>);<br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[stream.available()];<br>    stream.read(bytes);<br>    Class&lt;?&gt; clazz = classLoader.defineClass(<span class="hljs-string">&quot;com.test.Test&quot;</span>, bytes);   <span class="hljs-comment">//类名必须和我们定义的保持一致</span><br>    System.out.println(clazz.getName());   <span class="hljs-comment">//成功加载外部class文件</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Object obj = clazz.newInstance();<br>    Method method = clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//获取我们定义的test(String str)方法</span><br>    method.invoke(obj, <span class="hljs-string">&quot;哥们这瓜多少钱一斤？&quot;</span>);<br>&#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Object obj = clazz.newInstance();<br>    Method method = clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//获取我们定义的test(String str)方法</span><br>    method.invoke(obj, <span class="hljs-string">&quot;哥们这瓜多少钱一斤？&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来试试看修改成员字段之后，再来调用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Object obj = clazz.newInstance();<br>    Field field = clazz.getField(<span class="hljs-string">&quot;text&quot;</span>);   <span class="hljs-comment">//获取成员变量 String text;</span><br>    field.set(obj, <span class="hljs-string">&quot;华强&quot;</span>);<br>    Method method = clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//获取我们定义的test(String str)方法</span><br>    method.invoke(obj, <span class="hljs-string">&quot;哥们这瓜多少钱一斤？&quot;</span>);<br>&#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Object obj = clazz.newInstance();<br>    Field field = clazz.getField(<span class="hljs-string">&quot;text&quot;</span>);   <span class="hljs-comment">//获取成员变量 String text;</span><br>    field.set(obj, <span class="hljs-string">&quot;华强&quot;</span>);<br>    Method method = clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//获取我们定义的test(String str)方法</span><br>    method.invoke(obj, <span class="hljs-string">&quot;哥们这瓜多少钱一斤？&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。</p><hr><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>其实我们在之前就接触到注解了，比如<code>@Override</code>表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。</p><p>注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。</p><h3 id="预设注解"><a href="#预设注解" class="headerlink" title="预设注解"></a>预设注解</h3><p>JDK预设了以下注解，作用于代码：</p><ul><li>@Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时）</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是作用于注解上的注解，用于我们编写自定义的注解：</p><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><p>看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看<code>@Override</code>是如何定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>该注解由<code>@Target</code>限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。<code>@Retention</code>表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个<code>@Retention</code>和1-n个<code>@Target</code>。</p><p>既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，一个最简单的注解就被我们创建了。</p><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><p>我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <span class="hljs-function">String <span class="hljs-title">test</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <span class="hljs-function">String <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-meta">@Test(test = &quot;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-meta">@Test(test = &quot;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以使用default关键字来为这些属性指定默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "都看到这里了，给个三连吧！"</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    String[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Test(&quot;关注点了吗&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@Test(&quot;关注点了吗&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-meta">@Test(&#123;&quot;value1&quot;, &quot;value2&quot;&#125;)</span>   <span class="hljs-comment">//多个值时就使用花括号括起来</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-meta">@Test(&#123;&quot;value1&quot;, &quot;value2&quot;&#125;)</span>   <span class="hljs-comment">//多个值时就使用花括号括起来</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射获取注解"><a href="#反射获取注解" class="headerlink" title="反射获取注解"></a>反射获取注解</h3><p>既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-keyword">for</span> (Annotation annotation : clazz.getAnnotations()) &#123;<br>        System.out.println(annotation.annotationType());   <span class="hljs-comment">//获取类型</span><br>        System.out.println(annotation <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//直接判断是否为Test</span><br>        Test test = (Test) annotation;<br>        System.out.println(test.value());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-keyword">for</span> (Annotation annotation : clazz.getAnnotations()) &#123;<br>        System.out.println(annotation.annotationType());   <span class="hljs-comment">//获取类型</span><br>        System.out.println(annotation <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//直接判断是否为Test</span><br>        Test test = (Test) annotation;<br>        System.out.println(test.value());   <span class="hljs-comment">//获取我们在注解中写入的内容</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-keyword">for</span> (Annotation annotation : clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>).getAnnotations()) &#123;<br>        System.out.println(annotation.annotationType());   <span class="hljs-comment">//获取类型</span><br>        System.out.println(annotation <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//直接判断是否为Test</span><br>        Test test = (Test) annotation;<br>        System.out.println(test.value());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-keyword">for</span> (Annotation annotation : clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>).getAnnotations()) &#123;<br>        System.out.println(annotation.annotationType());   <span class="hljs-comment">//获取类型</span><br>        System.out.println(annotation <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//直接判断是否为Test</span><br>        Test test = (Test) annotation;<br>        System.out.println(test.value());   <span class="hljs-comment">//获取我们在注解中写入的内容</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论是方法、类、还是字段，都可以使用<code>getAnnotations()</code>方法（还有几个同名的）来快速获取我们标记的注解。</p><p>所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段你们还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，就能感受到注解带来的魅力了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/23/2.html/"/>
      <url>/2022/02/23/2.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><p><strong>注意：</strong>本章节会涉及到 <strong>操作系统</strong> 相关知识。</p><p>在了解多线程之前，让我们回顾一下<code>操作系统</code>中提到的进程概念：</p><p><img src="https://img0.baidu.com/it/u=2613039280,4140201323&fm=26&fmt=auto" alt="img"></p><p>进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过<code>时间片轮转调度</code>算法，来实现多个进程的同时运行。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhiphotos.baidu.com%2Fdoc%2Fpic%2Fitem%2Faec379310a55b3193e6caaf24aa98226cefc179b.jpg&refer=http%3A%2F%2Fhiphotos.baidu.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637499744&t=1df3c2095bc9a8cbe8cd9d0974644b7c" alt="img"></p><p>在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs2.51cto.com%2Fwyfs02%2FM00%2F84%2F3A%2FwKiom1eIqY7il2J7AAAyvcssSjs721.gif&refer=http%3A%2F%2Fs2.51cto.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637474421&t=aef9a39ea3a09d6d67e8d4b769036446" alt="img"></p><p>后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。</p><p>在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行<code>main()</code>方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法<strong>同时</strong>在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadMXBean bean = ManagementFactory.getThreadMXBean();<br>    <span class="hljs-keyword">long</span>[] ids = bean.getAllThreadIds();<br>    ThreadInfo[] infos = bean.getThreadInfo(ids);<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadMXBean bean = ManagementFactory.getThreadMXBean();<br>    <span class="hljs-keyword">long</span>[] ids = bean.getAllThreadIds();<br>    ThreadInfo[] infos = bean.getThreadInfo(ids);<br>    <span class="hljs-keyword">for</span> (ThreadInfo info : infos) &#123;<br>        System.out.println(info.getThreadName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。</p><hr><h2 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h2><p>通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="hljs-comment">     * to create a thread, starting the thread causes the object&#x27;s</span><br><span class="hljs-comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="hljs-comment">     * thread.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="hljs-comment">     * take any action whatsoever.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>     java.lang.Thread#run()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="hljs-comment">     * to create a thread, starting the thread causes the object&#x27;s</span><br><span class="hljs-comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="hljs-comment">     * thread.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="hljs-comment">     * take any action whatsoever.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>     java.lang.Thread#run()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建好后，通过调用<code>start()</code>方法来运行此线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-comment">//直接编写逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;我是另一个线程！&quot;</span>);<br>    &#125;);<br>    t.start();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-comment">//直接编写逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;我是另一个线程！&quot;</span>);<br>    &#125;);<br>    t.start();   <span class="hljs-comment">//调用此方法来开始执行此线程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程：&quot;</span>+Thread.currentThread().getName());<br>        System.out.println(<span class="hljs-string">&quot;我正在计算 0-10000 之间所有数的和...&quot;</span>);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10000</span>; i++) &#123;<br>            sum += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;结果：&quot;</span>+sum);<br>    &#125;);<br>    t.start();<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程：&quot;</span>+Thread.currentThread().getName());<br>        System.out.println(<span class="hljs-string">&quot;我正在计算 0-10000 之间所有数的和...&quot;</span>);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10000</span>; i++) &#123;<br>            sum += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;结果：&quot;</span>+sum);<br>    &#125;);<br>    t.start();<br>    System.out.println(<span class="hljs-string">"我是主线程！"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是一号线程：&quot;</span>+i);<br>        &#125;<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是一号线程：&quot;</span>+i);<br>        &#125;<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">"我是二号线程："</span>+i);<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！</p><p><strong>注意</strong>：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.liuhaihua.cn%2Fwp-content%2Fuploads%2F2019%2F09%2F3AfuQrV.png&refer=http%3A%2F%2Fwww.liuhaihua.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637477978&t=d986b270854b3d7c54f816f9103084bc" alt="img"></p><p>实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用<code>sleep()</code>方法来让当前线程休眠一段时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;l&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);    <span class="hljs-comment">//休眠时间，以毫秒为单位，1000ms = 1s</span><br>    System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;l&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);    <span class="hljs-comment">//休眠时间，以毫秒为单位，1000ms = 1s</span><br>    System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">"nb!"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以使用<code>stop()</code>方法来强行终止此线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        Thread me = Thread.currentThread();   <span class="hljs-comment">//获取当前线程对象</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;打印:&quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">20</span>) me.stop();  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        Thread me = Thread.currentThread();   <span class="hljs-comment">//获取当前线程对象</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;打印:&quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">20</span>) me.stop();  <span class="hljs-comment">//此方法会直接终止此线程</span><br>        &#125;<br>    &#125;);<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然<code>stop()</code>方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。</p><p><strong>思考</strong>：猜猜以下程序输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。</p><hr><h2 id="线程的休眠和中断"><a href="#线程的休眠和中断" class="headerlink" title="线程的休眠和中断"></a>线程的休眠和中断</h2><p>我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况：</p><ul><li>当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。</li><li>当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用<code>wait()</code>方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。</li><li>当线程出现异常或错误 / 被<code>stop()</code> 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。</li></ul><p>而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;l&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);   <span class="hljs-comment">//sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个）</span><br>            System.out.println(<span class="hljs-string">&quot;b&quot;</span>);    <span class="hljs-comment">//调用sleep后，线程会直接进入到等待状态，直到时间结束</span><br>        &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;l&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);   <span class="hljs-comment">//sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个）</span><br>            System.out.println(<span class="hljs-string">&quot;b&quot;</span>);    <span class="hljs-comment">//调用sleep后，线程会直接进入到等待状态，直到时间结束</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过调用<code>sleep()</code>方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);  <span class="hljs-comment">//休眠10秒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);  <span class="hljs-comment">//休眠10秒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，每一个Thread对象中，都有一个<code>interrupt()</code>方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的<code>stop()</code>方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;   <span class="hljs-comment">//无限循环</span><br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="hljs-comment">//判断是否存在中断标志</span><br>                <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//响应中断</span><br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程被中断了！&quot;</span>);<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;   <span class="hljs-comment">//无限循环</span><br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="hljs-comment">//判断是否存在中断标志</span><br>                <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//响应中断</span><br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程被中断了！&quot;</span>);<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>isInterrupted()</code>可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="hljs-comment">//判断是否存在中断标志</span><br>                System.out.println(<span class="hljs-string">&quot;发现中断信号，复位，继续运行...&quot;</span>);<br>                Thread.interrupted();  <span class="hljs-comment">//复位中断标记（返回值是当前是否有中断标记，这里不用管）</span><br>            &#125;<br>        &#125;<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="hljs-comment">//判断是否存在中断标志</span><br>                System.out.println(<span class="hljs-string">&quot;发现中断信号，复位，继续运行...&quot;</span>);<br>                Thread.interrupted();  <span class="hljs-comment">//复位中断标记（返回值是当前是否有中断标记，这里不用管）</span><br>            &#125;<br>        &#125;<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>        Thread.currentThread().suspend();   <span class="hljs-comment">//暂停此线程</span><br>        System.out.println(<span class="hljs-string">&quot;线程继续运行！&quot;</span>);<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.resume();   <span class="hljs-comment">//恢复此线程</span><br>    &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>        Thread.currentThread().suspend();   <span class="hljs-comment">//暂停此线程</span><br>        System.out.println(<span class="hljs-string">&quot;线程继续运行！&quot;</span>);<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.resume();   <span class="hljs-comment">//恢复此线程</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。</p><hr><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：</p><ul><li>MIN_PRIORITY   最低优先级</li><li>MAX_PRIORITY   最高优先级</li><li>NOM_PRIORITY  常规优先级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>    &#125;);<br>    t.start();<br>    t.setPriority(Thread.MIN_PRIORITY);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>    &#125;);<br>    t.start();<br>    t.setPriority(Thread.MIN_PRIORITY);  <span class="hljs-comment">//通过使用setPriority方法来设定优先级</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！</p><h2 id="线程的礼让和加入"><a href="#线程的礼让和加入" class="headerlink" title="线程的礼让和加入"></a>线程的礼让和加入</h2><p>我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用<code>yield()</code>方法来将当前资源让位给其他同优先级线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程1开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;让位！&quot;</span>);<br>                Thread.yield();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;1打印：&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1结束！&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程2开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程1开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;让位！&quot;</span>);<br>                Thread.yield();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;1打印：&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1结束！&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程2开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">"2打印："</span>+i);<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。</p><p>当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用<code>join()</code>方法来实现线程的加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程1开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;1打印：&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1结束！&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程2开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;2打印：&quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程1加入到此线程！&quot;</span>);<br>                    t1.join();    <span class="hljs-comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span><br>                &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程1开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;1打印：&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1结束！&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程2开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;2打印：&quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程1加入到此线程！&quot;</span>);<br>                    t1.join();    <span class="hljs-comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;打印：&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1结束！&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程2开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;2打印：&quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程1加入到此线程！&quot;</span>);<br>                    t1.join();    <span class="hljs-comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span><br>                &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;打印：&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1结束！&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程2开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;2打印：&quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程1加入到此线程！&quot;</span>);<br>                    t1.join();    <span class="hljs-comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。</p><hr><h2 id="线程锁和线程同步"><a href="#线程锁和线程同步" class="headerlink" title="线程锁和线程同步"></a>线程锁和线程同步</h2><p>在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fvlambda.com%2Fimg%3Furl%3Dhttps%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_png%2F2LlmEpiamhyq7hTfsoWa1GMIQlOtRuD8SScvIeB3KD7w4OoGu8wx13lBjMJLhYgYqTHND48X05m901TIEicGg49w%2F640%3Fwx_fmt%3Dpng&refer=http%3A%2F%2Fvlambda.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637562962&t=830ccc4dbe09f2699660bfcc9a292c63" alt="img"></p><p>线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在<code>计算机组成原理</code>中学习的多处理器高速缓存机制：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBb1fa2c9cd0784fb19f0d8ebeb8e00976?method=download&shareKey=8d48a5816e60b026adfa21e6735b5e31" alt="img"></p><p>高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。</p><p>实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！</p><h3 id="悬念破案"><a href="#悬念破案" class="headerlink" title="悬念破案"></a>悬念破案</h3><p>我们再来回顾一下之前留给大家的悬念：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F3154ff892af3cb3373a3b6b82b501a1d.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100&refer=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637565388&t=20091d33bae457edc36af7718ef1325b" alt="img"></p><p>那么要去解决这样的问题，我们就必须采取某种同步机制，来限制不同线程对于共享变量的访问！我们希望的是保证共享变量value自增操作的原子性（原子性是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，包括其他线程，要么就都不执行）</p><h3 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h3><p>通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Main.class)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Main.class)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Main.class)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Main.class)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！</p><p>当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容。（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面有机会我们还会讲到乐观锁，如CAS算法）</p><p>那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Main main1 = <span class="hljs-keyword">new</span> Main();<br>    Main main2 = <span class="hljs-keyword">new</span> Main();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (main1)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (main2)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Main main1 = <span class="hljs-keyword">new</span> Main();<br>    Main main2 = <span class="hljs-keyword">new</span> Main();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (main1)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (main2)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。</p><p>synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>    value++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) add();<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) add();<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>    value++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) add();<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) add();<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了！</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>其实死锁的概念在<code>操作系统</code>中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-9852c978350cc5e8641ba778619351bb_b.png&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637568214&t=7740dd98b8e1c4a3bfbd94a30e7f9ff8" alt="img"></p><p>我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Object o1 = <span class="hljs-keyword">new</span> Object();<br>    Object o2 = <span class="hljs-keyword">new</span> Object();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (o2)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程1&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o2)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程2&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Object o1 = <span class="hljs-keyword">new</span> Object();<br>    Object o2 = <span class="hljs-keyword">new</span> Object();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (o2)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程1&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o2)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程2&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">nagocoler@NagodeMacBook-Pro ~ % jps<br>51592 Launcher<br>51690 Jps<br>14955 <br>51693 Main<br>nagocoler@NagodeMacBook-Pro ~ % jstack 51693<br>...<br>Java stack information for the threads listed above:<br>===================================================<br>"Thread-1":<br>at com.test.Main.lambda$main$1(Main.java:46)<br>- waiting to lock <0x000000076ad27fc0> (a java.lang.Object)<br>- locked <0x000000076ad27fd0> (a java.lang.Object)<br>at com.test.Main$$Lambda$2/1867750575.run(Unknown Source)<br>at java.lang.Thread.run(Thread.java:748)<br>"Thread-0":<br>at com.test.Main.lambda$main$0(Main.java:34)<br>- waiting to lock <0x000000076ad27fd0> (a java.lang.Object)<br>- locked <0x000000076ad27fc0> (a java.lang.Object)<br>at com.test.Main$$Lambda$1/396873410.run(Unknown Source)<br>at java.lang.Thread.run(Thread.java:748)<br><br>Found 1 deadlock.<br></code></pre></td></tr></table></figure><p>jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息。</p><p>不推荐使用 <code>suspend() </code>去挂起线程的原因，是因为<code>suspend()</code>在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行<code>resume()</code>方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果<code>resume()</code>操作出现在<code>suspend()</code>之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。</p><h3 id="wait和notify方法"><a href="#wait和notify方法" class="headerlink" title="wait和notify方法"></a>wait和notify方法</h3><p>其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>，他们其实是需要配合synchronized来使用的，只有在同步代码块中才能使用这些方法，我们来看看他们的作用是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Object o1 = <span class="hljs-keyword">new</span> Object();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;开始等待&quot;</span>);<br>                o1.wait();     <span class="hljs-comment">//进入等待状态并释放锁</span><br>                System.out.println(<span class="hljs-string">&quot;等待结束！&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>            System.out.println(<span class="hljs-string">&quot;开始唤醒！&quot;</span>);<br>            o1.notify();     <span class="hljs-comment">//唤醒处于等待状态的线程</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>               System.out.println(i);   <br>            &#125;<br>          <span class="hljs-comment">//唤醒后依然需要等待这里的锁释放之前等待的线程才能继续</span><br>        &#125;<br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Object o1 = <span class="hljs-keyword">new</span> Object();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;开始等待&quot;</span>);<br>                o1.wait();     <span class="hljs-comment">//进入等待状态并释放锁</span><br>                System.out.println(<span class="hljs-string">&quot;等待结束！&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>            System.out.println(<span class="hljs-string">&quot;开始唤醒！&quot;</span>);<br>            o1.notify();     <span class="hljs-comment">//唤醒处于等待状态的线程</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>               System.out.println(i);   <br>            &#125;<br>          <span class="hljs-comment">//唤醒后依然需要等待这里的锁释放之前等待的线程才能继续</span><br>        &#125;<br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以发现，对象的<code>wait()</code>方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的<code>notify()</code>方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！</p><p>notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用<code>wait()</code>后处于等待的线程，而后者是看运气随机选择一个。</p><h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？</p><p><img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613220434628-1803630402.png" alt="img"></p><p>我们可以是ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的变量访问到ThreadLocal对象时，都只能获取到自己线程所属的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();  <span class="hljs-comment">//注意这是一个泛型类，存储类型为我们要存放的变量类型</span><br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">&quot;变量值已设定！&quot;</span>);<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">3000</span>);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();  <span class="hljs-comment">//注意这是一个泛型类，存储类型为我们要存放的变量类型</span><br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">&quot;变量值已设定！&quot;</span>);<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">3000</span>);    <span class="hljs-comment">//间隔三秒</span><br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();  <span class="hljs-comment">//注意这是一个泛型类，存储类型为我们要存放的变量类型</span><br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">&quot;线程1变量值已设定！&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);    <span class="hljs-comment">//间隔2秒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1读取变量值：&quot;</span>);<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        local.set(<span class="hljs-string">&quot;yyds&quot;</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">&quot;线程2变量值已设定！&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();  <span class="hljs-comment">//注意这是一个泛型类，存储类型为我们要存放的变量类型</span><br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">&quot;线程1变量值已设定！&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);    <span class="hljs-comment">//间隔2秒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1读取变量值：&quot;</span>);<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    &#125;);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        local.set(<span class="hljs-string">&quot;yyds&quot;</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">&quot;线程2变量值已设定！&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);    <span class="hljs-comment">//间隔1秒</span><br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。</p><p>我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -> &#123;<br>            System.out.println(local.get());<br>        &#125;).start();<br>    &#125;);<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用InheritableThreadLocal来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;&gt;();<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;&gt;();<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>       local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -> &#123;<br>            System.out.println(local.get());<br>        &#125;).start();<br>    &#125;);<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>在InheritableThreadLocal存放的内容，会自动向子线程传递。</p><hr><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用<code>Thread.sleep()</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> TimerTask(() -&gt; System.out.println(<span class="hljs-string">&quot;我是定时任务！&quot;</span>), <span class="hljs-number">3000</span>).start();   <span class="hljs-comment">//创建并启动此定时任务</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerTask</span></span>&#123;<br>    Runnable task;<br>    <span class="hljs-keyword">long</span> time;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimerTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-keyword">long</span> time)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.task = runnable;<br>        <span class="hljs-keyword">this</span>.time = time;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(time);<br>                task.run();   <span class="hljs-comment">//休眠后再运行</span><br>            &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> TimerTask(() -&gt; System.out.println(<span class="hljs-string">&quot;我是定时任务！&quot;</span>), <span class="hljs-number">3000</span>).start();   <span class="hljs-comment">//创建并启动此定时任务</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerTask</span></span>&#123;<br>    Runnable task;<br>    <span class="hljs-keyword">long</span> time;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimerTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-keyword">long</span> time)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.task = runnable;<br>        <span class="hljs-keyword">this</span>.time = time;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(time);<br>                task.run();   <span class="hljs-comment">//休眠后再运行</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> TimerLoopTask(() -&gt; System.out.println(<span class="hljs-string">&quot;我是定时任务！&quot;</span>), <span class="hljs-number">3000</span>).start();   <span class="hljs-comment">//创建并启动此定时任务</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerLoopTask</span></span>&#123;<br>    Runnable task;<br>    <span class="hljs-keyword">long</span> loopTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimerLoopTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-keyword">long</span> loopTime)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.task = runnable;<br>        <span class="hljs-keyword">this</span>.loopTime = loopTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;   <span class="hljs-comment">//无限循环执行</span><br>                    Thread.sleep(loopTime);<br>                    task.run();   <span class="hljs-comment">//休眠后再运行</span><br>                &#125;<br>            &#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> TimerLoopTask(() -&gt; System.out.println(<span class="hljs-string">&quot;我是定时任务！&quot;</span>), <span class="hljs-number">3000</span>).start();   <span class="hljs-comment">//创建并启动此定时任务</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerLoopTask</span></span>&#123;<br>    Runnable task;<br>    <span class="hljs-keyword">long</span> loopTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimerLoopTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-keyword">long</span> loopTime)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.task = runnable;<br>        <span class="hljs-keyword">this</span>.loopTime = loopTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;   <span class="hljs-comment">//无限循环执行</span><br>                    Thread.sleep(loopTime);<br>                    task.run();   <span class="hljs-comment">//休眠后再运行</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。</p><p>但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Timer timer = <span class="hljs-keyword">new</span> Timer();    <span class="hljs-comment">//创建定时器对象</span><br>    timer.schedule(<span class="hljs-keyword">new</span> TimerTask() &#123;   <span class="hljs-comment">//注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(Thread.currentThread().getName());    <span class="hljs-comment">//打印当前线程名称</span><br>        &#125;<br>    &#125;, <span class="hljs-number">1000</span>);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Timer timer = <span class="hljs-keyword">new</span> Timer();    <span class="hljs-comment">//创建定时器对象</span><br>    timer.schedule(<span class="hljs-keyword">new</span> TimerTask() &#123;   <span class="hljs-comment">//注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(Thread.currentThread().getName());    <span class="hljs-comment">//打印当前线程名称</span><br>        &#125;<br>    &#125;, <span class="hljs-number">1000</span>);    <span class="hljs-comment">//执行一个延时任务</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The timer task queue.  This data structure is shared with the timer</span><br><span class="hljs-comment">     * thread.  The timer produces tasks, via its various schedule calls,</span><br><span class="hljs-comment">     * and the timer thread consumes, executing timer tasks as appropriate,</span><br><span class="hljs-comment">     * and removing them from the queue when they&#x27;re obsolete.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TaskQueue queue = <span class="hljs-keyword">new</span> TaskQueue();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The timer thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TimerThread thread = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The timer task queue.  This data structure is shared with the timer</span><br><span class="hljs-comment">     * thread.  The timer produces tasks, via its various schedule calls,</span><br><span class="hljs-comment">     * and the timer thread consumes, executing timer tasks as appropriate,</span><br><span class="hljs-comment">     * and removing them from the queue when they&#x27;re obsolete.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TaskQueue queue = <span class="hljs-keyword">new</span> TaskQueue();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The timer thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TimerThread thread = <span class="hljs-keyword">new</span> TimerThread(queue);<br>  <br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Timer</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Timer</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    thread.setName(name);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mainLoop();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Someone killed this Thread, behave as if Timer cancelled</span><br>        <span class="hljs-keyword">synchronized</span>(queue) &#123;<br>            newTasksMayBeScheduled = <span class="hljs-keyword">false</span>;<br>            queue.clear();  <span class="hljs-comment">// Eliminate obsolete references</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The main timer loop.  (See class comment.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>       TimerTask task;<br>       <span class="hljs-keyword">boolean</span> taskFired;<br>       <span class="hljs-keyword">synchronized</span>(queue) &#123;<br>         <span class="hljs-comment">// Wait for queue to become non-empty</span><br>          <span class="hljs-keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)   <span class="hljs-comment">//当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。</span><br>                queue.wait();<br>          <span class="hljs-keyword">if</span> (queue.isEmpty())<br>             <span class="hljs-keyword">break</span>;    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mainLoop();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Someone killed this Thread, behave as if Timer cancelled</span><br>        <span class="hljs-keyword">synchronized</span>(queue) &#123;<br>            newTasksMayBeScheduled = <span class="hljs-keyword">false</span>;<br>            queue.clear();  <span class="hljs-comment">// Eliminate obsolete references</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The main timer loop.  (See class comment.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>       TimerTask task;<br>       <span class="hljs-keyword">boolean</span> taskFired;<br>       <span class="hljs-keyword">synchronized</span>(queue) &#123;<br>         <span class="hljs-comment">// Wait for queue to become non-empty</span><br>          <span class="hljs-keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)   <span class="hljs-comment">//当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。</span><br>                queue.wait();<br>          <span class="hljs-keyword">if</span> (queue.isEmpty())<br>             <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程</span><br>                      ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>newTasksMayBeScheduled</code>实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用<code>cancel()</code>方法来关闭它的工作线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(queue) &#123;<br>        thread.newTasksMayBeScheduled = <span class="hljs-keyword">false</span>;<br>        queue.clear();<br>        queue.notify();  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(queue) &#123;<br>        thread.newTasksMayBeScheduled = <span class="hljs-keyword">false</span>;<br>        queue.clear();<br>        queue.notify();  <span class="hljs-comment">//唤醒wait使得工作线程结束</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们可以在使用完成后，调用Timer的<code>cancel()</code>方法以正常退出我们的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Timer timer = <span class="hljs-keyword">new</span> Timer();<br>    timer.schedule(<span class="hljs-keyword">new</span> TimerTask() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(Thread.currentThread().getName());<br>            timer.cancel();  <span class="hljs-comment">//结束</span><br>        &#125;<br>    &#125;, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Timer timer = <span class="hljs-keyword">new</span> Timer();<br>    timer.schedule(<span class="hljs-keyword">new</span> TimerTask() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(Thread.currentThread().getName());<br>            timer.cancel();  <span class="hljs-comment">//结束</span><br>        &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>不要把守护进程和守护线程相提并论！守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程是自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;程序正常运行中...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t.setDaemon(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span><br>    t.start();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        Thread.sleep(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;程序正常运行中...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t.setDaemon(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span><br>    t.start();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在守护线程中产生的新线程也是守护的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        Thread it = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;程序正常运行中...&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        it.start();<br>    &#125;);<br>    t.setDaemon(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span><br>    t.start();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        Thread.sleep(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        Thread it = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;程序正常运行中...&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        it.start();<br>    &#125;);<br>    t.setDaemon(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span><br>    t.start();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="再谈集合类并行方法"><a href="#再谈集合类并行方法" class="headerlink" title="再谈集合类并行方法"></a>再谈集合类并行方法</h2><p>其实我们之前在讲解集合类的根接口时，就发现有这样一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title">parallelStream</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title">parallelStream</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>));<br>    list<br>            .parallelStream()    <span class="hljs-comment">//获得并行流</span><br>            .forEach(i -&gt; System.out.println(Thread.currentThread().getName()+<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>));<br>    list<br>            .parallelStream()    <span class="hljs-comment">//获得并行流</span><br>            .forEach(i -&gt; System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" -> "</span>+i));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用<code>forEachOrdered()</code>方法来使用单线程维持原本的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>));<br>    list<br>            .parallelStream()    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>));<br>    list<br>            .parallelStream()    <span class="hljs-comment">//获得并行流</span><br>            .forEachOrdered(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>&#125;;<br>    Arrays.parallelSort(arr);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>&#125;;<br>    Arrays.parallelSort(arr);   <span class="hljs-comment">//使用多线程进行并行排序，效率更高</span><br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>&#125;;<br>    Arrays.parallelSetAll(arr, i -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>&#125;;<br>    Arrays.parallelSetAll(arr, i -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> arr[i];<br>    &#125;);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！</p><hr><h2 id="Java多线程编程实战"><a href="#Java多线程编程实战" class="headerlink" title="Java多线程编程实战"></a>Java多线程编程实战</h2><p>这是整个教程最后一个编程实战内容了，下一章节为<code>反射</code>一般开发者使用比较少，属于选学内容，不编排编程实战课程。</p><h3 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h3><p>所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。</p><p>通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型与集合类</title>
      <link href="/2022/02/23/4.html/"/>
      <url>/2022/02/23/4.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Java泛型与集合类"><a href="#Java泛型与集合类" class="headerlink" title="Java泛型与集合类"></a>Java泛型与集合类</h1><p>在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。</p><h2 id="走进泛型"><a href="#走进泛型" class="headerlink" title="走进泛型"></a>走进泛型</h2><p>为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以<code>优秀、良好、合格</code> 来作为结果，还有一种就是 <code>60.0、75.5、92.5</code> 这样的数字分数，那么现在该如何去设计这样的一个Score类呢？现在的问题就是，成绩可能是<code>String</code>类型，也可能是<code>Integer</code>类型，如何才能很好的去存可能出现的两种类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span> </span>&#123;<br>    String name;<br>    String id;<br>    Object score;  <span class="hljs-comment">//因为Object是所有类型的父类，因此既可以存放Integer也能存放String</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, Object score)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span> </span>&#123;<br>    String name;<br>    String id;<br>    Object score;  <span class="hljs-comment">//因为Object是所有类型的父类，因此既可以存放Integer也能存放String</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, Object score)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    Score score = <span class="hljs-keyword">new</span> Score(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);  <span class="hljs-comment">//是String类型的</span><br><br>    <span class="hljs-comment">//....</span><br><br>    Integer number = (Integer) score.score;  <span class="hljs-comment">//获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错</span><br>&#125;<br><br><span class="hljs-comment">//运行时出现异常！</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer<br>at com.test.Main.main(Main.java:<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    Score score = <span class="hljs-keyword">new</span> Score(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);  <span class="hljs-comment">//是String类型的</span><br><br>    <span class="hljs-comment">//....</span><br><br>    Integer number = (Integer) score.score;  <span class="hljs-comment">//获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错</span><br>&#125;<br><br><span class="hljs-comment">//运行时出现异常！</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer<br>at com.test.Main.main(Main.java:<span class="hljs-number">14</span>)<br></code></pre></td></tr></table></figure><p>使用Object类型作为引用，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺！（此方法虽然可行，但并不是最好的方法）</p><p>为了解决以上问题，JDK1.5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;   <span class="hljs-comment">//将Score转变为泛型类&lt;T&gt;</span><br>    String name;<br>    String id;<br>    T score;  <span class="hljs-comment">//T为泛型，根据用户提供的类型自动变成对应类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, T score)</span> </span>&#123;   <span class="hljs-comment">//提供的score类型即为T代表的类型</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;   <span class="hljs-comment">//将Score转变为泛型类&lt;T&gt;</span><br>    String name;<br>    String id;<br>    T score;  <span class="hljs-comment">//T为泛型，根据用户提供的类型自动变成对应类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, T score)</span> </span>&#123;   <span class="hljs-comment">//提供的score类型即为T代表的类型</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//直接确定Score的类型是字符串类型的成绩</span><br>    Score&lt;String&gt; score = <span class="hljs-keyword">new</span> Score&lt;String&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);<br><br>    Integer i = score.score;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//直接确定Score的类型是字符串类型的成绩</span><br>    Score&lt;String&gt; score = <span class="hljs-keyword">new</span> Score&lt;String&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);<br><br>    Integer i = score.score;  <span class="hljs-comment">//编译不通过，因为成员变量score类型被定为String！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型！如果类型不符合，将无法通过编译！</p><p>泛型本质上也是一个语法糖（并不是JVM所支持的语法，编译后会转成编译器支持的语法，比如之前的foreach就是），在编译后会被擦除，变回上面的Object类型调用，但是类型转换由编译器帮我们完成，而不是我们自己进行转换（安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//反编译后的代码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Score score = <span class="hljs-keyword">new</span> Score(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);<br>        String i = (String)score.score;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//反编译后的代码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Score score = <span class="hljs-keyword">new</span> Score(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);<br>        String i = (String)score.score;   <span class="hljs-comment">//其实依然会变为强制类型转换，但是这是由编译器帮我们完成的</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>像这样在编译后泛型的内容消失转变为Object的情况称为<code>类型擦除</code>（重要，需要完全理解），所以泛型只是为了方便我们在编译阶段确定类型的一种语法而已，并不是JVM所支持的。</p><p>综上，泛型其实就是一种类型参数，用于指定类型。</p><h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>上一节我们已经提到泛型类的定义，实际上就是普通的类多了一个类型参数，也就是在使用时需要指定具体的泛型类型。泛型的名称一般取单个大写字母，比如T代表Type，也就是<code>类型</code>的英文单词首字母，当然也可以添加数字和其他的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;   <span class="hljs-comment">//将Score转变为泛型类&lt;T&gt;</span><br>    String name;<br>    String id;<br>    T score;  <span class="hljs-comment">//T为泛型，根据用户提供的类型自动变成对应类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, T score)</span> </span>&#123;   <span class="hljs-comment">//提供的score类型即为T代表的类型</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;   <span class="hljs-comment">//将Score转变为泛型类&lt;T&gt;</span><br>    String name;<br>    String id;<br>    T score;  <span class="hljs-comment">//T为泛型，根据用户提供的类型自动变成对应类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, T score)</span> </span>&#123;   <span class="hljs-comment">//提供的score类型即为T代表的类型</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在一个普通类型中定义泛型，泛型T称为<code>参数化类型</code>，在定义泛型类的引用时，需要明确指出类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">Score&lt;String&gt; score = <span class="hljs-keyword">new</span> Score&lt;String&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string"><code class="language-hljs java">Score&lt;String&gt; score = <span class="hljs-keyword">new</span> Score&lt;String&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">"优秀"</span>);<br></code></pre></td></tr></table></figure><p>此时类中的泛型T已经被替换为String了，在我们获取此对象的泛型属性时，编译器会直接告诉我们类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">Integer i = score.score;   <span class="hljs-comment"><code class="language-hljs java">Integer i = score.score;   <span class="hljs-comment">//编译不通过，因为成员变量score明确为String类型</span><br></code></pre></td></tr></table></figure><p>注意，泛型只能用于对象属性，也就是非静态的成员变量才能使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">static</span> T score;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">static</span> T score;   <span class="hljs-comment">//错误，不能在静态成员上定义</span><br></code></pre></td></tr></table></figure><p>由此可见，泛型是只有在创建对象后编译器才能明确泛型类型，而静态类型是类所具有的属性，不足以使得编译器完成类型推断。</p><p>泛型无法使用基本类型，如果需要基本类型，只能使用基本类型的包装类进行替换！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">Score&lt;<span class="hljs-keyword">double</span>&gt; score = <span class="hljs-keyword">new</span> Score&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">90.5</span>);  <span class="hljs-comment"><code class="language-hljs java">Score&lt;<span class="hljs-keyword">double</span>&gt; score = <span class="hljs-keyword">new</span> Score&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">90.5</span>);  <span class="hljs-comment">//编译不通过</span><br></code></pre></td></tr></table></figure><p>那么为什么泛型无法使用基本类型呢？回想上一节提到的类型擦除，其实就很好理解了。由于JVM没有泛型概念，因此泛型最后还是会被编译器编译为Object，并采用强制类型转换的形式进行类型匹配，而我们的基本数据类型和引用类型之间无法进行类型转换，所以只能使用基本类型的包装类来处理。</p><h3 id="类的泛型方法"><a href="#类的泛型方法" class="headerlink" title="类的泛型方法"></a>类的泛型方法</h3><p>泛型方法的使用也很简单，我们只需要把它当做一个未知的类型来使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//若方法的返回值类型为泛型，那么编译器会自动进行推断</span><br>  <span class="hljs-keyword">return</span> score;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(T score)</span> </span>&#123;   <span class="hljs-comment">//若方法的形式参数为泛型，那么实参只能是定义时的类型</span><br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//若方法的返回值类型为泛型，那么编译器会自动进行推断</span><br>  <span class="hljs-keyword">return</span> score;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(T score)</span> </span>&#123;   <span class="hljs-comment">//若方法的形式参数为泛型，那么实参只能是定义时的类型</span><br>  <span class="hljs-keyword">this</span>.score = score;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Score&lt;String&gt; score = <span class="hljs-keyword">new</span> Score&lt;String&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);<br>score.setScore(<span class="hljs-number">10</span>);   <span class="hljs-comment"><code class="language-hljs java">Score&lt;String&gt; score = <span class="hljs-keyword">new</span> Score&lt;String&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);<br>score.setScore(<span class="hljs-number">10</span>);   <span class="hljs-comment">//编译不通过，因为只接受String类型</span><br></code></pre></td></tr></table></figure><p>同样地，静态方法无法直接使用类定义的泛型（注意是无法直接使用，静态方法可以使用泛型）</p><h3 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h3><p>那么如果我想在静态方法中使用泛型呢？首先我们要明确之前为什么无法使用泛型，因为之前我们的泛型定义是在类上的，只有明确具体的类型才能开始使用，也就是创建对象时完成类型确定，但是静态方法不需要依附于对象，那么只能在使用时再来确定了，所以静态方法可以使用泛型，但是需要单独定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(E e)</span></span>&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(E e)</span></span>&#123;   <span class="hljs-comment">//在方法定义前声明泛型</span><br>  System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，成员方法也能自行定义泛型，在实际使用时再进行类型确定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(E e)</span></span>&#123;<br>  System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实，无论是泛型类还是泛型方法，再使用时一定要能够进行类型推断，明确类型才行。</p><p>注意一定要区分类定义的泛型和方法前定义的泛型！</p><h3 id="泛型引用"><a href="#泛型引用" class="headerlink" title="泛型引用"></a>泛型引用</h3><p>可以看到我们在定义一个泛型类的引用时，需要在后面指出此类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">Score&lt;Integer&gt; score;  <span class="hljs-comment"><code class="language-hljs java">Score&lt;Integer&gt; score;  <span class="hljs-comment">//声明泛型为Integer类型</span><br></code></pre></td></tr></table></figure><p>如果不希望指定类型，或是希望此引用类型可以引用任意泛型的<code>Score</code>类对象，可以使用<code>?</code>通配符，来表示自动匹配任意的可用类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">Score&lt;?&gt; score;   <span class="hljs-comment"><code class="language-hljs java">Score&lt;?&gt; score;   <span class="hljs-comment">//score可以引用任意的Score类型对象了！</span><br></code></pre></td></tr></table></figure><p>那么使用通配符之后，得到的泛型成员变量会是什么类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">Object o = score.getScore();   <span class="hljs-comment"><code class="language-hljs java">Object o = score.getScore();   <span class="hljs-comment">//只能变为Object</span><br></code></pre></td></tr></table></figure><p>因为使用了通配符，编译器就无法进行类型推断，所以只能使用原始类型。</p><p>在学习了泛型的界限后，我们还会继续了解通配符的使用。</p><h3 id="泛型的界限"><a href="#泛型的界限" class="headerlink" title="泛型的界限"></a>泛型的界限</h3><p>现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt; </span>&#123;   <span class="hljs-comment">//设定泛型上界，必须是Number的子类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> T score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, T score)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt; </span>&#123;   <span class="hljs-comment">//设定泛型上界，必须是Number的子类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> T score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, T score)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>extends</code>关键字进行上界限定，只有指定类型或指定类型的子类才能作为类型参数。</p><p>同样的，泛型通配符也支持泛型的界限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">Score&lt;? extends Number&gt; score;  <span class="hljs-comment"><code class="language-hljs java">Score&lt;? extends Number&gt; score;  <span class="hljs-comment">//限定为匹配Number及其子类的类型</span><br></code></pre></td></tr></table></figure><p>同理，既然泛型有上限，那么也有下限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">Score&lt;? <span class="hljs-keyword">super</span> Integer&gt; score;   <span class="hljs-comment"><code class="language-hljs java">Score&lt;? <span class="hljs-keyword">super</span> Integer&gt; score;   <span class="hljs-comment">//限定为匹配Integer及其父类</span><br></code></pre></td></tr></table></figure><p>通过<code>super</code>关键字进行下界限定，只有指定类型或指定类型的父类才能作为类型参数。</p><p>图解如下：</p><p><img src="http://images4.10qianwan.com/10qianwan/20191209/b_0_201912091523263309.png" alt="png"></p><p><img src="http://images4.10qianwan.com/10qianwan/20191209/b_0_201912091523264595.jpg" alt="png"></p><p>那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Score&lt;? extends Number&gt; score = <span class="hljs-keyword">new</span> Score&lt;&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">10</span>);<br>Number o = score.getScore();    <span class="hljs-comment"><code class="language-hljs java">Score&lt;? extends Number&gt; score = <span class="hljs-keyword">new</span> Score&lt;&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">10</span>);<br>Number o = score.getScore();    <span class="hljs-comment">//得到的结果为上界类型</span><br></code></pre></td></tr></table></figure><p>也就是说，一旦我们指定了上界后，编译器就将范围从原始类型<code>Object</code>提升到我们指定的上界<code>Number</code>，但是依然无法明确具体类型。思考：那如果定义下限呢？</p><p>那么既然我们可以给泛型类限定上界，现在我们来看编译后结果呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//使用javap -l 进行反编译</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Number</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> com.test.Score(java.lang.String, java.lang.String, T);<br>    LineNumberTable:<br>      line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>      line <span class="hljs-number">9</span>: <span class="hljs-number">4</span><br>      line <span class="hljs-number">10</span>: <span class="hljs-number">9</span><br>      line <span class="hljs-number">11</span>: <span class="hljs-number">14</span><br>      line <span class="hljs-number">12</span>: <span class="hljs-number">19</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>      <span class="hljs-number">20</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/test/Score;<br>          <span class="hljs-number">0</span>      <span class="hljs-number">20</span>     <span class="hljs-number">1</span>  name   Ljava/lang/String;<br>          <span class="hljs-number">0</span>      <span class="hljs-number">20</span>     <span class="hljs-number">2</span>    id   Ljava/lang/String;<br>          <span class="hljs-number">0</span>      <span class="hljs-number">20</span>     <span class="hljs-number">3</span> score   Ljava/lang/Number;   <span class="hljs-comment">//可以看到score的类型直接被编译为Number类</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getScore</span><span class="hljs-params">()</span></span>;<br>    LineNumberTable:<br>      line <span class="hljs-number">15</span>: <span class="hljs-number">0</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">//使用javap -l 进行反编译</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Number</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> com.test.Score(java.lang.String, java.lang.String, T);<br>    LineNumberTable:<br>      line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>      line <span class="hljs-number">9</span>: <span class="hljs-number">4</span><br>      line <span class="hljs-number">10</span>: <span class="hljs-number">9</span><br>      line <span class="hljs-number">11</span>: <span class="hljs-number">14</span><br>      line <span class="hljs-number">12</span>: <span class="hljs-number">19</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>      <span class="hljs-number">20</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/test/Score;<br>          <span class="hljs-number">0</span>      <span class="hljs-number">20</span>     <span class="hljs-number">1</span>  name   Ljava/lang/String;<br>          <span class="hljs-number">0</span>      <span class="hljs-number">20</span>     <span class="hljs-number">2</span>    id   Ljava/lang/String;<br>          <span class="hljs-number">0</span>      <span class="hljs-number">20</span>     <span class="hljs-number">3</span> score   Ljava/lang/Number;   <span class="hljs-comment">//可以看到score的类型直接被编译为Number类</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getScore</span><span class="hljs-params">()</span></span>;<br>    LineNumberTable:<br>      line <span class="hljs-number">15</span>: <span class="hljs-number">0</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/test/Score;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因此，一旦确立上限后，编译器会自动将类型提升到上限类型。</p><h3 id="钻石运算符"><a href="#钻石运算符" class="headerlink" title="钻石运算符"></a>钻石运算符</h3><p>我们发现，每次创建泛型对象都需要在前后都标明类型，但是实际上后面的类型声明是可以去掉的，因为我们在传入参数时或定义泛型类的引用时，就已经明确了类型，因此JDK1.7提供了钻石运算符来简化代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java">Score&lt;Integer&gt; score = <span class="hljs-keyword">new</span> Score&lt;Integer&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">//1.7之前</span><br><br>Score&lt;Integer&gt; score = <span class="hljs-keyword">new</span> Score&lt;&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment"><code class="language-hljs java">Score&lt;Integer&gt; score = <span class="hljs-keyword">new</span> Score&lt;Integer&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">//1.7之前</span><br><br>Score&lt;Integer&gt; score = <span class="hljs-keyword">new</span> Score&lt;&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">//1.7之后</span><br></code></pre></td></tr></table></figure><h3 id="泛型与多态"><a href="#泛型与多态" class="headerlink" title="泛型与多态"></a>泛型与多态</h3><p>泛型不仅仅可以可以定义在类上，同时也能定义在接口上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScoreInterface</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">getScore</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScoreInterface</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">getScore</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当实现此接口时，我们可以选择在实现类明确泛型类型或是继续使用此泛型，让具体创建的对象来确定类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ScoreInterface</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;   <span class="hljs-comment">//将Score转变为泛型类&lt;T&gt;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> T score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, T score)</span> </span>&#123; <br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(T score)</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ScoreInterface</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;   <span class="hljs-comment">//将Score转变为泛型类&lt;T&gt;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> T score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(String name, String id, T score)</span> </span>&#123; <br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(T score)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringScore</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ScoreInterface</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;   <span class="hljs-comment">//在实现时明确类型</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringScore</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ScoreInterface</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;   <span class="hljs-comment">//在实现时明确类型</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类同理，这里就不多做演示了。</p><h3 id="多态类型擦除"><a href="#多态类型擦除" class="headerlink" title="多态类型擦除"></a>多态类型擦除</h3><p>思考一个问题，既然继承后明确了泛型类型，那么为什么<code>@Override</code>不会出现错误呢，重写的条件是需要和父类的返回值类型、形式参数一致，而泛型默认的原始类型是Object类型，子类明确后变为Number类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T t)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.t=t;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Number</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> Number n;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//这并不满足重写的要求，因为只能重写父类同样返回值和参数的方法，但是这样却能够通过编译！</span><br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Number t)</span></span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T t)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.t=t;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">Number</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> Number n;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//这并不满足重写的要求，因为只能重写父类同样返回值和参数的方法，但是这样却能够通过编译！</span><br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Number t)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.t=t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过反编译进行观察，实际上是编译器帮助我们生成了两个桥接方法用于支持重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get();<span class="hljs-comment">//调用返回Number的那个方法</span><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Object t )</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.set((Number)t ); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get();<span class="hljs-comment">//调用返回Number的那个方法</span><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Object t )</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.set((Number)t ); <span class="hljs-comment">//调用参数是Number的那个方法</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h2><p>警告！本章最难的部分！</p><p>学习集合类之前，我们还有最关键的内容需要学习，同第一章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件！（学习不要快餐式！）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以下去自行了解。</p><p>在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。</p><p>通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！</p><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>线性表是最基本的一种数据结构，它是表示一组相同类型数据的有限序列，你可以把它与数组进行参考，但是它并不是数组，线性表是一种表结构，它能够支持数据的插入、删除、更新、查询等，同时数组可以随意存放在数组中任意位置，而线性表只能依次有序排列，不能出现空隙，因此，我们需要进一步的设计。</p><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><p>将数据依次存储在连续的整块物理空间中，这种存储结构称为<code>顺序存储结构</code>，而以这种方式实现的线性表，我们称为<code>顺序表</code>。</p><p>同样的，表中的每一个个体都被称为<code>元素</code>，元素左边的元素（上一个元素），称为<code>前驱</code>，同理，右边的元素（后一个元素）称为<code>后驱</code>。</p><p><img src="https://img1.baidu.com/it/u=4003060195,523881164&fm=26&fmt=auto" alt="img"></p><p>我们设计线性表的目标就是为了去更好地管理我们的数据，也就是说，我们可以基于数组，来进行封装，实现增删改查！既然要存储一组数据，那么很容易联想到我们之前学过的数组，数组就能够容纳一组同类型的数据。</p><p>目标：以数组为底层，编写以下抽象类的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性表抽象类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt; 存储的元素(Element)类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取表的长度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 顺序表的长度</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加一个元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 要添加的位置(索引)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e, <span class="hljs-keyword">int</span> index)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除指定位置的元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 移除的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取指定位置的元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性表抽象类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt; 存储的元素(Element)类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取表的长度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 顺序表的长度</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加一个元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 要添加的位置(索引)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e, <span class="hljs-keyword">int</span> index)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除指定位置的元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 移除的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取指定位置的元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为<code>链式存储结构</code></p><p>实际上，就是每一个结点存放一个元素和一个指向下一个结点的引用（C语言里面是指针，Java中就是对象的引用，代表下一个结点对象）</p><p><img src="https://img1.baidu.com/it/u=3381038214,3369355034&fm=26&fmt=auto&gp=0.jpg" alt="img"></p><p>利用这种思想，我们再来尝试实现上面的抽象类，从实际的代码中感受！</p><p>比较：顺序表和链表的优异？</p><p>顺序表优缺点：</p><ul><li>访问速度快，随机访问性能高</li><li>插入和删除的效率低下，极端情况下需要变更整个表</li><li>不易扩充，需要复制并重新创建数组</li></ul><p>链表优缺点：</p><ul><li>插入和删除效率高，只需要改变连接点的指向即可</li><li>动态扩充容量，无需担心容量问题</li><li>访问元素需要依次寻找，随机访问元素效率低下</li></ul><p>链表只能指向后面，能不能指向前面呢？双向链表！</p><hr><p>栈和队列实际上就是对线性表加以约束的一种数据结构，如果前面的线性表的掌握已经ok，那么栈和队列就非常轻松了！</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈遵循先入后出原则，只能在线性表的一端添加和删除元素。我们可以把栈看做一个杯子，杯子只有一个口进出，最低处的元素只能等到上面的元素离开杯子后，才能离开。</p><p><img src="https://img2.baidu.com/it/u=4172728777,3669222584&fm=26&fmt=auto&gp=0.jpg" alt="img"></p><p>向栈中插入一个元素时，称为<code>入栈（压栈）</code>，移除栈顶元素称为<code>出栈</code>，我们需要尝试实现以下抽象类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象类型栈，待实现</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt; 元素类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStack</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出栈操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 栈顶元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 入栈操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象类型栈，待实现</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt; 元素类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStack</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出栈操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 栈顶元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 入栈操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实，我们的JVM在处理方法调用时，也是一个栈操作：</p><p><img src="https://img0.baidu.com/it/u=1098322354,1667908648&fm=26&fmt=auto" alt="img"></p><p>所以说，如果玩不好递归，就会像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        go();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;<br>        go();<br>    &#125;<br>&#125;<br><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        go();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;<br>        go();<br>    &#125;<br>&#125;<br><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>at com.test.Main.go(Main.java:<span class="hljs-number">13</span>)<br>  ...<br></code></pre></td></tr></table></figure><p>栈的深度是有限制的，如果达到限制，将会出现<code>StackOverflowError</code>错误（注意是错误！说明是JVM出现了问题）</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列同样也是受限制的线性表，不过队列就像我们排队一样，只能从队尾开始排，从队首出。</p><p><img src="https://img1.baidu.com/it/u=2682903513,371531599&fm=26&fmt=auto" alt="img"></p><p>所以我们要实现以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 进队操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出队操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">poll</span><span class="hljs-params"><code class="language-hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 进队操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出队操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>本版块主要学习的是二叉树，树也是一种数据结构，但是它使用起来更加的复杂。</p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>我们前面已经学习过链表了，我们知道链表是单个结点之间相连，也就是一种一对一的关系，而树则是一个结点连接多个结点，也就是一对多的关系。</p><p><img src="https://img2.baidu.com/it/u=1603039729,2366298993&fm=26&fmt=auto" alt="img"></p><p>一个结点可以有N个子结点，就像上图一样，看起来就像是一棵树。而位于最顶端的结点（没有父结点）我们称为<code>根结点</code>，而结点拥有的子节点数量称为<code>度</code>，每向下一级称为一个<code>层次</code>，树中出现的最大层次称为树的<code>深度(高度)</code>。</p><h4 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是一种特殊的树，每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点，位于两边的子结点称为左右子树（注意，左右子树是明确区分的，是左就是左，是右就是右）</p><p><img src="https://img1.baidu.com/it/u=4097712510,2021128931&fm=26&fmt=auto&gp=0.jpg" alt="img"></p><p>数学性质：</p><ul><li>在二叉树的第i层上最多有2^(i-1) 个节点。</li><li>二叉树中如果深度为k，那么最多有2^k-1个节点。</li></ul><p>设计一个二叉树结点类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> E e;   <span class="hljs-comment">//当前结点数据</span><br>    <span class="hljs-keyword">public</span> TreeNode&lt;E&gt; left;   <span class="hljs-comment">//左子树</span><br>    <span class="hljs-keyword">public</span> TreeNode&lt;E&gt; right;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> E e;   <span class="hljs-comment">//当前结点数据</span><br>    <span class="hljs-keyword">public</span> TreeNode&lt;E&gt; left;   <span class="hljs-comment">//左子树</span><br>    <span class="hljs-keyword">public</span> TreeNode&lt;E&gt; right;   <span class="hljs-comment">//右子树</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>顺序表的遍历其实就是依次有序去访问表中每一个元素，而像二叉树这样的复杂结构，我们有四种遍历方式，他们是：前序遍历、中序遍历、后序遍历以及层序遍历，本版块我们主要讨论前三种遍历方式：</p><ul><li><strong>前序遍历</strong>：从二叉树的根结点出发，到达结点时就直接输出结点数据，按照先向左在向右的方向访问。ABCDEF</li><li><strong>中序遍历</strong>：从二叉树的根结点出发，优先输出左子树的节点的数据，再输出当前节点本身，最后才是右子树。CBDAEF</li><li><strong>后序遍历</strong>：从二叉树的根结点出发，优先遍历其左子树，再遍历右子树，最后在输出当前节点本身。CDBFEA</li></ul><h4 id="满二叉树和完全二叉树"><a href="#满二叉树和完全二叉树" class="headerlink" title="满二叉树和完全二叉树"></a>满二叉树和完全二叉树</h4><p>满二叉树和完全二叉树其实就是特殊情况下的二叉树，满二叉树左右的所有叶子节点都在同一层，也就是说，完全把每一个层级都给加满了结点。完全二叉树与满二叉树不同的地方在于，它的最下层叶子节点可以不满，但是最下层的叶子节点必须靠左排布。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.examw.com%2Fncre%2FFiles%2F2011-6%2F20%2F93236613.gif&refer=http%3A%2F%2Fwww.examw.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634373420&t=19f3ed8195b15d0b8f49201cc2803759" alt="img"></p><p>其实满二叉树和完全二叉树就是有一定规律的二叉树，很容易理解。</p><h3 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h3><p>我们之前提到的这些数据结构，很好地帮我们管理了数据，但是，如果需要查找某一个元素是否存在于数据结构中，如何才能更加高效的去完成呢？</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>通过前面的学习，我们发现，顺序表虽然查询效率高，但是插入删除有严重表更新的问题，而链表虽然弥补了更新问题，但是查询效率实在是太低了，能否有一种折中方案？哈希表！</p><p>不知大家在之前的学习中是否发现，我们的Object类中，定义了一个叫做<code>hashcode()</code>的方法？而这个方法呢，就是为了更好地支持哈希表的实现。<code>hashcode()</code>默认得到的是对象的内存地址，也就是说，每个对象的hashCode都不一样。</p><p>哈希表，其实本质上就是一个存放链表的数组，那么它是如何去存储数据的呢？我们先来看看长啥样：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2127470%2F202012%2F2127470-20201222194727385-1606433879.jpg&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634376519&t=8cc6fc7a35e695cc5ba12687974daa54" alt="img"></p><p>数组中每一个元素都是一个头结点，用于保存数据，那我们怎么确定数据应该放在哪一个位置呢？通过hash算法，我们能够瞬间得到元素应该放置的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//假设hash表长度为16，hash算法为：</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hashcode)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> hashcode % <span class="hljs-number"><code class="language-hljs java"><span class="hljs-comment">//假设hash表长度为16，hash算法为：</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hashcode)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> hashcode % <span class="hljs-number">16</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>设想这样一个问题，如果计算出来的hash值和之前已经存在的元素相同了呢？这种情况我们称为<code>hash碰撞</code>，这也是为什么要将每一个表元素设置为一个链表的头结点的原因，一旦发现重复，我们可以往后继续添加节点。</p><p>当然，以上的hash表结构只是一种设计方案，在面对大额数据时，是不够用的，在JDK1.8中，集合类使用的是数组+二叉树的形式解决的（这里的二叉树是经过加强的二叉树，不是前面讲得简单二叉树，我们下一节就会开始讲）</p><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>我们前面学习的二叉树效率是不够的，我们需要的是一种效率更高的二叉树，因此，基于二叉树的改进，提出了二叉查找树，可以看到结构像下面这样：</p><p><img src="https://img0.baidu.com/it/u=3674232536,1832030468&fm=26&fmt=auto&gp=0.jpg" alt="img"></p><p>不难发现，每个节点的左子树，一定小于当前节点的值，每个节点的右子树，一定大于当前节点的值，这样的二叉树称为<code>二叉排序树</code>。利用二分搜索的思想，我们就可以快速查找某个节点！</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>在了解了二叉查找树之后，我们发现，如果根节点为10，现在加入到结点的值从9开始，依次减小到1，那么这个表就会很奇怪，就像下面这样：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20191127151205330.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDE5MTA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634378465&t=eb9bf93cfb9191362d1170b93b06d902" alt="img"></p><p>显然，当所有的结点都排列到一边，这种情况下，查找效率会直接退化为最原始的二叉树！因此我们需要维持二叉树的平衡，才能维持原有的查找效率。</p><p>现在我们对二叉排序树加以约束，要求每个结点的左右两个子树的高度差的绝对值不超过1，这样的二叉树称为<code>平衡二叉树</code>，同时要求每个结点的左右子树都是平衡二叉树，这样，就不会因为一边的疯狂增加导致失衡。我们来看看以下几种情况：</p><p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072218213884.png" alt="img"></p><p>左左失衡</p><p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072218444051.png" alt="img"></p><p>右右失衡</p><p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072219144367.png" alt="img"></p><p>左右失衡</p><p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072219540371.png" alt="img"></p><p>右左失衡</p><p>通过以上四种情况的处理，最终得到维护平衡二叉树的算法。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树也是二叉排序树的一种改进，同平衡二叉树一样，红黑树也是一种维护平衡的二叉排序树，但是没有平衡二叉树那样严格（平衡二叉树每次插入新结点时，可能会出现大量的旋转，而红黑树保证不超过三次），红黑树降低了对于旋转的要求，因此效率有一定的提升同时实现起来也更加简单。但是红黑树的效率却高于平衡二叉树，红黑树也是JDK1.8中使用的数据结构！</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F1301290%2F201904%2F1301290-20190418213139526-1239863354.jpg&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634381313&t=d60b654d81ee3930b8518f194c976409" alt="img"></p><p>红黑树的特性:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点的两边也需要表示（虽然没有，但是null也需要表示出来）是黑色。<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><p>我们来看看一个节点，是如何插入到红黑树中的：</p><p>基本的 插入规则和平衡二叉树一样，但是在插入后：</p><ol><li>将新插入的节点标记为红色</li><li>如果 X 是根结点(root)，则标记为黑色</li><li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li></ol><ul><li><p>3.1 如果 X 的 uncle (叔叔) 是红色</p></li><li><ul><li>3.1.1 将 parent 和 uncle 标记为黑色</li><li>3.1.2 将 grand parent (祖父) 标记为红色</li><li>3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3</li></ul></li><li><p>3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理</p></li><li><ul><li>3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子)</li><li>3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子)</li><li>3.2.3 右右 (P 是 G 的右孩子，并且 X 是 P 的右孩子)</li><li>3.2.4 右左 (P 是 G 的右孩子，并且 X 是 P 的左孩子)</li><li>其实这种情况下处理就和我们的平衡二叉树一样了</li></ul></li></ul><hr><h2 id="认识集合类"><a href="#认识集合类" class="headerlink" title="认识集合类"></a>认识集合类</h2><p>集合表示一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。一些集合是有序的，而其他则是无序的。</p><p>集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（数据结构很重要！），不仅仅是教会大家如何去使用。</p><p>集合类最顶层不是抽象类而是接口，因为接口代表的是某个功能，而抽象类是已经快要成形的类型，不同的集合类的底层实现是不相同的，同时一个集合类可能会同时具有两种及以上功能（既能做队列也能做列表），所以采用接口会更加合适，接口只需定义支持的功能即可。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.mianfeiwendang.com%2Fpic%2F29a5b61e9e5e19fe10103b4c%2F1-356-jpg_6_0_______-858-0-0-858.jpg&refer=http%3A%2F%2Fwww.mianfeiwendang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634434848&t=e696ab71af584ef08a38fc328956586c" alt="img"></p><h3 id="数组与集合"><a href="#数组与集合" class="headerlink" title="数组与集合"></a>数组与集合</h3><p>相同之处：</p><ol><li>它们都是容器，都能够容纳一组元素。</li></ol><p>不同之处：</p><ol><li>数组的大小是固定的，集合的大小是可变的。</li><li>数组可以存放基本数据类型，但集合只能存放对象。</li><li>数组存放的类型只能是一种，但集合可以有不同种类的元素。</li></ol><h3 id="集合根接口Collection"><a href="#集合根接口Collection" class="headerlink" title="集合根接口Collection"></a>集合根接口Collection</h3><p>本接口中定义了全部的集合基本操作，我们可以在源码中看看。</p><p>我们再来看看List和Set以及Queue接口。</p><h2 id="集合类的使用"><a href="#集合类的使用" class="headerlink" title="集合类的使用"></a>集合类的使用</h2><h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><p>首先介绍ArrayList，它的底层是用数组实现的，内部维护的是一个可改变大小的数组，也就是我们之前所说的线性表！跟我们之前自己写的ArrayList相比，它更加的规范，同时继承自List接口。</p><p>先看看ArrayList的源码！</p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">//默认长度的列表</span><br>List&lt;String&gt; listInit = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">100</span>);  <span class="hljs-comment"><code class="language-hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">//默认长度的列表</span><br>List&lt;String&gt; listInit = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">100</span>);  <span class="hljs-comment">//初始长度为100的列表</span><br></code></pre></td></tr></table></figure><p>向列表中添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>list.add(<span class="hljs-string">&quot;yyds&quot;</span>);<br>list.contains(<span class="hljs-string">&quot;yyds&quot;</span>); <span class="hljs-comment"><code class="language-hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>list.add(<span class="hljs-string">&quot;yyds&quot;</span>);<br>list.contains(<span class="hljs-string">&quot;yyds&quot;</span>); <span class="hljs-comment">//是否包含某个元素</span><br>System.out.println(list);<br></code></pre></td></tr></table></figure><p>移除元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;yyds&quot;</span>);<br>    list.remove(<span class="hljs-number">0</span>);   <span class="hljs-comment">//按下标移除元素</span><br>    list.remove(<span class="hljs-string">&quot;yyds&quot;</span>);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;yyds&quot;</span>);<br>    list.remove(<span class="hljs-number">0</span>);   <span class="hljs-comment">//按下标移除元素</span><br>    list.remove(<span class="hljs-string">&quot;yyds&quot;</span>);    <span class="hljs-comment">//移除指定元素</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>也支持批量操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.addAll(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());   <span class="hljs-comment">//在尾部批量添加元素</span><br>    list.removeAll(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());   <span class="hljs-comment">//批量移除元素（只有给定集合中存在的元素才会被移除）</span><br>    list.retainAll(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.addAll(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());   <span class="hljs-comment">//在尾部批量添加元素</span><br>    list.removeAll(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());   <span class="hljs-comment">//批量移除元素（只有给定集合中存在的元素才会被移除）</span><br>    list.retainAll(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());   <span class="hljs-comment">//只保留某些元素</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看LinkedList，其实本质就是一个链表！我们来看看源码。</p><p>其实与我们之前编写的LinkedList不同之处在于，它内部使用的是一个双向链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.item = element;<br>        <span class="hljs-keyword">this</span>.next = next;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.item = element;<br>        <span class="hljs-keyword">this</span>.next = next;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，我们发现它还实现了Queue接口，所以LinkedList也能被当做一个队列或是栈来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    list.offer(<span class="hljs-string">&quot;A&quot;</span>);   <span class="hljs-comment">//入队</span><br>    System.out.println(list.poll());  <span class="hljs-comment">//出队</span><br>    list.push(<span class="hljs-string">&quot;A&quot;</span>);<br>    list.push(<span class="hljs-string">&quot;B&quot;</span>);    <span class="hljs-comment">//进栈</span><br>    list.push(<span class="hljs-string">&quot;C&quot;</span>);<br>    System.out.println(list.pop());<br>    System.out.println(list.pop());    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    list.offer(<span class="hljs-string">&quot;A&quot;</span>);   <span class="hljs-comment">//入队</span><br>    System.out.println(list.poll());  <span class="hljs-comment">//出队</span><br>    list.push(<span class="hljs-string">&quot;A&quot;</span>);<br>    list.push(<span class="hljs-string">&quot;B&quot;</span>);    <span class="hljs-comment">//进栈</span><br>    list.push(<span class="hljs-string">&quot;C&quot;</span>);<br>    System.out.println(list.pop());<br>    System.out.println(list.pop());    <span class="hljs-comment">//出栈</span><br>    System.out.println(list.pop());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="利用代码块来快速添加内容"><a href="#利用代码块来快速添加内容" class="headerlink" title="利用代码块来快速添加内容"></a>利用代码块来快速添加内容</h4><p>前面我们学习了匿名内部类，我们就可以利用代码块，来快速生成一个自带元素的List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;()&#123;&#123;    <span class="hljs-comment">//初始化时添加</span><br>  <span class="hljs-keyword">this</span>.add(<span class="hljs-string">&quot;A&quot;</span>);<br>  <span class="hljs-keyword">this</span>.add(<span class="hljs-string"><code class="language-hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;()&#123;&#123;    <span class="hljs-comment">//初始化时添加</span><br>  <span class="hljs-keyword">this</span>.add(<span class="hljs-string">&quot;A&quot;</span>);<br>  <span class="hljs-keyword">this</span>.add(<span class="hljs-string">"B"</span>);<br>&#125;&#125;;<br></code></pre></td></tr></table></figure><p>如果是需要快速生成一个只读的List，后面我们会讲解Arrays工具类。</p><h4 id="集合的排序"><a href="#集合的排序" class="headerlink" title="集合的排序"></a>集合的排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;()&#123;   <span class="hljs-comment">//Java9才支持匿名内部类使用钻石运算符</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.add(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">this</span>.add(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">this</span>.add(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">this</span>.add(<span class="hljs-number">8</span>);<br>    &#125;<br>&#125;;<br>list.sort((a, b) -&gt; &#123;    <span class="hljs-comment">//排序已经由JDK实现，现在只需要填入自定义规则，完成Comparator接口实现</span><br>  <span class="hljs-keyword">return</span> a - b;    <span class="hljs-comment"><code class="language-hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;()&#123;   <span class="hljs-comment">//Java9才支持匿名内部类使用钻石运算符</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.add(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">this</span>.add(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">this</span>.add(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">this</span>.add(<span class="hljs-number">8</span>);<br>    &#125;<br>&#125;;<br>list.sort((a, b) -&gt; &#123;    <span class="hljs-comment">//排序已经由JDK实现，现在只需要填入自定义规则，完成Comparator接口实现</span><br>  <span class="hljs-keyword">return</span> a - b;    <span class="hljs-comment">//返回值小于0，表示a应该在b前面，返回值大于0，表示b应该在a后面，等于0则不进行交换</span><br>&#125;);<br>System.out.println(list);<br></code></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><p>所有的集合类，都支持foreach循环！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;()&#123;   <span class="hljs-comment">//Java9才支持匿名内部类使用钻石运算符</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.add(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">this</span>.add(<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">this</span>.add(<span class="hljs-number">5</span>);<br>            <span class="hljs-keyword">this</span>.add(<span class="hljs-number">8</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;()&#123;   <span class="hljs-comment">//Java9才支持匿名内部类使用钻石运算符</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.add(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">this</span>.add(<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">this</span>.add(<span class="hljs-number">5</span>);<br>            <span class="hljs-keyword">this</span>.add(<span class="hljs-number">8</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (Integer integer : list) &#123;<br>        System.out.println(integer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，也可以使用JDK1.8新增的forEach方法，它接受一个Consumer接口实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><code class="language-hljs java">list.forEach(i -> &#123;<br>    System.out.println(i);<br>&#125;);<br></code></pre></td></tr></table></figure><p>从JDK1.8开始，lambda表达式开始逐渐成为主流，我们需要去适应函数式编程的这种语法，包括批量替换，也是用到了函数式接口来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">list.replaceAll((i) -&gt; &#123;<br>  <span class="hljs-keyword">if</span>(i == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;   <span class="hljs-comment">//将所有的2替换为3</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;   <span class="hljs-comment"><code class="language-hljs java">list.replaceAll((i) -&gt; &#123;<br>  <span class="hljs-keyword">if</span>(i == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;   <span class="hljs-comment">//将所有的2替换为3</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;   <span class="hljs-comment">//不是2就不变</span><br>&#125;);<br>System.out.println(list);<br></code></pre></td></tr></table></figure><h4 id="Iterable和Iterator接口"><a href="#Iterable和Iterator接口" class="headerlink" title="Iterable和Iterator接口"></a>Iterable和Iterator接口</h4><p>我们之前学习数据结构时，已经得知，不同的线性表实现，在获取元素时的效率也不同，因此我们需要一种更好地方式来统一不同数据结构的遍历。</p><p>由于ArrayList对于随机访问的速度更快，而LinkedList对于顺序访问的速度更快，因此在上述的传统for循环遍历操作中，ArrayList的效率更胜一筹，因此我们要使得LinkedList遍历效率提升，就需要采用顺序访问的方式进行遍历，如果没有迭代器帮助我们统一标准，那么我们在应对多种集合类型的时候，就需要对应编写不同的遍历算法，很显然这样会降低我们的开发效率，而迭代器的出现就帮助我们解决了这个问题。</p><p>我们先来看看迭代器里面方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个集合类都有自己的迭代器，通过<code>iterator()</code>方法来获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">Iterator&lt;Integer&gt; iterator = list.iterator();   <span class="hljs-comment">//生成一个新的迭代器</span><br><span class="hljs-keyword">while</span> (iterator.hasNext())&#123;    <span class="hljs-comment">//判断是否还有下一个元素</span><br>  Integer i = iterator.next();     <span class="hljs-comment"><code class="language-hljs java">Iterator&lt;Integer&gt; iterator = list.iterator();   <span class="hljs-comment">//生成一个新的迭代器</span><br><span class="hljs-keyword">while</span> (iterator.hasNext())&#123;    <span class="hljs-comment">//判断是否还有下一个元素</span><br>  Integer i = iterator.next();     <span class="hljs-comment">//获取下一个元素（获取一个少一个）</span><br>  System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器生成后，默认指向第一个元素，每次调用<code>next()</code>方法，都会将指针后移，当指针移动到最后一个元素之后，调用<code>hasNext()</code>将会返回<code>false</code>，迭代器是一次性的，用完即止，如果需要再次使用，需要调用<code>iterator()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">ListIterator&lt;Integer&gt; iterator = list.listIterator();   <span class="hljs-comment"><code class="language-hljs java">ListIterator&lt;Integer&gt; iterator = list.listIterator();   <span class="hljs-comment">//List还有一个更好地迭代器实现ListIterator</span><br></code></pre></td></tr></table></figure><p><code>ListIterator</code>是List中独有的迭代器，在原有迭代器基础上新增了一些额外的操作。</p><hr><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>我们之前已经看过<code>Set</code>接口的定义了，我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过使用方法上稍有不同。</p><p>Set集合特点：</p><ul><li>不允许出现重复元素</li><li>不支持随机访问（不允许通过下标访问）</li></ul><p>首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上维护的是一个HashMap，我们学习了Map之后再来讨论）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    set.add(<span class="hljs-number">120</span>);    <span class="hljs-comment">//支持插入元素，但是不支持指定位置插入</span><br>    set.add(<span class="hljs-number">13</span>);<br>    set.add(<span class="hljs-number">11</span>);<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    set.add(<span class="hljs-number">120</span>);    <span class="hljs-comment">//支持插入元素，但是不支持指定位置插入</span><br>    set.add(<span class="hljs-number">13</span>);<br>    set.add(<span class="hljs-number">11</span>);<br>    <span class="hljs-keyword">for</span> (Integer integer : set) &#123;<br>      System.out.println(integer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面代码发现，最后Set集合中存在的元素顺序，并不是我们的插入顺序，这是因为HashSet底层是采用<code>哈希表</code>来实现的，实际的存放顺序是由Hash算法决定的。</p><p>那么我们希望数据按照我们插入的顺序进行保存该怎么办呢？我们可以使用LinkedHashSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    LinkedHashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();  <span class="hljs-comment">//会自动保存我们的插入顺序</span><br>    set.add(<span class="hljs-number">120</span>);<br>    set.add(<span class="hljs-number">13</span>);<br>    set.add(<span class="hljs-number">11</span>);<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    LinkedHashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();  <span class="hljs-comment">//会自动保存我们的插入顺序</span><br>    set.add(<span class="hljs-number">120</span>);<br>    set.add(<span class="hljs-number">13</span>);<br>    set.add(<span class="hljs-number">11</span>);<br>    <span class="hljs-keyword">for</span> (Integer integer : set) &#123;<br>        System.out.println(integer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。</p><p>还有一种Set叫做TreeSet，它会在元素插入时进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number">2</span>);<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;((a, b) -&gt; b - a);   <span class="hljs-comment">//在创建对象时指定规则即可</span><br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;((a, b) -&gt; b - a);   <span class="hljs-comment">//在创建对象时指定规则即可</span><br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number">2</span>);<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在的结果就是我们自定义的排序规则了。</p><p>虽然Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。</p><hr><h3 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a>Map映射</h3><h4 id="什么是映射"><a href="#什么是映射" class="headerlink" title="什么是映射"></a>什么是映射</h4><p>我们在高中阶段其实已经学习过映射了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。</p><p><img src="https://bkimg.cdn.bcebos.com/pic/7aec54e736d12f2e89cbcbb64dc2d5628435681d?x-bce-process=image/resize,m_lfit,w_268,limit_1/format,f_jpg" alt="映射"></p><h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><p>Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系。</p><p>我们先来看看Map接口中定义了哪些操作。</p><h4 id="HashMap和LinkedHashMap"><a href="#HashMap和LinkedHashMap" class="headerlink" title="HashMap和LinkedHashMap"></a>HashMap和LinkedHashMap</h4><p>HashMap的实现过程，相比List，就非常地复杂了，它并不是简简单单的表结构，而是利用哈希表存放映射关系，我们来看看HashMap是如何实现的，首先回顾我们之前学习的哈希表，它长这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/16566539-672ab962ae6dc500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp" alt="img"></p><p>哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。</p><p>而HashMap就是采用的这种方式，我们可以看到源码中同样定义了这样的一个结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The table, initialized on first use, and resized as</span><br><span class="hljs-comment"> * necessary. When allocated, length is always a power of two.</span><br><span class="hljs-comment"> * (We also tolerate length zero in some operations to allow</span><br><span class="hljs-comment"> * bootstrapping mechanics that are currently not needed.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The table, initialized on first use, and resized as</span><br><span class="hljs-comment"> * necessary. When allocated, length is always a power of two.</span><br><span class="hljs-comment"> * (We also tolerate length zero in some operations to allow</span><br><span class="hljs-comment"> * bootstrapping mechanics that are currently not needed.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Node<K,V>[] table;<br></code></pre></td></tr></table></figure><p>这个表会在第一次使用时初始化，同时在必要时进行扩容，并且它的大小永远是2的倍数！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default initial capacity - MUST be a power of two.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default initial capacity - MUST be a power of two.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br></code></pre></td></tr></table></figure><p>我们可以看到默认的大小为2的4次方，每次都需要是2的倍数，也就是说，下一次增长之后，大小会变成2的5次方。</p><p>我们现在需要思考一个问题，当我们表中的数据不断增加之后，链表会变得越来越长，这样会严重导致查询速度变慢，首先想到办法就是，我们可以对数组的长度进行扩容，来存放更多的链表，那么什么情况下会进行扩容呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The load factor for the hash table.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The load factor for the hash table.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br></code></pre></td></tr></table></figure><p>我们还发现HashMap源码中有这样一个变量，也就是<code>负载因子</code>，那么它是干嘛的呢？</p><p>负载因子其实就是用来衡量当前情况是否需要进行扩容的标准。我们可以看到默认的负载因子是<code>0.75</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The load factor used when none specified in constructor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The load factor used when none specified in constructor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br></code></pre></td></tr></table></figure><p>那么负载因子是怎么控制扩容的呢？<code>0.75</code>的意思是，在插入新的结点后，如果当前数组的占用率达到75%则进行扩容。在扩容时，会将所有的数据，重新计算哈希值，得到一个新的下标，组成新的哈希表。</p><p>但是这样依然有一个问题，链表过长的情况还是有可能发生，所以，为了从根源上解决这个问题，在JDK1.8时，引入了红黑树这个数据结构。</p><p><img src="https://i0.hdslb.com/bfs/album/5884577601a5ab1aabe10ee95696557b8d3b5338.jpg"></p><p>当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span><br><span class="hljs-comment"> * extends Node) so can be used as extension of either regular or</span><br><span class="hljs-comment"> * linked node.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span><br><span class="hljs-comment"> * extends Node) so can be used as extension of either regular or</span><br><span class="hljs-comment"> * linked node.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>> </span>&#123;<br></code></pre></td></tr></table></figure><p>除了Node以外，HashMap还有TreeNode，很明显这就是为了实现红黑树而设计的内部类。不过我们发现，TreeNode并不是直接继承Node，而是使用了LinkedHashMap中的Entry实现，它保存了前后节点的顺序（也就是我们的插入顺序）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HashMap.Node subclass for normal LinkedHashMap entries.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    Entry&lt;K,V&gt; before, after;<br>    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HashMap.Node subclass for normal LinkedHashMap entries.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    Entry&lt;K,V&gt; before, after;<br>    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, value, next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，保存了插入顺序，这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    LinkedHashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(<span class="hljs-number">16</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-keyword">true</span>);  <span class="hljs-comment">//以访问顺序</span><br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    map.get(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    LinkedHashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(<span class="hljs-number">16</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-keyword">true</span>);  <span class="hljs-comment">//以访问顺序</span><br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    map.get(<span class="hljs-number">2</span>);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>观察结果，我们发现，刚访问的结果被排到了最后一位。</p><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap其实就是自动维护顺序的一种Map，就和我们前面提到的TreeSet一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The comparator used to maintain order in this tree map, or</span><br><span class="hljs-comment"> * null if it uses the natural ordering of its keys.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-keyword">super</span> K&gt; comparator;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Entry&lt;K,V&gt; root;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Node in the Tree.  Doubles as a means to pass key-value pairs back to</span><br><span class="hljs-comment">* user (see Map.Entry).</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The comparator used to maintain order in this tree map, or</span><br><span class="hljs-comment"> * null if it uses the natural ordering of its keys.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-keyword">super</span> K&gt; comparator;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Entry&lt;K,V&gt; root;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Node in the Tree.  Doubles as a means to pass key-value pairs back to</span><br><span class="hljs-comment">* user (see Map.Entry).</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>> </span>&#123;<br></code></pre></td></tr></table></figure><p>我们发现它的内部直接维护了一个红黑树，就像它的名字一样，就是一个Tree，因为它默认就是有序的，所以说直接采用红黑树会更好。我们在创建时，直接给予一个比较规则即可。</p><h4 id="Map的使用"><a href="#Map的使用" class="headerlink" title="Map的使用"></a>Map的使用</h4><p>我们首先来看看Map的一些基本操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    System.out.println(map.get(<span class="hljs-number">1</span>));    <span class="hljs-comment">//获取Key为1的值</span><br>    System.out.println(map.getOrDefault(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;K&quot;</span>));  <span class="hljs-comment">//不存在就返回K</span><br>   map.remove(<span class="hljs-number">1</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    System.out.println(map.get(<span class="hljs-number">1</span>));    <span class="hljs-comment">//获取Key为1的值</span><br>    System.out.println(map.getOrDefault(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;K&quot;</span>));  <span class="hljs-comment">//不存在就返回K</span><br>   map.remove(<span class="hljs-number">1</span>);   <span class="hljs-comment">//移除这个Key的键值对</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于Map并未实现迭代器接口，因此不支持foreach，但是JDK1.8为我们提供了forEach方法使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    map.forEach((k, v) -&gt; System.out.println(k+<span class="hljs-string">&quot;-&gt;&quot;</span>+v));<br>  <br>  <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;   <span class="hljs-comment">//也可以获取所有的Entry来foreach</span><br>      <span class="hljs-keyword">int</span> key = entry.getKey();<br>      String value = entry.getValue();<br>      System.out.println(key+<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    map.forEach((k, v) -&gt; System.out.println(k+<span class="hljs-string">&quot;-&gt;&quot;</span>+v));<br>  <br>  <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;   <span class="hljs-comment">//也可以获取所有的Entry来foreach</span><br>      <span class="hljs-keyword">int</span> key = entry.getKey();<br>      String value = entry.getValue();<br>      System.out.println(key+<span class="hljs-string">" -> "</span>+value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以单独获取所有的值或者是键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    System.out.println(map.keySet());   <span class="hljs-comment">//直接获取所有的key</span><br>    System.out.println(map.values());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    System.out.println(map.keySet());   <span class="hljs-comment">//直接获取所有的key</span><br>    System.out.println(map.values());   <span class="hljs-comment">//直接获取所有的值</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="再谈Set原理"><a href="#再谈Set原理" class="headerlink" title="再谈Set原理"></a>再谈Set原理</h4><p>通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br></code></pre></td></tr></table></figure><p>我们发现，在添加元素时，其实添加的是一个键为我们插入的元素，而值就是<code>PRESENT</code>常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adds the specified element to this set if it is not already present.</span><br><span class="hljs-comment"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span><br><span class="hljs-comment"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span><br><span class="hljs-comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span><br><span class="hljs-comment"> * If this set already contains the element, the call leaves the set</span><br><span class="hljs-comment"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e element to be added to this set</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span><br><span class="hljs-comment"> * element</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adds the specified element to this set if it is not already present.</span><br><span class="hljs-comment"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span><br><span class="hljs-comment"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span><br><span class="hljs-comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span><br><span class="hljs-comment"> * If this set already contains the element, the call leaves the set</span><br><span class="hljs-comment"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e element to be added to this set</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span><br><span class="hljs-comment"> * element</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察其他的方法，也几乎都是在用HashMap做事，所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！</p><p>再来看TreeSet，实际上用的就是我们的TreeMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The backing map.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The backing map.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap<E,Object> m;<br></code></pre></td></tr></table></figure><p>同理，这里就不多做阐述了。</p><h4 id="JDK1-8新增方法使用"><a href="#JDK1-8新增方法使用" class="headerlink" title="JDK1.8新增方法使用"></a>JDK1.8新增方法使用</h4><p>最后，我们再来看看JDK1.8中集合类新增的一些操作（之前没有提及的）首先来看看<code>compute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.compute(<span class="hljs-number">1</span>, (k, v) -&gt; &#123;   <span class="hljs-comment">//compute会将指定Key的值进行重新计算，若Key不存在，v会返回null</span><br>        <span class="hljs-keyword">return</span> v+<span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment">//这里返回原来的value+M</span><br>    &#125;);<br>  map.computeIfPresent(<span class="hljs-number">1</span>, (k, v) -&gt; &#123;   <span class="hljs-comment">//当Key存在时存在则计算并赋予新的值</span><br>      <span class="hljs-keyword">return</span> v+<span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.compute(<span class="hljs-number">1</span>, (k, v) -&gt; &#123;   <span class="hljs-comment">//compute会将指定Key的值进行重新计算，若Key不存在，v会返回null</span><br>        <span class="hljs-keyword">return</span> v+<span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment">//这里返回原来的value+M</span><br>    &#125;);<br>  map.computeIfPresent(<span class="hljs-number">1</span>, (k, v) -&gt; &#123;   <span class="hljs-comment">//当Key存在时存在则计算并赋予新的值</span><br>      <span class="hljs-keyword">return</span> v+<span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment">//这里返回原来的value+M</span><br>    &#125;);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用<code>computeIfAbsent</code>，当不存在Key时，计算并将键值对放入Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.computeIfAbsent(<span class="hljs-number">0</span>, (k) -&gt; &#123;   <span class="hljs-comment">//若不存在则计算并插入新的值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.computeIfAbsent(<span class="hljs-number">0</span>, (k) -&gt; &#123;   <span class="hljs-comment">//若不存在则计算并插入新的值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment">//这里返回M</span><br>    &#125;);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>merge方法用于处理数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Student&gt; students = Arrays.asList(<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">80</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">98</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">95</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">50</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">72</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">41</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">89</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">92</span>)<br>    );<br>    Map&lt;String, Integer&gt; scoreMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum));<br>    scoreMap.forEach((k, v) -&gt; System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + k + <span class="hljs-string">&quot;总分&quot;</span> + <span class="hljs-string">&quot;value:&quot;</span> + v));<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, String type, <span class="hljs-keyword">int</span> score)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.type = type;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Student&gt; students = Arrays.asList(<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">80</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">98</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">95</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">50</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">72</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">41</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">89</span>),<br>            <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">92</span>)<br>    );<br>    Map&lt;String, Integer&gt; scoreMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum));<br>    scoreMap.forEach((k, v) -&gt; System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + k + <span class="hljs-string">&quot;总分&quot;</span> + <span class="hljs-string">&quot;value:&quot;</span> + v));<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> score;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, String type, <span class="hljs-keyword">int</span> score)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.type = type;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> type;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="集合的嵌套"><a href="#集合的嵌套" class="headerlink" title="集合的嵌套"></a>集合的嵌套</h3><p>既然集合类型中的元素类型是泛型，那么能否嵌套存储呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-comment">//每一个映射都是 字符串&lt;-&gt;列表</span><br>    map.put(<span class="hljs-string">&quot;卡布奇诺今犹在&quot;</span>, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;());<br>    map.put(<span class="hljs-string">&quot;不见当年倒茶人&quot;</span>, <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-comment">//每一个映射都是 字符串&lt;-&gt;列表</span><br>    map.put(<span class="hljs-string">&quot;卡布奇诺今犹在&quot;</span>, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;());<br>    map.put(<span class="hljs-string">&quot;不见当年倒茶人&quot;</span>, <span class="hljs-keyword">new</span> LinkedList<>());<br>    System.out.println(map.keySet());<br>    System.out.println(map.values());<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Key获取到对应的值后，就是一个列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">map.get(<span class="hljs-string">&quot;卡布奇诺今犹在&quot;</span>).add(<span class="hljs-number">10</span>);<br>System.out.println(map.get(<span class="hljs-string">&quot;卡布奇诺今犹在&quot;</span>).get(<span class="hljs-number"><code class="language-hljs java">map.get(<span class="hljs-string">&quot;卡布奇诺今犹在&quot;</span>).add(<span class="hljs-number">10</span>);<br>System.out.println(map.get(<span class="hljs-string">&quot;卡布奇诺今犹在&quot;</span>).get(<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>让套娃继续下去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, Map&lt;Integer, Map&lt;Integer, String&gt;&gt;&gt; map = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, Map&lt;Integer, Map&lt;Integer, String&gt;&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap<>();<br>&#125;<br></code></pre></td></tr></table></figure><p>你也可以使用List来套娃别的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Map&lt;String, Set&lt;String&gt;&gt;&gt; list = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Map&lt;String, Set&lt;String&gt;&gt;&gt; list = <span class="hljs-keyword">new</span> LinkedList<>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流Stream和Optional的使用"><a href="#流Stream和Optional的使用" class="headerlink" title="流Stream和Optional的使用"></a>流Stream和Optional的使用</h3><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fseo-1255598498.file.myqcloud.com%2Ffull%2F723b4e9e03e9f1cbd9078f60b265e3ddc8a582aa.jpg&refer=http%3A%2F%2Fseo-1255598498.file.myqcloud.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634782830&t=8d9a60d60087bec5ce0d09b763eb3805" alt="img"></p><p>它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;C&quot;</span>);<br>  <br>  <span class="hljs-comment">//移除为B的元素</span><br>  Iterator&lt;String&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>            <span class="hljs-keyword">if</span>(iterator.next().equals(<span class="hljs-string">&quot;B&quot;</span>)) iterator.remove();<br>        &#125;<br>  <br>  <span class="hljs-comment">//Stream操作</span><br>    list = list     <span class="hljs-comment">//链式调用</span><br>            .stream()    <span class="hljs-comment">//获取流</span><br>            .filter(e -&gt; !e.equals(<span class="hljs-string">&quot;B&quot;</span>))   <span class="hljs-comment">//只允许所有不是B的元素通过流水线</span><br>            .collect(Collectors.toList());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;C&quot;</span>);<br>  <br>  <span class="hljs-comment">//移除为B的元素</span><br>  Iterator&lt;String&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>            <span class="hljs-keyword">if</span>(iterator.next().equals(<span class="hljs-string">&quot;B&quot;</span>)) iterator.remove();<br>        &#125;<br>  <br>  <span class="hljs-comment">//Stream操作</span><br>    list = list     <span class="hljs-comment">//链式调用</span><br>            .stream()    <span class="hljs-comment">//获取流</span><br>            .filter(e -&gt; !e.equals(<span class="hljs-string">&quot;B&quot;</span>))   <span class="hljs-comment">//只允许所有不是B的元素通过流水线</span><br>            .collect(Collectors.toList());   <span class="hljs-comment">//将流水线中的元素重新收集起来，变回List</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>  list.add(<span class="hljs-number">3</span>);<br><br>    list = list<br>            .stream()<br>      .distinct()   <span class="hljs-comment">//去重（使用equals判断）</span><br>            .sorted((a, b) -&gt; b - a)    <span class="hljs-comment">//进行倒序排列</span><br>            .map(e -&gt; e+<span class="hljs-number">1</span>)    <span class="hljs-comment">//每个元素都要执行+1操作</span><br>            .limit(<span class="hljs-number">2</span>)    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>  list.add(<span class="hljs-number">3</span>);<br><br>    list = list<br>            .stream()<br>      .distinct()   <span class="hljs-comment">//去重（使用equals判断）</span><br>            .sorted((a, b) -&gt; b - a)    <span class="hljs-comment">//进行倒序排列</span><br>            .map(e -&gt; e+<span class="hljs-number">1</span>)    <span class="hljs-comment">//每个元素都要执行+1操作</span><br>            .limit(<span class="hljs-number">2</span>)    <span class="hljs-comment">//只放行前两个元素</span><br>            .collect(Collectors.toList());<br><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）</p><p><strong>注意</strong>：不能认为每一步是直接依次执行的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>list.add(<span class="hljs-number">3</span>);<br><br>list = list<br>        .stream()<br>        .distinct()   <span class="hljs-comment">//断点</span><br>        .sorted((a, b) -&gt; b - a)<br>        .map(e -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>+e);   <span class="hljs-comment">//断点</span><br>            <span class="hljs-keyword">return</span> e+<span class="hljs-number">1</span>;<br>        &#125;)<br>        .limit(<span class="hljs-number">2</span>)   <span class="hljs-comment">//断点</span><br>        .collect(Collectors.toList());<br><span class="hljs-comment"><code class="language-hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>list.add(<span class="hljs-number">3</span>);<br><br>list = list<br>        .stream()<br>        .distinct()   <span class="hljs-comment">//断点</span><br>        .sorted((a, b) -&gt; b - a)<br>        .map(e -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>+e);   <span class="hljs-comment">//断点</span><br>            <span class="hljs-keyword">return</span> e+<span class="hljs-number">1</span>;<br>        &#125;)<br>        .limit(<span class="hljs-number">2</span>)   <span class="hljs-comment">//断点</span><br>        .collect(Collectors.toList());<br><span class="hljs-comment">//实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行！</span><br></code></pre></td></tr></table></figure><p>接下来，我们用一堆随机数来进行更多流操作的演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Random random = <span class="hljs-keyword">new</span> Random();  <span class="hljs-comment">//Random是一个随机数工具类</span><br>    random<br>            .ints(-<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)   <span class="hljs-comment">//生成-100~100之间的，随机int型数字（本质上是一个IntStream）</span><br>            .limit(<span class="hljs-number">10</span>)   <span class="hljs-comment">//只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！）</span><br>            .filter(i -&gt; i &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">//只保留小于0的数字</span><br>            .sorted()    <span class="hljs-comment">//默认从小到大排序</span><br>            .forEach(System.out::println);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Random random = <span class="hljs-keyword">new</span> Random();  <span class="hljs-comment">//Random是一个随机数工具类</span><br>    random<br>            .ints(-<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)   <span class="hljs-comment">//生成-100~100之间的，随机int型数字（本质上是一个IntStream）</span><br>            .limit(<span class="hljs-number">10</span>)   <span class="hljs-comment">//只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！）</span><br>            .filter(i -&gt; i &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">//只保留小于0的数字</span><br>            .sorted()    <span class="hljs-comment">//默认从小到大排序</span><br>            .forEach(System.out::println);   <span class="hljs-comment">//依次打印</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以生成一个统计实例来帮助我们快速进行统计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Random random = <span class="hljs-keyword">new</span> Random();  <span class="hljs-comment">//Random是一个随机数工具类</span><br>    IntSummaryStatistics statistics = random<br>            .ints(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>            .limit(<span class="hljs-number">100</span>)<br>            .summaryStatistics();    <span class="hljs-comment">//获取语法统计实例</span><br>    System.out.println(statistics.getMax());  <span class="hljs-comment">//快速获取最大值</span><br>    System.out.println(statistics.getCount());  <span class="hljs-comment">//获取数量</span><br>    System.out.println(statistics.getAverage());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Random random = <span class="hljs-keyword">new</span> Random();  <span class="hljs-comment">//Random是一个随机数工具类</span><br>    IntSummaryStatistics statistics = random<br>            .ints(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>            .limit(<span class="hljs-number">100</span>)<br>            .summaryStatistics();    <span class="hljs-comment">//获取语法统计实例</span><br>    System.out.println(statistics.getMax());  <span class="hljs-comment">//快速获取最大值</span><br>    System.out.println(statistics.getCount());  <span class="hljs-comment">//获取数量</span><br>    System.out.println(statistics.getAverage());   <span class="hljs-comment">//获取平均值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>    list.add(<span class="hljs-number">4</span>);<br>    list.stream()<br>            .mapToInt(i -&gt; i)    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>    list.add(<span class="hljs-number">4</span>);<br>    list.stream()<br>            .mapToInt(i -&gt; i)    <span class="hljs-comment">//将每一个元素映射为Integer类型（这里因为本来就是Integer）</span><br>            .summaryStatistics();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以通过<code>flat</code>来对整个流进行进一步细分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;A,B&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;C,D&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;E,F&quot;</span>);   <span class="hljs-comment">//我们想让每一个元素通过,进行分割，变成独立的6个元素</span><br>    list = list<br>            .stream()    <span class="hljs-comment">//生成流</span><br>            .flatMap(e -&gt; Arrays.stream(e.split(<span class="hljs-string">&quot;,&quot;</span>)))    <span class="hljs-comment">//分割字符串并生成新的流</span><br>            .collect(Collectors.toList());   <span class="hljs-comment">//汇成新的List</span><br>    System.out.println(list);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;A,B&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;C,D&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;E,F&quot;</span>);   <span class="hljs-comment">//我们想让每一个元素通过,进行分割，变成独立的6个元素</span><br>    list = list<br>            .stream()    <span class="hljs-comment">//生成流</span><br>            .flatMap(e -&gt; Arrays.stream(e.split(<span class="hljs-string">&quot;,&quot;</span>)))    <span class="hljs-comment">//分割字符串并生成新的流</span><br>            .collect(Collectors.toList());   <span class="hljs-comment">//汇成新的List</span><br>    System.out.println(list);   <span class="hljs-comment">//得到结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以只通过Stream来完成所有数字的和，使用<code>reduce</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">int</span> sum = list<br>            .stream()<br>            .reduce((a, b) -&gt; a + b)   <span class="hljs-comment">//计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和</span><br>            .get();    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">int</span> sum = list<br>            .stream()<br>            .reduce((a, b) -&gt; a + b)   <span class="hljs-comment">//计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和</span><br>            .get();    <span class="hljs-comment">//我们发现得到的是一个Optional类实例，不是我们返回的类型，通过get方法返回得到的值</span><br>    System.out.println(sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的例子，我们发现，Stream不喜欢直接给我们返回一个结果，而是通过Optinal的方式，那么什么是Optional呢？</p><p>Optional类是Java8为了解决null值判断问题，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerException）。总而言之，就是对控制的一个判断，为了避免空指针异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span>(str != <span class="hljs-keyword">null</span>)&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span>(str != <span class="hljs-keyword">null</span>)&#123;   <span class="hljs-comment">//当str不为空时添加元素到List中</span><br>        list.add(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了Optional之后，我们就可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-keyword">null</span>;<br>    Optional&lt;String&gt; optional = Optional.ofNullable(str);   <span class="hljs-comment">//转换为Optional</span><br>    optional.ifPresent(System.out::println);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-keyword">null</span>;<br>    Optional&lt;String&gt; optional = Optional.ofNullable(str);   <span class="hljs-comment">//转换为Optional</span><br>    optional.ifPresent(System.out::println);  <span class="hljs-comment">//当存在时再执行方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就类似于Kotlin中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs js"><span class="hljs-keyword">var</span> str : <span class="hljs-built_in">String</span>? = <span class="hljs-literal"><code class="language-hljs js"><span class="hljs-keyword">var</span> str : <span class="hljs-built_in">String</span>? = <span class="hljs-literal">null</span><br>str?.upperCase()<br></code></pre></td></tr></table></figure><p>我们可以选择直接get或是当值为null时，获取备选值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-keyword">null</span>;<br>    Optional optional = Optional.ofNullable(str);   <span class="hljs-comment">//转换为Optional（可空）</span><br>    System.out.println(optional.orElse(<span class="hljs-string">&quot;lbwnb&quot;</span>));<br> <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-keyword">null</span>;<br>    Optional optional = Optional.ofNullable(str);   <span class="hljs-comment">//转换为Optional（可空）</span><br>    System.out.println(optional.orElse(<span class="hljs-string">&quot;lbwnb&quot;</span>));<br> <span class="hljs-comment">// System.out.println(optional.get());   这样会直接报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，Optional也支持过滤操作和映射操作，不过是对于单对象而言：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-string">&quot;A&quot;</span>;<br>    Optional optional = Optional.ofNullable(str);   <span class="hljs-comment">//转换为Optional（可空）</span><br>    System.out.println(optional.filter(s -&gt; s.equals(<span class="hljs-string">&quot;B&quot;</span>)).get());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-string">&quot;A&quot;</span>;<br>    Optional optional = Optional.ofNullable(str);   <span class="hljs-comment">//转换为Optional（可空）</span><br>    System.out.println(optional.filter(s -&gt; s.equals(<span class="hljs-string">&quot;B&quot;</span>)).get());   <span class="hljs-comment">//被过滤了，此时元素为null，获取时报错</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    String str = <span class="hljs-string">&quot;A&quot;</span>;<br>    Optional optional = Optional.ofNullable(str);   <span class="hljs-comment">//转换为Optional（可空）</span><br>    System.out.println(optional.map(s -&gt; s + <span class="hljs-string">&quot;A&quot;</span>).get());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    String str = <span class="hljs-string">&quot;A&quot;</span>;<br>    Optional optional = Optional.ofNullable(str);   <span class="hljs-comment">//转换为Optional（可空）</span><br>    System.out.println(optional.map(s -&gt; s + <span class="hljs-string">&quot;A&quot;</span>).get());   <span class="hljs-comment">//在尾部追加一个A</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其他操作自学了解。</p><h3 id="Arrays和Collections的使用"><a href="#Arrays和Collections的使用" class="headerlink" title="Arrays和Collections的使用"></a>Arrays和Collections的使用</h3><p>Arrays是一个用于操作数组的工具类，它给我们提供了大量的工具方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This class contains various methods for manipulating arrays (such as</span><br><span class="hljs-comment"> * sorting and searching). This class also contains a static factory</span><br><span class="hljs-comment"> * that allows arrays to be viewed as lists. &lt;- 注意，这句话很关键</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Josh Bloch</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Neal Gafter</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> John Rose</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>  1.2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This class contains various methods for manipulating arrays (such as</span><br><span class="hljs-comment"> * sorting and searching). This class also contains a static factory</span><br><span class="hljs-comment"> * that allows arrays to be viewed as lists. &lt;- 注意，这句话很关键</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Josh Bloch</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Neal Gafter</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> John Rose</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>  1.2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arrays</span> </span>&#123;<br></code></pre></td></tr></table></figure><p>由于操作数组并不像集合那样方便，因此JDK提供了Arrays类来增强对数组操作，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    Arrays.sort(array);   <span class="hljs-comment">//直接进行排序（底层原理：进行判断，元素少使用插入排序，大量元素使用双轴快速/归并排序）</span><br>    System.out.println(array);  <span class="hljs-comment">//由于int[]是一个对象类型，而数组默认是没有重写toString()方法，因此无法打印到想要的结果</span><br>    System.out.println(Arrays.toString(array));  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    Arrays.sort(array);   <span class="hljs-comment">//直接进行排序（底层原理：进行判断，元素少使用插入排序，大量元素使用双轴快速/归并排序）</span><br>    System.out.println(array);  <span class="hljs-comment">//由于int[]是一个对象类型，而数组默认是没有重写toString()方法，因此无法打印到想要的结果</span><br>    System.out.println(Arrays.toString(array));  <span class="hljs-comment">//我们可以使用Arrays.toString()来像集合一样直接打印每一个元素出来</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    Arrays.sort(array);<br>    System.out.println(<span class="hljs-string">&quot;排序后的结果：&quot;</span>+Arrays.toString(array));<br>    System.out.println(<span class="hljs-string">&quot;目标元素3位置为：&quot;</span>+Arrays.binarySearch(array, <span class="hljs-number">3</span>));  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    Arrays.sort(array);<br>    System.out.println(<span class="hljs-string">&quot;排序后的结果：&quot;</span>+Arrays.toString(array));<br>    System.out.println(<span class="hljs-string">&quot;目标元素3位置为：&quot;</span>+Arrays.binarySearch(array, <span class="hljs-number">3</span>));  <span class="hljs-comment">//二分搜素，必须是已经排序好的数组！</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    Arrays<br>            .stream(array)    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    Arrays<br>            .stream(array)    <span class="hljs-comment">//将数组转换为流进行操作</span><br>            .sorted()<br>            .forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] array2 = Arrays.copyOf(array, array.length);  <span class="hljs-comment">//复制一个一模一样的数组</span><br>    System.out.println(Arrays.toString(array2));<br><br>    System.out.println(Arrays.equals(array, array2));  <span class="hljs-comment">//比较两个数组是否值相同</span><br><br>    Arrays.fill(array, <span class="hljs-number">0</span>);   <span class="hljs-comment">//将数组的所有值全部填充为指定值</span><br>    System.out.println(Arrays.toString(array));<br><br>    Arrays.setAll(array2, i -&gt; array2[i] + <span class="hljs-number">2</span>);  <span class="hljs-comment">//依次计算每一个元素（注意i是下标位置）</span><br>    System.out.println(Arrays.toString(array2));   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] array2 = Arrays.copyOf(array, array.length);  <span class="hljs-comment">//复制一个一模一样的数组</span><br>    System.out.println(Arrays.toString(array2));<br><br>    System.out.println(Arrays.equals(array, array2));  <span class="hljs-comment">//比较两个数组是否值相同</span><br><br>    Arrays.fill(array, <span class="hljs-number">0</span>);   <span class="hljs-comment">//将数组的所有值全部填充为指定值</span><br>    System.out.println(Arrays.toString(array));<br><br>    Arrays.setAll(array2, i -&gt; array2[i] + <span class="hljs-number">2</span>);  <span class="hljs-comment">//依次计算每一个元素（注意i是下标位置）</span><br>    System.out.println(Arrays.toString(array2));   <span class="hljs-comment">//这里计算让每个元素值+2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>思考：当二维数组使用<code>Arrays.equals()</code>进行比较以及<code>Arrays.toString()</code>进行打印时，还会得到我们想要的结果吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer[][] array = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">6</span>&#125;&#125;;<br>    Integer[][] array2 = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">6</span>&#125;&#125;;<br>    System.out.println(Arrays.toString(array));    <span class="hljs-comment">//这样还会得到我们想要的结果吗？</span><br>    System.out.println(Arrays.equals(array2, array));    <span class="hljs-comment">//这样还会得到true吗？</span><br><br>    System.out.println(Arrays.deepToString(array));   <span class="hljs-comment">//使用deepToString就能到打印多维数组</span><br>    System.out.println(Arrays.deepEquals(array2, array));   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer[][] array = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">6</span>&#125;&#125;;<br>    Integer[][] array2 = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">6</span>&#125;&#125;;<br>    System.out.println(Arrays.toString(array));    <span class="hljs-comment">//这样还会得到我们想要的结果吗？</span><br>    System.out.println(Arrays.equals(array2, array));    <span class="hljs-comment">//这样还会得到true吗？</span><br><br>    System.out.println(Arrays.deepToString(array));   <span class="hljs-comment">//使用deepToString就能到打印多维数组</span><br>    System.out.println(Arrays.deepEquals(array2, array));   <span class="hljs-comment">//使用deepEquals就能比较多维数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么，一开始提到的当做List进行操作呢？我们可以使用<code>Arrays.asList()</code>来将数组转换为一个 <strong>固定长度的List</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    List&lt;Integer&gt; list = Arrays.asList(array);   <span class="hljs-comment">//不支持基本类型数组，必须是对象类型数组</span><br>    Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);  <span class="hljs-comment">//也可以逐个添加，因为是可变参数</span><br><br>    list.add(<span class="hljs-number">1</span>);    <span class="hljs-comment">//此List实现是长度固定的，是Arrays内部单独实现的一个类型，因此不支持添加操作</span><br>    list.remove(<span class="hljs-number">0</span>);   <span class="hljs-comment">//同理，也不支持移除</span><br><br>    list.set(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>);   <span class="hljs-comment">//直接设置指定下标的值就可以</span><br>    list.sort(Comparator.reverseOrder());   <span class="hljs-comment">//也可以执行排序操作</span><br>    System.out.println(list);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    List&lt;Integer&gt; list = Arrays.asList(array);   <span class="hljs-comment">//不支持基本类型数组，必须是对象类型数组</span><br>    Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);  <span class="hljs-comment">//也可以逐个添加，因为是可变参数</span><br><br>    list.add(<span class="hljs-number">1</span>);    <span class="hljs-comment">//此List实现是长度固定的，是Arrays内部单独实现的一个类型，因此不支持添加操作</span><br>    list.remove(<span class="hljs-number">0</span>);   <span class="hljs-comment">//同理，也不支持移除</span><br><br>    list.set(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>);   <span class="hljs-comment">//直接设置指定下标的值就可以</span><br>    list.sort(Comparator.reverseOrder());   <span class="hljs-comment">//也可以执行排序操作</span><br>    System.out.println(list);   <span class="hljs-comment">//也可以像List那样直接打印</span><br>&#125;<br></code></pre></td></tr></table></figure><p>文字游戏：<code>allows arrays to be viewed as lists</code>，实际上只是当做List使用，本质还是数组，因此数组的属性依然存在！因此如果要将数组快速转换为实际的List，可以像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList<>(Arrays.asList(array));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过自行创建一个真正的ArrayList并在构造时将Arrays的List值传递。</p><p>既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList<>();<br>    Collections.max(list);<br>    Collections.min(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，Collections提供的内容相比Arrays会更多，希望大家下去自行了解，这里就不多做介绍了。</p><hr><h2 id="集合类编程实战"><a href="#集合类编程实战" class="headerlink" title="集合类编程实战"></a>集合类编程实战</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>1 &lt;- 3 &lt;- 5 &lt;- 7 &lt;- 9  转换为 1 &lt;- 3 &lt;- 5 &lt;- 7 &lt;- 9</p><p>现在有一个单链表，尝试将其所有节点倒序排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Node head = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);<br>        head.next = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">3</span>);<br>        head.next.next = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">5</span>);<br>        head.next.next.next = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">7</span>);<br>        head.next.next.next.next = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">9</span>);<br><br>        head = reverse(head);<br><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;<br>            System.out.println(head.value+<span class="hljs-string">&quot; &quot;</span>);<br>            head = head.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;<br>        <span class="hljs-keyword">public</span> Node next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.value = data;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverse</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Node head = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);<br>        head.next = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">3</span>);<br>        head.next.next = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">5</span>);<br>        head.next.next.next = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">7</span>);<br>        head.next.next.next.next = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">9</span>);<br><br>        head = reverse(head);<br><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;<br>            System.out.println(head.value+<span class="hljs-string">&quot; &quot;</span>);<br>            head = head.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;<br>        <span class="hljs-keyword">public</span> Node next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.value = data;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">reverse</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        <span class="hljs-comment">//在这里实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><p>现在知道二叉树的前序: GDAFEMHZ，以及中序: ADEFGHMZ，请根据已知信息还原这颗二叉树。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTEwMTExNTE3NDcx?x-oss-process=image/format,png" alt="这里写图片描述"></p><h3 id="实现计算器"><a href="#实现计算器" class="headerlink" title="实现计算器"></a>实现计算器</h3><p>实现一个计算器，要求输入一个计算公式（含加减乘除运算符，没有负数但是有小数），得到结果，比如输入：1+4*3/1.321，得到结果为：2.2</p><h3 id="字符串匹配（KMP算法）"><a href="#字符串匹配（KMP算法）" class="headerlink" title="字符串匹配（KMP算法）"></a>字符串匹配（KMP算法）</h3><p>现在给定一个主字符串和一个子字符串，请判断主字符串是否包含子字符串，例如主字符串：ABCABCDHI，子字符串：ABCD，因此主字符串包含此子字符串；主字符串：ABCABCUISA，子字符串：ABCD，则不包含。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常机制</title>
      <link href="/2022/02/23/3.html/"/>
      <url>/2022/02/23/3.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Java异常机制"><a href="#Java异常机制" class="headerlink" title="Java异常机制"></a>Java异常机制</h1><p>在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);   <span class="hljs-comment">//当b为0的时候，还能正常运行吗？</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a/b;   <span class="hljs-comment">//没有任何的判断而是直接做计算</span><br>&#125;<br><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero<br>at com.test.Application.test(Application.java:<span class="hljs-number">9</span>)<br>at com.test.Application.main(Application.java:<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);   <span class="hljs-comment">//当b为0的时候，还能正常运行吗？</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a/b;   <span class="hljs-comment">//没有任何的判断而是直接做计算</span><br>&#125;<br><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero<br>at com.test.Application.test(Application.java:<span class="hljs-number">9</span>)<br>at com.test.Application.main(Application.java:<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自<code>Exception</code>类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！</p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。所有的运行时异常都继承自<code>RuntimeException</code>。</p><h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>异常的另一种类型是编译时异常，编译时异常是明确会出现的异常，在编译阶段就需要进行处理的异常（捕获异常）如果不进行处理，将无法通过编译！默认继承自<code>Exception</code>类的异常都是编译时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;my.txt&quot;</span>);<br>file.createNewFile();   <span class="hljs-comment"><code class="language-hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;my.txt&quot;</span>);<br>file.createNewFile();   <span class="hljs-comment">//要调用此方法，首先需要处理异常</span><br></code></pre></td></tr></table></figure><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如<code>OutOfMemoryError</code>就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Integer.MAX_VALUE];   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Integer.MAX_VALUE];   <span class="hljs-comment">//能创建如此之大的数组吗？</span><br></code></pre></td></tr></table></figure><p>运行后得到以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Requested array size exceeds VM limit<br>at com.test.Main.main(Main.java:<span class="hljs-number"><code class="language-hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Requested array size exceeds VM limit<br>at com.test.Main.main(Main.java:<span class="hljs-number">14</span>)<br></code></pre></td></tr></table></figure><p>错误都继承自<code>Error</code>类，一般情况下，程序中只能处理异常，错误是很难进行处理的，<code>Error</code>和<code>Execption</code>都继承自<code>Throwable</code>类。当程序中出现错误或异常时又没有进行处理时，程序（当前线程）将终止运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Integer.MAX_VALUE];<br>System.out.println(<span class="hljs-string">&quot;lbwnb&quot;</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Integer.MAX_VALUE];<br>System.out.println(<span class="hljs-string">&quot;lbwnb&quot;</span>);  <span class="hljs-comment">//还能正常打印吗？</span><br></code></pre></td></tr></table></figure><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>当程序没有按照我们想要的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息），我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];<br>arr[<span class="hljs-number">5</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">//我们需要处理这种情况，保证后面的代码正常运行！</span><br>System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];<br>arr[<span class="hljs-number">5</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">//我们需要处理这种情况，保证后面的代码正常运行！</span><br>System.out.println(<span class="hljs-string">"lbwnb"</span>);<br></code></pre></td></tr></table></figure><p>我们可以使用<code>try</code>和<code>catch</code>语句块来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">try</span>&#123;    <span class="hljs-comment">//在try块中运行代码</span><br>     arr[<span class="hljs-number">5</span>] = <span class="hljs-number">1</span>;    <span class="hljs-comment">//当代码出现异常时，异常会被捕获，并在catch块中得到异常类型的对象</span><br>&#125;<span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e)&#123;   <span class="hljs-comment">//捕获的异常类型</span><br>     System.out.println(<span class="hljs-string">&quot;程序运行出现异常！&quot;</span>);  <span class="hljs-comment">//出现异常时执行</span><br>&#125;<br><span class="hljs-comment">//后面的代码会正常运行</span><br>System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">try</span>&#123;    <span class="hljs-comment">//在try块中运行代码</span><br>     arr[<span class="hljs-number">5</span>] = <span class="hljs-number">1</span>;    <span class="hljs-comment">//当代码出现异常时，异常会被捕获，并在catch块中得到异常类型的对象</span><br>&#125;<span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e)&#123;   <span class="hljs-comment">//捕获的异常类型</span><br>     System.out.println(<span class="hljs-string">&quot;程序运行出现异常！&quot;</span>);  <span class="hljs-comment">//出现异常时执行</span><br>&#125;<br><span class="hljs-comment">//后面的代码会正常运行</span><br>System.out.println(<span class="hljs-string">"lbwnb"</span>);<br></code></pre></td></tr></table></figure><p>当异常被捕获后，就由我们自己进行处理（不再交给JVM处理），因此就不会导致程序终止运行。</p><p>我们可以通过使用<code>e.printStackTrace()</code>来打印栈追踪信息，定位我们的异常出现位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">java.lang.ArrayIndexOutOfBoundsException: <span class="hljs-number">5</span><br>at com.test.Main.main(Main.java:<span class="hljs-number">7</span>)    <span class="hljs-comment"><code class="language-hljs java">java.lang.ArrayIndexOutOfBoundsException: <span class="hljs-number">5</span><br>at com.test.Main.main(Main.java:<span class="hljs-number">7</span>)    <span class="hljs-comment">//Main类的第7行出现问题</span><br>程序运行出现异常！<br>lbwnb<br></code></pre></td></tr></table></figure><p>运行时异常在编译时可以不用捕获，但是编译时异常必须进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;my.txt&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>  file.createNewFile();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <span class="hljs-comment"><code class="language-hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;my.txt&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>  file.createNewFile();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <span class="hljs-comment">//捕获声明的异常类型</span><br>  e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以捕获到类型不止是<code>Exception</code>的子类，只要是继承自<code>Throwalbe</code>的类，都能被捕获，也就是说，<code>Error</code>也能被捕获，但是不建议这样做，因为错误一般是虚拟机相关的问题，出现<code>Error</code>应该从问题的根源去解决。</p><h2 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h2><p>当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就需要手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;   <span class="hljs-comment">//捕获方法中会出现的异常</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//声明抛出的异常类型</span><br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;0不能做除数！&quot;</span>);  <span class="hljs-comment">//创建异常对象并抛出异常</span><br>        <span class="hljs-keyword">return</span> a/b;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;   <span class="hljs-comment">//捕获方法中会出现的异常</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//声明抛出的异常类型</span><br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;0不能做除数！&quot;</span>);  <span class="hljs-comment">//创建异常对象并抛出异常</span><br>        <span class="hljs-keyword">return</span> a/b;  <span class="hljs-comment">//抛出异常会终止代码运行</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>通过<code>throw</code>关键字抛出异常（抛出异常后，后面的代码不再执行）当程序运行到这一行时，就会终止执行，并出现一个异常。</p><p>如果方法中抛出了非运行时异常，但是不希望在此方法内处理，而是交给调用者来处理异常，就需要在方法定义后面显式声明抛出的异常类型！如果抛出的是运行时异常，则不需要在方法后面声明异常类型，调用时也无需捕获，但是出现异常时同样会导致程序终止（出现运行时异常同时未被捕获会默认交给JVM处理，也就是直接中止程序并在控制台打印栈追踪信息）</p><p>如果想要调用声明编译时异常的方法，但是依然不想去处理，可以同样的在方法上声明<code>throws</code>来继续交给上一级处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//出现异常就再往上抛，而不是在此方法内处理</span><br>  test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//声明抛出的异常类型</span><br>  <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;0不能做除数！&quot;</span>);  <span class="hljs-comment">//创建异常对象并抛出异常      </span><br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//出现异常就再往上抛，而不是在此方法内处理</span><br>  test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//声明抛出的异常类型</span><br>  <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;0不能做除数！&quot;</span>);  <span class="hljs-comment">//创建异常对象并抛出异常      </span><br>  <span class="hljs-keyword">return</span> a/b;  <br>&#125;<br></code></pre></td></tr></table></figure><p>当main方法都声明抛出异常时，出现异常就由JVM进行处理，也就是默认的处理方式（直接中止程序并在控制台打印栈追踪信息）</p><p>异常只能被捕获一次，当异常捕获出现嵌套时，只会在最内层被捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;外层&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;0不能做除数！&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;内层&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;外层&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;0不能做除数！&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;内层&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a/b;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>JDK为我们已经提前定义了一些异常了，但是可能对我们来说不够，那么就需要自定义异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;  <span class="hljs-comment">//直接继承即可</span><br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MyException </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;  <span class="hljs-comment">//直接继承即可</span><br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MyException </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException();   <span class="hljs-comment">//直接使用</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>也可以使用父类的带描述的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span><span class="hljs-params">(String message)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MyException </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span><span class="hljs-params">(String message)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MyException </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException(<span class="hljs-string">"出现了自定义的错误"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>捕获异常指定的类型，会捕获其所有子异常类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException(<span class="hljs-string">&quot;出现了自定义的错误&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-comment">//捕获父异常类型</span><br>  System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException(<span class="hljs-string">&quot;出现了自定义的错误&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-comment">//捕获父异常类型</span><br>  System.out.println(<span class="hljs-string">"捕获到异常"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多重异常捕获和finally关键字"><a href="#多重异常捕获和finally关键字" class="headerlink" title="多重异常捕获和finally关键字"></a>多重异常捕获和finally关键字</h2><p>当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>            <br>&#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e)&#123;<br><br>&#125; <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>            <br>&#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e)&#123;<br><br>&#125; <span class="hljs-keyword">catch</span> (RuntimeException e)&#123;<br>            <br>&#125;<br></code></pre></td></tr></table></figure><p>注意，类似于<code>if-else if</code>的结构，父异常类型只能放在最后！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (RuntimeException e)&#123;  <span class="hljs-comment">//父类型在前，会将子类的也捕获</span><br><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;   <span class="hljs-comment">//永远都不会被捕获</span><br><br>&#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e)&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (RuntimeException e)&#123;  <span class="hljs-comment">//父类型在前，会将子类的也捕获</span><br><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;   <span class="hljs-comment">//永远都不会被捕获</span><br><br>&#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e)&#123;   <span class="hljs-comment">//永远都不会被捕获</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望把这些异常放在一起进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException | IndexOutOfBoundsException e) &#123;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException | IndexOutOfBoundsException e) &#123;  <span class="hljs-comment">//用|隔开每种类型即可</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>当我们希望，程序运行时，无论是否出现异常，都会在最后执行的任务，可以交给<code>finally</code>语句块来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>  System.out.println(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>  System.out.println(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//无论是否出现异常，都会在最后执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>try</code>语句块至少要配合<code>catch</code>或<code>finally</code>中的一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    a /= <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">finally</span> &#123;  <span class="hljs-comment">//不捕获异常，程序会终止，但在最后依然会执行下面的内容</span><br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    a /= <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">finally</span> &#123;  <span class="hljs-comment">//不捕获异常，程序会终止，但在最后依然会执行下面的内容</span><br>    System.out.println(<span class="hljs-string">"lbwnb"</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>思考：<code>try</code>、<code>catch</code>和<code>finally</code>执行顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>  <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<span class="hljs-keyword">finally</span> &#123;<br>    a =  a + <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>  <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<span class="hljs-keyword">finally</span> &#123;<br>    a =  a + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Java泛型与集合类"><a href="#Java泛型与集合类" class="headerlink" title="Java泛型与集合类"></a>Java泛型与集合类</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="利用代码块来快速添加内容"><a href="#利用代码块来快速添加内容" class="headerlink" title="利用代码块来快速添加内容"></a>利用代码块来快速添加内容</h2><h1 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h1><h2 id="try-with-resourse"><a href="#try-with-resourse" class="headerlink" title="try-with-resourse"></a>try-with-resourse</h2><h1 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h1><h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><h2 id="详谈类加载机制"><a href="#详谈类加载机制" class="headerlink" title="详谈类加载机制"></a>详谈类加载机制</h2><h1 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h1>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对象和多态 （面向对象）</title>
      <link href="/2022/02/21/1.html/"/>
      <url>/2022/02/21/1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Java对象和多态-（面向对象）"><a href="#Java对象和多态-（面向对象）" class="headerlink" title="Java对象和多态 （面向对象）"></a>Java对象和多态 （面向对象）</h1><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><p>面向对象程序设计(Object Oriented Programming)</p><p>对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String str = sc.nextLine();<br>System.out.println(<span class="hljs-string"><code class="language-hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String str = sc.nextLine();<br>System.out.println(<span class="hljs-string">"你输入了："</span>+str);<br>sc.close();<br></code></pre></td></tr></table></figure><p>所有的对象，都需要通过<code>new</code>关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！</p><p>不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论）</p><p>对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！</p><hr><h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a>类的基本结构</h2><p>为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过<code>.</code>来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    test.name = <span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    test.name = <span class="hljs-string">"奥利给"</span>;<br>    System.out.println(test.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>成员变量默认带有初始值，也可以自己定义初始值。</p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>我们之前的学习中接触过方法(Method)吗？主方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//Body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p><h4 id="方法的定义和使用"><a href="#方法的定义和使用" class="headerlink" title="方法的定义和使用"></a>方法的定义和使用</h4><p>在类中，我们可以定义自己的方法，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">[返回值类型] 方法名称([参数])&#123;<br>  <span class="hljs-comment">//方法体</span><br>  <span class="hljs-keyword"><code class="language-hljs java">[返回值类型] 方法名称([参数])&#123;<br>  <span class="hljs-comment">//方法体</span><br>  <span class="hljs-keyword">return</span> 结果;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值</li><li>方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！</li><li>参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法</li><li>方法体：方法具体要干的事情</li><li>结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return）</li></ul><p>非void方法中，<code>return</code>关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//缺少retrun语句！</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//缺少retrun语句！</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>return</code>也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>       <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//在循环内返回了！和break区别？</span><br>   &#125;<br>   System.out.println(<span class="hljs-string">&quot;淦&quot;</span>);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>       <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//在循环内返回了！和break区别？</span><br>   &#125;<br>   System.out.println(<span class="hljs-string">&quot;淦&quot;</span>);   <span class="hljs-comment">//还会到这里吗？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">new</span> Test().swap(a, b);<br>  System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string">&quot;, b=&quot;</span>+b);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;  <span class="hljs-comment">//传递的仅仅是值而已！</span><br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">new</span> Test().swap(a, b);<br>  System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string">&quot;, b=&quot;</span>+b);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;  <span class="hljs-comment">//传递的仅仅是值而已！</span><br>  <span class="hljs-keyword">int</span> temp = a;<br>  a = b;<br> b = temp;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br> String name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(B b)</span></span>&#123;  <span class="hljs-comment">//传递的是对象的引用，而不是值</span><br>    System.out.println(b.name);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  B b = <span class="hljs-keyword">new</span> B();<br>  b.name = <span class="hljs-string">&quot;lbw&quot;</span>;<br>  <span class="hljs-keyword">new</span> A().test(b);<br>  System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br> String name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(B b)</span></span>&#123;  <span class="hljs-comment">//传递的是对象的引用，而不是值</span><br>    System.out.println(b.name);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>  B b = <span class="hljs-keyword">new</span> B();<br>  b.name = <span class="hljs-string">&quot;lbw&quot;</span>;<br>  <span class="hljs-keyword">new</span> A().test(b);<br>  System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a+<span class="hljs-string">", b="</span>+b);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法之间可以相互调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//xxxx</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//xxxx</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;<br>  a();<br>&#125;<br></code></pre></td></tr></table></figure><p>当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> a();<br>&#125;<br></code></pre></td></tr></table></figure><p>成员方法和成员变量一样，是属于对象的，只能通过对象去调用！</p><hr><h3 id="对象设计练习"><a href="#对象设计练习" class="headerlink" title="对象设计练习"></a>对象设计练习</h3><ul><li>学生应该具有以下属性：名字、年龄</li><li>学生应该具有以下行为：学习、运动、说话</li></ul><hr><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//原本的方法</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，形参不同</span><br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，返回类型和形参都不同</span><br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//原本的方法</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，形参不同</span><br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> i)</span></span>&#123;  <span class="hljs-comment">//ok，返回类型和形参都不同</span><br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//错误，仅返回值类型名称不同不能重载</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;   <span class="hljs-comment">//只有int支持，不灵活！</span><br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>&#123;  <span class="hljs-comment">//重写一个double类型的，就支持小数计算了</span><br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;   <span class="hljs-comment">//只有int支持，不灵活！</span><br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>&#123;  <span class="hljs-comment">//重写一个double类型的，就支持小数计算了</span><br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了int&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">short</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了short&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">long</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了long&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">char</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了char&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了double&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">float</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了float&quot;</span>);<br>    &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        test.a(<span class="hljs-number">1</span>);   <span class="hljs-comment">//直接输入整数</span><br>        test.a(<span class="hljs-number">1.0</span>);  <span class="hljs-comment">//直接输入小数</span><br><br>        <span class="hljs-keyword">short</span> s = <span class="hljs-number">2</span>;<br>        test.a(s);  <span class="hljs-comment">//会对号入座吗？</span><br>        test.a(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了int&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">short</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了short&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">long</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了long&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">char</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了char&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了double&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">float</span> i)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了float&quot;</span>);<br>    &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        test.a(<span class="hljs-number">1</span>);   <span class="hljs-comment">//直接输入整数</span><br>        test.a(<span class="hljs-number">1.0</span>);  <span class="hljs-comment">//直接输入小数</span><br><br>        <span class="hljs-keyword">short</span> s = <span class="hljs-number">2</span>;<br>        test.a(s);  <span class="hljs-comment">//会对号入座吗？</span><br>        test.a(<span class="hljs-number">1.0F</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//反编译结果</span><br><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//反编译结果</span><br><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译其实就是把我们编译好的class文件变回Java源代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Test test = <span class="hljs-keyword">new</span> Test();  <span class="hljs-comment">//实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的</span><br><span class="hljs-comment"><code class="language-hljs java">Test test = <span class="hljs-keyword">new</span> Test();  <span class="hljs-comment">//实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的</span><br><span class="hljs-comment">// new + 你想要使用的构造方法</span><br></code></pre></td></tr></table></figure><p>这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！</p><p>类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！</p><p>一般最常用的就是给成员属性赋初始值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    <br>    Student()&#123;<br>        name = <span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    <br>    Student()&#123;<br>        name = <span class="hljs-string">"伞兵一号"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student(String name)&#123;   <span class="hljs-comment">//形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！</span><br>        <span class="hljs-keyword">this</span>.name = name;  <span class="hljs-comment">//通过this指代当前的对象属性，this就代表当前对象</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student(String name)&#123;   <span class="hljs-comment">//形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！</span><br>        <span class="hljs-keyword">this</span>.name = name;  <span class="hljs-comment">//通过this指代当前的对象属性，this就代表当前对象</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//idea 右键快速生成！</span><br></code></pre></td></tr></table></figure><p>注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。</p><p>在我们定义了新的有参构造之后，默认的无参构造会被覆盖！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//反编译后依然只有我们定义的有参构造！</span><br></code></pre></td></tr></table></figure><p>如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student()&#123;<br><br>    &#125;<br><br>    Student(String name)&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br><br>    Student()&#123;<br><br>    &#125;<br><br>    Student(String name)&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成员变量的初始化始终在构造方法执行之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String a = <span class="hljs-string">&quot;sadasa&quot;</span>;<br><br>    Student()&#123;<br>        System.out.println(a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String a = <span class="hljs-string">&quot;sadasa&quot;</span>;<br><br>    Student()&#123;<br>        System.out.println(a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><p>静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Student s1 = <span class="hljs-keyword">new</span> Student();<br>s1.a = <span class="hljs-number">10</span>;<br>Student s2 = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Student s1 = <span class="hljs-keyword">new</span> Student();<br>s1.a = <span class="hljs-number">10</span>;<br>Student s2 = <span class="hljs-keyword">new</span> Student();<br>System.out.println(s2.a);<br>&#125;<br></code></pre></td></tr></table></figure><p>不推荐使用对象来调用，被标记为静态的内容，可以直接通过<code>类名.xxx</code>的形式访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   Student.a = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   Student.a = <span class="hljs-number">10</span>;<br>   System.out.println(Student.a);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="简述类加载机制"><a href="#简述类加载机制" class="headerlink" title="简述类加载机制"></a>简述类加载机制</h4><p>类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new 创建类的实例（隐式加载）</li><li>调用类的静态方法</li><li>子类初始化时</li><li>其他的情况会在讲到反射时介绍</li></ul><p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();  <span class="hljs-comment">//直接调用静态方法，只能调用静态方法</span><br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string">&quot;构造类对象&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//静态方法刚加载时就有了</span><br>        System.out.println(<span class="hljs-string">&quot;初始化变量a&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();  <span class="hljs-comment">//直接调用静态方法，只能调用静态方法</span><br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string">&quot;构造类对象&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//静态方法刚加载时就有了</span><br>        System.out.println(<span class="hljs-string">&quot;初始化变量a&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = test();<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Student.a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0</p><h3 id="代码块和静态代码块"><a href="#代码块和静态代码块" class="headerlink" title="代码块和静态代码块"></a>代码块和静态代码块</h3><p>代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是代码块&quot;</span>);<br>    &#125;<br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是代码块&quot;</span>);<br>    &#125;<br><br>    Student()&#123;<br>        System.out.println(<span class="hljs-string">"我是构造方法"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        a = <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        a = <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Student.a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="String和StringBuilder类"><a href="#String和StringBuilder类" class="headerlink" title="String和StringBuilder类"></a>String和StringBuilder类</h3><p>字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例)</p><p>String的对象直接支持使用<code>+</code>或<code>+=</code>运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java">String a = <span class="hljs-string">&quot;dasdsa&quot;</span>, b = <span class="hljs-string"><code class="language-hljs java">String a = <span class="hljs-string">&quot;dasdsa&quot;</span>, b = <span class="hljs-string">"dasdasdsa"</span>;<br>String l = a+b;<br>System.out.println(l);<br></code></pre></td></tr></table></figure><p>大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">String result=<span class="hljs-string">&quot;String&quot;</span>+<span class="hljs-string">&quot;and&quot;</span>; <span class="hljs-comment"><code class="language-hljs java">String result=<span class="hljs-string">&quot;String&quot;</span>+<span class="hljs-string">&quot;and&quot;</span>; <span class="hljs-comment">//会被优化成一句！</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=str1+str2;<br><span class="hljs-comment"><code class="language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=str1+str2;<br><span class="hljs-comment">//变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=(<span class="hljs-keyword">new</span> StringBuilder(String.valueOf(str1))).append(str2).toString();<br><span class="hljs-comment"><code class="language-hljs java">String str1=<span class="hljs-string">&quot;String&quot;</span>;<br>String str2=<span class="hljs-string">&quot;and&quot;</span>;<br>String result=(<span class="hljs-keyword">new</span> StringBuilder(String.valueOf(str1))).append(str2).toString();<br><span class="hljs-comment">//使用StringBuilder，会采用类似于第一种实现，显然会更快！</span><br></code></pre></td></tr></table></figure><p>StringBuilder也是一个类，但是它能够存储可变长度的字符串！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>builder<br>       .append(<span class="hljs-string">&quot;a&quot;</span>)<br>       .append(<span class="hljs-string">&quot;bc&quot;</span>)<br>       .append(<span class="hljs-string">&quot;d&quot;</span>);   <span class="hljs-comment"><code class="language-hljs java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>builder<br>       .append(<span class="hljs-string">&quot;a&quot;</span>)<br>       .append(<span class="hljs-string">&quot;bc&quot;</span>)<br>       .append(<span class="hljs-string">&quot;d&quot;</span>);   <span class="hljs-comment">//链式调用</span><br>String str = builder.toString();<br>System.out.println(str);<br></code></pre></td></tr></table></figure><hr><h2 id="包和访问控制"><a href="#包和访问控制" class="headerlink" title="包和访问控制"></a>包和访问控制</h2><h3 id="包声明和导入"><a href="#包声明和导入" class="headerlink" title="包声明和导入"></a>包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。</p><p>一般包按照个人或是公司域名的规则倒过来写 <code>顶级域名.一级域名.二级域名</code> <code>com.java.xxxx</code></p><p>如果需要使用其他包里面的类，那么我们需要<code>import</code>（类似于C/C++中的include）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">import</span> com.test.Student;<br></code></pre></td></tr></table></figure><p>也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">import</span> com.test.*<br></code></pre></td></tr></table></figure><p>Java默认为我们导入了以下的包，不需要去声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">import</span> java.lang.*<br></code></pre></td></tr></table></figure><h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><p>静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.test.ui.Student.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.test.ui.Student.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态导入不会进行类的初始化！</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。</p><p>![image-20210819160939950](/Users/nagocoler/Library/Application Support/typora-user-images/image-20210819160939950.png)</p><p>权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//具有私有访问权限，只能类内部访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    System.out.println(s.a);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//具有私有访问权限，只能类内部访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    System.out.println(s.a);  <span class="hljs-comment">//还可以访问吗？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// Student.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">// Student.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;   <span class="hljs-comment">//不能添加权限修饰符！只能是default</span><br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&refer=http%3A%2F%2Fimgs.itxueyuan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632192902&t=7a6d67fc01d0e3ea7816adf951c49605" alt="img"></p><p>我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];  <span class="hljs-comment">//需要new关键字来创建！</span><br>String[] arr2 = <span class="hljs-keyword">new</span> String[<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];  <span class="hljs-comment">//需要new关键字来创建！</span><br>String[] arr2 = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>数组本身也是类（编程不可见，C++写的），不是基本数据类型！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>System.out.println(arr.length);   <span class="hljs-comment">//数组有成员变量！</span><br>System.out.println(arr.toString());   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>System.out.println(arr.length);   <span class="hljs-comment">//数组有成员变量！</span><br>System.out.println(arr.toString());   <span class="hljs-comment">//数组有成员方法！</span><br></code></pre></td></tr></table></figure><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[数组大小];<br>类型 变量名称n = <span class="hljs-keyword">new</span> 类型[数组大小];  <span class="hljs-comment">//支持C语言样式，但不推荐！</span><br><br>类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[]&#123;...&#125;;  <span class="hljs-comment">//静态初始化（直接指定值和大小）</span><br>类型[] 变量名称 = &#123;...&#125;;   <span class="hljs-comment"><code class="language-hljs java">类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[数组大小];<br>类型 变量名称n = <span class="hljs-keyword">new</span> 类型[数组大小];  <span class="hljs-comment">//支持C语言样式，但不推荐！</span><br><br>类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[]&#123;...&#125;;  <span class="hljs-comment">//静态初始化（直接指定值和大小）</span><br>类型[] 变量名称 = &#123;...&#125;;   <span class="hljs-comment">//同上，但是只能在定义时赋值</span><br></code></pre></td></tr></table></figure><p> 创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">626</span>;<br>System.out.println(arr[<span class="hljs-number">0</span>]);<br>System.out.println(arr[<span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">626</span>;<br>System.out.println(arr[<span class="hljs-number">0</span>]);<br>System.out.println(arr[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>我们可以通过<code>数组变量名称.length</code>来获取当前数组长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(arr.length);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(arr.length);  <span class="hljs-comment">//打印length成员变量的值</span><br></code></pre></td></tr></table></figure><p>数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">String[] arr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>System.out.println(arr[<span class="hljs-number">10</span>]);  <span class="hljs-comment">//出现异常！</span><br><br><span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11</span><br><span class="hljs-comment"><code class="language-hljs java">String[] arr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>System.out.println(arr[<span class="hljs-number">10</span>]);  <span class="hljs-comment">//出现异常！</span><br><br><span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11</span><br><span class="hljs-comment">//at com.test.Application.main(Application.java:7)</span><br></code></pre></td></tr></table></figure><p>思考：能不能直接修改length的值来实现动态扩容呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>arr.length = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>arr.length = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    test(arr);<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    test(arr);<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number">2934</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>如果我们想要快速打印数组中的每一个元素，又怎么办呢？</p><h4 id="传统for循环"><a href="#传统for循环" class="headerlink" title="传统for循环"></a>传统for循环</h4><p>我们很容易就联想到for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < arr.length; i++) &#123;<br>   System.out.println(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2FDD%2F01%2Fo4YBAGASjymAK8QIAADiOdWkSVA342.jpg&refer=http%3A%2F%2Ffile.elecfans.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632204192&t=52381354d190d09899776f9bb868ef3e" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//三行两列</span><br><span class="hljs-keyword">int</span>[][] arr = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>System.out.println(arr[<span class="hljs-number">2</span>][<span class="hljs-number"><code class="language-hljs java"><span class="hljs-comment">//三行两列</span><br><span class="hljs-keyword">int</span>[][] arr = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>System.out.println(arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>二维数组的遍历同一维数组一样，只不过需要嵌套循环！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                           &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                           &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                           &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                           &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>          System.out.println(arr[i][j]);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。</p><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     test(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);    <span class="hljs-comment">//可变长，最后都会被自动封装成一个数组</span><br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String... test)</span></span>&#123;<br>     System.out.println(test[<span class="hljs-number">0</span>]);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     test(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);    <span class="hljs-comment">//可变长，最后都会被自动封装成一个数组</span><br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String... test)</span></span>&#123;<br>     System.out.println(test[<span class="hljs-number">0</span>]);    <span class="hljs-comment">//其实参数就是一个数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！</p><h3 id="实战：三大基本排序算法"><a href="#实战：三大基本排序算法" class="headerlink" title="实战：三大基本排序算法"></a>实战：三大基本排序算法</h3><p>现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br></code></pre></td></tr></table></figure><p>排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法：</p><ul><li>冒泡排序</li></ul><p>冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。</p><ul><li>插入排序</li></ul><p>插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg1.jjhgame.com%2Fstatic_data%2Fnewshelp%2F113_5c08e82d2ac8b.jpg&refer=http%3A%2F%2Fimg1.jjhgame.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632208529&t=f3fb9be4dce91c6364f5ec4f9faafc94" alt="img"></p><ul><li>选择排序</li></ul><p>选择排序其实就是每次都选择当前数组中最大的数排到最前面！</p><hr><h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。</p><p>设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">&quot;小&quot;</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">&quot;小&quot;</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">this</span>.name = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！</p><p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。</p><p>封装就是通过访问权限控制来实现的。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p><p>现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;   <span class="hljs-comment">//通过extends关键字来继承父类</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SportsStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);   <span class="hljs-comment">//必须先通过super关键字（指代父类），实现父类的构造方法！</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exercise</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我超勇的！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArtStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArtStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">art</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;   <span class="hljs-comment">//通过extends关键字来继承父类</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SportsStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);   <span class="hljs-comment">//必须先通过super关键字（指代父类），实现父类的构造方法！</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exercise</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我超勇的！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArtStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArtStudent</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">art</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">"随手画个毕加索！"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类具有父类的全部属性，protected可见但外部无法使用（包括<code>private</code>属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！</p><p>每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用<code>super()</code>，如果父类使用的是默认构造方法，那么子类不用手动指明。</p><p>所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Object obj = <span class="hljs-keyword">new</span> Object;<br>System.out.println(obj.hashCode());  <span class="hljs-comment">//求对象的hashcode，默认是对象的内存地址</span><br>System.out.println(obj.equals(obj));  <span class="hljs-comment">//比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 ==</span><br>System.out.println(obj.toString());  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Object obj = <span class="hljs-keyword">new</span> Object;<br>System.out.println(obj.hashCode());  <span class="hljs-comment">//求对象的hashcode，默认是对象的内存地址</span><br>System.out.println(obj.equals(obj));  <span class="hljs-comment">//比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 ==</span><br>System.out.println(obj.toString());  <span class="hljs-comment">//将对象转换为字符串，默认生成对象的类名称+hashcode</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于Object类的其他方法，我们会在Java多线程中再来提及。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！</p><h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//父类中的study</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;学习&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//子类中的study</span><br><span class="hljs-meta">@Override</span>  <span class="hljs-comment">//声明这个方法是重写的，但是可以不要，我们现阶段不接触</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-comment">//父类中的study</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;学习&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//子类中的study</span><br><span class="hljs-meta">@Override</span>  <span class="hljs-comment">//声明这个方法是重写的，但是可以不要，我们现阶段不接触</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">"给你看点好康的"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     SportsStudent student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);<br>     student.study();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     SportsStudent student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);<br>     student.study();   <span class="hljs-comment">//输出子类定义的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>思考：静态方法能被重写吗？</p><p>当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">super</span>.study();<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">super</span>.study();<br>    System.out.println(<span class="hljs-string">"给你看点好康的"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> test)</span></span>&#123;<br>    test = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">this</span>.test = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">super</span>.test = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> test)</span></span>&#123;<br>    test = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">this</span>.test = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">super</span>.test = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="再谈类型转换"><a href="#再谈类型转换" class="headerlink" title="再谈类型转换"></a>再谈类型转换</h4><p>我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//父类变量引用子类实例</span><br>student.study();     <span class="hljs-comment"><code class="language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//父类变量引用子类实例</span><br>student.study();     <span class="hljs-comment">//得到依然是具体实现的结果，而不是当前类型的结果</span><br></code></pre></td></tr></table></figure><p>我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//是由SportsStudent进行实现的</span><br><span class="hljs-comment">//... do something...</span><br><br>SportsStudent ps = (SportsStudent)student;  <span class="hljs-comment">//让它变成一个具体的子类</span><br>ps.sport();  <span class="hljs-comment"><code class="language-hljs java">Student student = <span class="hljs-keyword">new</span> SportsStudent(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//是由SportsStudent进行实现的</span><br><span class="hljs-comment">//... do something...</span><br><br>SportsStudent ps = (SportsStudent)student;  <span class="hljs-comment">//让它变成一个具体的子类</span><br>ps.sport();  <span class="hljs-comment">//调用具体实现类的方法</span><br></code></pre></td></tr></table></figure><p>这样的类型转换称为向下转型。</p><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Student student)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> SportsStudent)&#123;<br>        SportsStudent sportsStudent = (SportsStudent) student;<br>        sportsStudent.sport();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (student <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Student student)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> SportsStudent)&#123;<br>        SportsStudent sportsStudent = (SportsStudent) student;<br>        sportsStudent.sport();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (student <span class="hljs-keyword">instanceof</span> ArtStudent)&#123;<br>        ArtStudent artStudent = (ArtStudent) student;<br>        artStudent.art();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！</p><p>思考：<code>student instanceof Student</code>的结果是什么？</p><h4 id="再谈final关键字"><a href="#再谈final关键字" class="headerlink" title="再谈final关键字"></a>再谈final关键字</h4><p>我们目前只知道<code>final</code>关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-comment">//类被声明为终态，那么它还能被继承吗</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//还能重写吗</span><br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//还能重写吗</span><br>    System.out.println(<span class="hljs-string">"学习"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;   <span class="hljs-comment">//引用类型不允许再指向其他对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-comment">//基本类型值不允许发生改变</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;   <span class="hljs-comment">//引用类型不允许再指向其他对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-comment">//基本类型值不允许发生改变</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure><p>学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-comment">//抽象类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-comment">//抽象类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用<code>abstract</code>关键字来表明一个类是一个抽象类，抽象类可以使用<code>abstract</code>关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是<strong>必须</strong>由子类实现（除非子类也是一个抽象类）！</p><p>抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">Student s = <span class="hljs-keyword">new</span> Student()&#123;    <span class="hljs-comment">//只能直接创建带实现的匿名内部类！</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params"><code class="language-hljs java">Student s = <span class="hljs-keyword">new</span> Student()&#123;    <span class="hljs-comment">//只能直接创建带实现的匿名内部类！</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span><br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span><br>    System.out.println(<span class="hljs-string">"给你看点好康的"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用<code>interface</code>关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含<code>public</code>权限的<strong>抽象方法</strong>！（Java8以后可以有默认实现）我们可以通过声明<code>default</code>关键字来给抽象方法一个默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//do something...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口中定义的变量，默认为public static final</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Eat</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Eat</span>, ...</span>&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SportsStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Eat</span>, ...</span>&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类通过<code>implements</code>关键字来声明实现的接口！每个接口之间用逗号隔开！</p><p>实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>我们的类中可以在嵌套一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;   <span class="hljs-comment">//类中定义的一个内部类</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    Test.Inner inner = test.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test test = <span class="hljs-keyword">new</span> Test();<br>    Test.Inner inner = test.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//写法有那么一丝怪异，但是没毛病！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过<code>类名.</code>去访问:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test.Inner inner = <span class="hljs-keyword">new</span> Test.Inner();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test.Inner inner = <span class="hljs-keyword">new</span> Test.Inner();   <span class="hljs-comment">//不用再创建外部类对象了！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>对，你没猜错，就是和局部变量一样哒~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>        &#125;<br>        <br>        Inner inner = <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br><br>        &#125;<br>        <br>        Inner inner = <span class="hljs-keyword">new</span> Inner();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反正我是没用过！内部类 -&gt; 累不累 -&gt; 反正我累了！</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//DO something...</span><br>            &#125;<br>        &#125;;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！</p><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>读作<code>λ</code>表达式，它其实就是我们接口匿名实现的简化，比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//DO something...</span><br>            &#125;<br>        &#125;;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = () -&gt; &#123;&#125;;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = <span class="hljs-keyword">new</span> Eat() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//DO something...</span><br>            &#125;<br>        &#125;;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Eat eat = () -&gt; &#123;&#125;;   <span class="hljs-comment">//等价于上述内容</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！</p><p>为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String status;<br>  <br>  <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String status;<br>  <br>  <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！</p><p>有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING, STUDY, SLEEP    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING, STUDY, SLEEP    <span class="hljs-comment">//直接写每个状态的名字即可，分号可以不打，但是推荐打上</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用枚举类也非常方便，我们只需要直接访问即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> Status status;<br>  <br> <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(Status status)</span> </span>&#123;   <span class="hljs-comment">//不再是String，而是我们指定的枚举类型</span><br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> Status status;<br>  <br> <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(Status status)</span> </span>&#123;   <span class="hljs-comment">//不再是String，而是我们指定的枚举类型</span><br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>);<br>    student.setStatus(Status.RUNNING);<br>    System.out.println(student.getStatus());<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// Compiled from &quot;Status.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Enum</span>&lt;<span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status RUNNING;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status STUDY;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status SLEEP;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status[] values();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.<span class="hljs-function">Status <span class="hljs-title">valueOf</span><span class="hljs-params">(java.lang.String)</span></span>;<br>  <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">// Compiled from &quot;Status.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Enum</span>&lt;<span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">Status</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status RUNNING;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status STUDY;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status SLEEP;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status[] values();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.<span class="hljs-function">Status <span class="hljs-title">valueOf</span><span class="hljs-params">(java.lang.String)</span></span>;<br>  <span class="hljs-keyword">static</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING(<span class="hljs-string">&quot;睡觉&quot;</span>), STUDY(<span class="hljs-string">&quot;学习&quot;</span>), SLEEP(<span class="hljs-string">&quot;睡觉&quot;</span>);   <span class="hljs-comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-comment">//枚举的成员变量</span><br>    Status(String name)&#123;    <span class="hljs-comment">//覆盖原有构造方法（默认private，只能内部使用！）</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//获取封装的成员变量</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span> </span>&#123;<br>    RUNNING(<span class="hljs-string">&quot;睡觉&quot;</span>), STUDY(<span class="hljs-string">&quot;学习&quot;</span>), SLEEP(<span class="hljs-string">&quot;睡觉&quot;</span>);   <span class="hljs-comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-comment">//枚举的成员变量</span><br>    Status(String name)&#123;    <span class="hljs-comment">//覆盖原有构造方法（默认private，只能内部使用！）</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//获取封装的成员变量</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>);<br>    student.setStatus(Status.RUNNING);<br>    System.out.println(student.getStatus().getName());<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类还自带一些继承下来的实用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Status.valueOf(<span class="hljs-string">&quot;&quot;</span>)   <span class="hljs-comment">//将名称相同的字符串转换为枚举</span><br>Status.values()   <span class="hljs-comment"><code class="language-hljs java">Status.valueOf(<span class="hljs-string">&quot;&quot;</span>)   <span class="hljs-comment">//将名称相同的字符串转换为枚举</span><br>Status.values()   <span class="hljs-comment">//快速获取所有的枚举</span><br></code></pre></td></tr></table></figure><h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！</p><p>我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p><p><img src="https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png" alt="img"></p><ul><li>byte  -&gt;  Byte      </li><li>boolean  -&gt;  Boolean   </li><li>short  -&gt;  Short    </li><li>char  -&gt;  Character  </li><li>int -&gt; Integer    </li><li>long -&gt;  Long     </li><li>float -&gt; Float      </li><li>double -&gt; Double   </li></ul><p>包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-comment">//Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;   <span class="hljs-comment">//Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.value = value;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们操作的就是Integer对象而不是一个int基本类型了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     Integer i = <span class="hljs-number">1</span>;   <span class="hljs-comment">//包装类型可以直接接收对应类型的数据，并变为一个对象！</span><br>     System.out.println(i + i);    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     Integer i = <span class="hljs-number">1</span>;   <span class="hljs-comment">//包装类型可以直接接收对应类型的数据，并变为一个对象！</span><br>     System.out.println(i + i);    <span class="hljs-comment">//包装类型可以直接被当做一个基本类型进行操作！</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">Integer i = <span class="hljs-number">1</span>;    <span class="hljs-comment">//其实这里只是简写了而已</span><br>Integer i = Integer.valueOf(<span class="hljs-number">1</span>);  <span class="hljs-comment"><code class="language-hljs java">Integer i = <span class="hljs-number">1</span>;    <span class="hljs-comment">//其实这里只是简写了而已</span><br>Integer i = Integer.valueOf(<span class="hljs-number">1</span>);  <span class="hljs-comment">//编译后真正的样子</span><br></code></pre></td></tr></table></figure><p>调用valueOf来生成一个Integer对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="hljs-comment">//注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）</span><br>       <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="hljs-comment">//注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）</span><br>       <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);   <span class="hljs-comment">//返回一个新创建好的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = Integer.valueOf(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> a = i;    <span class="hljs-comment">//简写</span><br>    <span class="hljs-keyword">int</span> a = i.intValue();   <span class="hljs-comment">//编译后实际的代码</span><br>  <br>  <span class="hljs-keyword">long</span> c = i.longValue();   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i = Integer.valueOf(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> a = i;    <span class="hljs-comment">//简写</span><br>    <span class="hljs-keyword">int</span> a = i.intValue();   <span class="hljs-comment">//编译后实际的代码</span><br>  <br>  <span class="hljs-keyword">long</span> c = i.longValue();   <span class="hljs-comment">//其他类型也有！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>既然现在是包装类型了，那么我们还能使用<code>==</code>来判断两个数是否相等吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1 == i2);   <span class="hljs-comment">//实际上判断是两个对象是否为同一个对象（内存地址是否相同）</span><br>    System.out.println(i1.equals(i2));   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1 == i2);   <span class="hljs-comment">//实际上判断是两个对象是否为同一个对象（内存地址是否相同）</span><br>    System.out.println(i1.equals(i2));   <span class="hljs-comment">//这个才是真正的值判断！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意IntegerCache带来的影响！</p><p>思考：下面这种情况结果会是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1+<span class="hljs-number">1</span> == i2+<span class="hljs-number"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Integer i1 = <span class="hljs-number">28914</span>;<br>    Integer i2 = <span class="hljs-number">28914</span>;<br><br>    System.out.println(i1+<span class="hljs-number">1</span> == i2+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在集合类的学习中，我们还会继续用到我们的包装类型！</p><hr><h2 id="面向对象编程实战"><a href="#面向对象编程实战" class="headerlink" title="面向对象编程实战"></a>面向对象编程实战</h2><p>虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;   <span class="hljs-comment">//for循环暴力求解，简单，但是效率似乎低了一些</span><br>        sum += i;<br>    &#125;<br>    System.out.println(sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println((<span class="hljs-number">1</span> + <span class="hljs-number">100</span>) * <span class="hljs-number">50</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;   <span class="hljs-comment">//for循环暴力求解，简单，但是效率似乎低了一些</span><br>        sum += i;<br>    &#125;<br>    System.out.println(sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println((<span class="hljs-number">1</span> + <span class="hljs-number">100</span>) * <span class="hljs-number">50</span>);  <span class="hljs-comment">//高斯求和公式，利用数学，瞬间计算结果！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>说到最后，其实数学和逻辑思维才是解决问题的最终办法！</p><h3 id="对象设计（面向对象、多态运用）"><a href="#对象设计（面向对象、多态运用）" class="headerlink" title="对象设计（面向对象、多态运用）"></a>对象设计（面向对象、多态运用）</h3><ul><li>设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。</li><li>设计设计一个接口<code>考试</code>，只有老师和学生会考试。</li><li>设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。</li></ul><h3 id="二分搜索（搜索算法）"><a href="#二分搜索（搜索算法）" class="headerlink" title="二分搜索（搜索算法）"></a>二分搜索（搜索算法）</h3><p>现在有一个有序数组（从小到大，数组长度 0 &lt; n &lt; 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回<code>-1</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">26</span>&#125;;   <span class="hljs-comment">//测试用例</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">26</span>&#125;;   <span class="hljs-comment">//测试用例</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-comment">//请在这里实现搜索算法</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序（排序算法、递归分治）"><a href="#快速排序（排序算法、递归分治）" class="headerlink" title="快速排序（排序算法、递归分治）"></a>快速排序（排序算法、递归分治）</h3><p>（开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用<strong>分治法</strong>来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。</p><p>快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！</p><h3 id="0-1背包问题（回溯法、剪枝-动态规划优化）"><a href="#0-1背包问题（回溯法、剪枝-动态规划优化）" class="headerlink" title="0/1背包问题（回溯法、剪枝/动态规划优化）"></a>0/1背包问题（回溯法、剪枝/动态规划优化）</h3><p>给定 <code>n </code>件物品，每一个物品的重量为 <code>w[n]</code>，每个物品的价值为 <code>v[n]</code>。现挑选物品放入背包中，假定背包能承受的最大重量为 <code>capacity</code>，求装入物品的最大价值是多少?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span>[] w = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span>[] v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">int</span> capacity = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span>[] w = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span>[] v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">int</span> capacity = <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语法规范</title>
      <link href="/2022/02/21/2.html/"/>
      <url>/2022/02/21/2.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Java语法规范"><a href="#Java语法规范" class="headerlink" title="Java语法规范"></a>Java语法规范</h1><p>所有的Java语句必须以<code>;</code>结尾！</p><p>无论是<code>()</code>、<code>[]</code>还是<code>&#123;&#125;</code>，所有的括号必须一一匹配！</p><p>主方法的代码只能写在<code>&#123;&#125;</code>中！</p><h1 id="Java基础语法（面向过程）"><a href="#Java基础语法（面向过程）" class="headerlink" title="Java基础语法（面向过程）"></a>Java基础语法（面向过程）</h1><p>在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Python就会很轻松！</p><h2 id="变量和关键字"><a href="#变量和关键字" class="headerlink" title="变量和关键字"></a>变量和关键字</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量就是一个可变的量，例如定义一个int类型的变量（int就是整数类型）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">20</span>;<br>a = <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">20</span>;<br>a = <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p>我们能够随意更改它的值，也就是说它的值是随时可变的，我们称为变量。变量可以是类的变量，也可以是方法内部的局部变量（我们现阶段主要用局部变量，类变量在面向对象再讲解）</p><p>变量和C语言中的变量不同，Java中的变量是存放在JVM管理的内存中，C语言的变量存放在内存（某些情况下需要手动释放内存，而Java会自动帮助我们清理变量占据的内存）Java和C++很类似，但是没有指针！Java也叫C++–</p><p>Java是强类型语言，只有明确定义了变量之后，你才能使用！一旦被指定某个数据类型，那么它将始终被认为是对应的类型（和JS不一样！）</p><p>定义一个变量的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">[类型] [标识符(名字)] = [初始值(可选)]<br><span class="hljs-keyword">int</span> a = <span class="hljs-number"><code class="language-hljs java">[类型] [标识符(名字)] = [初始值(可选)]<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>注意：标识符不能为以下内容：</p><ul><li>标识符以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。</li><li>大小写敏感！</li><li>不能有空格、@、#、+、-、/ 等符号</li><li>应该使用有意义的名称，达到见名知意的目的，最好以小写字母开头</li><li>不可以是 true 和 false </li><li>不能与Java语言的关键字重名</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>![image-20210817150135886](/Users/nagocoler/Library/Application Support/typora-user-images/image-20210817150135886.png)</p><p>包括基本数据类型、流程控制语句等，了解就行，不用去记，后面我们会一点一点带大家认识！</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量就是无法修改值的变量，常量的值，只能定义一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">10</span>;  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">10</span>;  <span class="hljs-comment">//报错！</span><br></code></pre></td></tr></table></figure><p>常量前面必须添加final关键字（C语言里面是const，虽然Java也有，但是不能使用！）</p><p>这只是final关键字的第一个用法，后面还会有更多的用法。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>养成注释的好习惯，不然以后自己都看不懂自己的代码！注释包括单行注释和多行注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//我是单行注释</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 我是</span><br><span class="hljs-comment">* 多行注释</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//我是单行注释</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 我是</span><br><span class="hljs-comment">* 多行注释</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//TODO 待做标记</span><br></code></pre></td></tr></table></figure><hr><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java中的数据类型分为基本数据类型和引用类型两大类，引用类型我们在面向对象时再提，基本数据类型是重点中的重点！首先我们需要了解有哪些类型。然后，我们需要知道的，并不是他们的精度如何，能够表示的范围有多大，而是为什么Java会给我们定义这些类型，计算机是怎么表示这些类型的，这样我们才能够更好的记忆他们的精度、表示的范围大小。所以，我们从计算机原理的角度出发，带领大家走进Java的基本数据类型。</p><p>这一部分稍微有点烧脑，但是是重中之重，如果你掌握了这些，任何相关的面试题都难不倒你！（如果你学习过计算机组成原理就很好理解了）</p><h3 id="计算机中的二进制表示"><a href="#计算机中的二进制表示" class="headerlink" title="计算机中的二进制表示"></a>计算机中的二进制表示</h3><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p><p>十进制的7 -&gt; 在二进制中为 111 = 2^2 + 2^1 + 2^0</p><p>现在有4个bit位，最大能够表示多大的数字呢？</p><ul><li>最小：0000 =&gt; 0</li><li>最大：1111 =&gt; 2^3+2^2+2^1+2^0 =&gt; 8 + 4 + 2 + 1 = 15</li></ul><p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p><ul><li>最小：1111 =&gt; -(2^2+2^1+2^0) =&gt; -7</li><li>最大：0111 =&gt; +(2^2+2^1+2^0) =&gt; +7 =&gt; 7</li></ul><p>现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。</p><h3 id="计算机中的加减法"><a href="#计算机中的加减法" class="headerlink" title="计算机中的加减法"></a>计算机中的加减法</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p><p>1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）</p><p>我们得创造一种更好的表示方式！于是我们引入了反码：</p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li></ul><p>经过上面的定义，我们再来进行加减法：</p><p>1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！）</p><p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？</p><ul><li>0既不是正数也不是负数，那么显然这样的表示依然不够合理！</li></ul><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：</p><ul><li>正数的补码就是其本身 （不变！）</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</li></ul><p>其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：</p><p>1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！）</p><p>所以现在，4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）</p><p><code>以上内容是重点， 是一定要掌握的知识，这些知识是你在面试中的最终防线！有了这些理论基础，无论面试题如何变换，都能够通过理论知识来破解</code></p><hr><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。</p><p>在Java中，整数类型包括以下几个：</p><ul><li>byte 字节型 （8个bit，也就是1个字节）范围：-128~+127</li><li>short 短整形（16个bit，也就是2个字节）范围：-32768~+32767</li><li>int 整形（32个bit，也就是4个字节）最常用的类型！</li><li>long 长整形（64个bit，也就是8个字节）最后需要添加l或L</li></ul><p>long都装不下怎么办？BigInteger！</p><p>数字已经达到byte的最大值了，还能加吗？为了便于理解，以4bit为例：</p><p>0111 + 0001 = 1000 =&gt;  -8（你没看错，就是这样！）</p><p>整数还能使用8进制、16进制表示：</p><ul><li>十进制为15 = 八进制表示为017 = 十六进制表示为 0xF = 二进制表示 1111 (代码里面不能使用二进制！)</li></ul><h3 id="字符类型和字符串"><a href="#字符类型和字符串" class="headerlink" title="字符类型和字符串"></a>字符类型和字符串</h3><p>在Java中，存在字符类型，它能够代表一个字符：</p><ul><li>char 字符型（16个bit，也就是2字节，它不带符号！）范围是0 ~ 65535</li><li>使用Unicode表示就是：\u0000 ~ \uffff</li></ul><p>字符要用单引号扩起来！比如 char c = ‘淦’;</p><p>字符其实本质也是数字，但是这些数字通过编码表进行映射，代表了不同的字符，比如字符<code>&#39;A&#39;</code>的ASCII码就是数字<code>65</code>，所以，char类型其实可以转换为上面的整数类型。</p><p>Java的char采用Unicode编码表（不是ASCII编码！），Unicode编码表包含ASCII的所有内容，同时还包括了全世界的语言，ASCII只有1字节，而Unicode编码是2字节，能够代表65536种文字，足以包含全世界的文字了！（我们编译出来的字节码文件也是使用Unicode编码的，所以利用这种特性，其实Java支持中文变量名称、方法名称甚至是类名）</p><p>既然char只能代表一个字符，那怎么才能包含一句话呢？（关于数组，我们这里先不了解，数组我们放在面向对象章节讲解）</p><p>String就是Java中的字符串类型（注意，它是一个类，创建出来的字符串本质是一个对象，不是我们的基本类型）字符串就像它的名字一样，代表一串字符，也就是一句完整的话。</p><p>字符串用双引号括起来！比如：String str = “一日三餐没烦恼”;</p><h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h3><p>小数类型比较难理解（比较难理解指的是原理，不是使用）首先来看看Java中的小数类型包含哪些：</p><ul><li>float 单精度浮点型 （32bit，4字节）</li><li>double 双精度浮点型（64bit，8字节）</li></ul><p>思考：小数的范围该怎么定义呢？我们首先要了解的是小数在计算机里面是如何存放的：</p><p>![image-20210817143234500](/Users/nagocoler/Library/Application Support/typora-user-images/image-20210817143234500.png)</p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：<br>V = (-1)^S × M × 2^E<br>（1）(-1)^S 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。<br>（2）M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）<br>（3）2^E 表示指数位。（用于移动小数点）</p><p>比如： 对于十进制的 5.25 对应的二进制为：101.01，相当于：1.0101*2^2。所以，S 为 0，M 为 1.0101，E 为 2。所以，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码。我们在这里就不去计算了，想了解的可以去搜索相关资料。</p><p>思考：就算double有64bit位数，但是依然存在精度限制，如果我要进行高精度的计算，怎么办？BigDecimal！</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句。（C语言一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p><hr><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换支持字节数小的类型自动转换为字节数大的类型，整数类型自动转换为小数类型，转换规则如下：</p><ul><li>byte→short(char)→int→long→float→double</li></ul><p>问题：为什么long比float大，还能转换为float呢？小数的存储规则让float的最大值比long还大，只是可能会丢失某些位上的精度！</p><p>所以，如下的代码就能够正常运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">short</span> s = b;<br><span class="hljs-keyword">int</span> i = s;<br><span class="hljs-keyword">long</span> l = i;<br><span class="hljs-keyword">float</span> f = l;<br><span class="hljs-keyword">double</span> d = f;<br>System.out.println(d);<br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">short</span> s = b;<br><span class="hljs-keyword">int</span> i = s;<br><span class="hljs-keyword">long</span> l = i;<br><span class="hljs-keyword">float</span> f = l;<br><span class="hljs-keyword">double</span> d = f;<br>System.out.println(d);<br><br><span class="hljs-comment">//输出 9.0</span><br></code></pre></td></tr></table></figure><h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><p>显示类型转换也叫做强制类型转换，也就是说，违反隐式转换的规则，牺牲精度强行进行类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">128</span>;<br><span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>)i;<br>System.out.println(b);<br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">128</span>;<br><span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>)i;<br>System.out.println(b);<br><br><span class="hljs-comment">//输出 -128</span><br></code></pre></td></tr></table></figure><p>为什么结果是-128？精度丢失了！</p><ul><li>int 类型的128表示：00000000 00000000 00000000 10000000</li><li>byte类型转换后表示：xxxxxxxx xxxxxxxx xxxxxxxx 10000000 =&gt; -128</li></ul><h3 id="数据类型自动提升"><a href="#数据类型自动提升" class="headerlink" title="数据类型自动提升"></a>数据类型自动提升</h3><p>在参与运算时（也可以位于表达式中时，自增自减除外），所有的byte型、short型和char的值将被提升到int型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">105</span>;<br>b = b + <span class="hljs-number">1</span>;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">105</span>;<br>b = b + <span class="hljs-number">1</span>;   <span class="hljs-comment">//报错！</span><br>System.out.println(b);<br></code></pre></td></tr></table></figure><p>这个特性是由 <strong>Java虚拟机规范</strong> 定义的，也是为了提高运行的效率。其他的特性还有：</p><ul><li>如果一个操作数是long型，计算结果就是long型</li><li>如果一个操作数是float型，计算结果就是float型</li><li>如果一个操作数是double型，计算结果就是double型</li></ul><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值和算术运算符"><a href="#赋值和算术运算符" class="headerlink" title="赋值和算术运算符"></a>赋值和算术运算符</h3><p>赋值运算符<code>=</code>是最常用的运算符，其实就是将我们等号右边的结果，传递给等号左边的变量，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span> + <span class="hljs-number">8</span>;<br><span class="hljs-keyword">int</span> c = <span class="hljs-number">5</span> * <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span> + <span class="hljs-number">8</span>;<br><span class="hljs-keyword">int</span> c = <span class="hljs-number">5</span> * <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>算术运算符也就是我们在小学阶段学习的<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code>，分别代表加减乘除还有取余，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> c = a * b;<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> c = a * b;<br><span class="hljs-comment">//结果为6</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>+</code>还可以用作字符串连接符使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java">System.out.println(<span class="hljs-string">&quot;lbw&quot;</span> + <span class="hljs-string">&quot;nb&quot;</span>);  <span class="hljs-comment"><code class="language-hljs java">System.out.println(<span class="hljs-string">&quot;lbw&quot;</span> + <span class="hljs-string">&quot;nb&quot;</span>);  <span class="hljs-comment">//lbwnb</span><br></code></pre></td></tr></table></figure><p>当然，字符串可以直接连接其他类型，但是会全部当做字符串处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>System.out.println(<span class="hljs-string">&quot;lbw&quot;</span> + a + b); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>System.out.println(<span class="hljs-string">&quot;lbw&quot;</span> + a + b); <span class="hljs-comment">//lbw715</span><br></code></pre></td></tr></table></figure><p>算术运算符还包括<code>++</code>和<code>--</code>也就是自增和自减，以自增为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a++;<br>System.out.println(a); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>a++;<br>System.out.println(a); <span class="hljs-comment">//输出为11</span><br></code></pre></td></tr></table></figure><p>自增自减运算符放在变量的前后的返回值是有区别的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(a++);  <span class="hljs-comment">//10 （先返回值，再自增）</span><br>System.out.println(a);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(a++);  <span class="hljs-comment">//10 （先返回值，再自增）</span><br>System.out.println(a);   <span class="hljs-comment">//11</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(++a);  <span class="hljs-comment">//11 （先自增，再返回值）</span><br>System.out.println(a);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(++a);  <span class="hljs-comment">//11 （先自增，再返回值）</span><br>System.out.println(a);  <span class="hljs-comment">//11</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>System.out.println(b+++a++);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>System.out.println(b+++a++);  <span class="hljs-comment">//猜猜看结果是多少</span><br></code></pre></td></tr></table></figure><p>为了使得代码更简洁，你还可以使用扩展的赋值运算符，包括<code>+=</code>、<code>-=</code>、<code>/=</code>、<code>*=</code>、<code>%=</code>，和自增自减类似，先执行运算，再返回结果，同时自身改变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(a += <span class="hljs-number">2</span>);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>System.out.println(a += <span class="hljs-number">2</span>);  <span class="hljs-comment">//等价于 a = a + 2</span><br></code></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符的结果只能是布尔类型，也就是要么为真要么为假，关系运算符包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java">&gt; &lt; == <span class="hljs-comment">//大于小于等于</span><br>&gt;= &lt;=  !=  <span class="hljs-comment"><code class="language-hljs java">&gt; &lt; == <span class="hljs-comment">//大于小于等于</span><br>&gt;= &lt;=  !=  <span class="hljs-comment">//大于等于，小于等于，不等于</span><br></code></pre></td></tr></table></figure><p>关系运算符一般只用于基本类型的比较，运算结果只能是boolean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b;<br>System.out.println(x);<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b;<br>System.out.println(x);<br><span class="hljs-comment">//结果为 true</span><br></code></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符两边只能是boolean类型或是关系/逻辑运算表达式，返回值只能是boolean类型！逻辑运算符包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java">&amp;&amp; <span class="hljs-comment">//与运算，要求两边同时为true才能返回true</span><br>|| <span class="hljs-comment">//或运算，要求两边至少要有一个为true才能返回true</span><br>! <span class="hljs-comment"><code class="language-hljs java">&amp;&amp; <span class="hljs-comment">//与运算，要求两边同时为true才能返回true</span><br>|| <span class="hljs-comment">//或运算，要求两边至少要有一个为true才能返回true</span><br>! <span class="hljs-comment">//非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转</span><br></code></pre></td></tr></table></figure><p>实际案例来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b &amp;&amp; a &lt; b;  <span class="hljs-comment">//怎么可能同时满足呢</span><br>System.out.println(x);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b &amp;&amp; a &lt; b;  <span class="hljs-comment">//怎么可能同时满足呢</span><br>System.out.println(x);   <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b || a &lt;= b;  <span class="hljs-comment">//一定有一个满足！</span><br>System.out.println(x);   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = a &gt; b || a &lt;= b;  <span class="hljs-comment">//一定有一个满足！</span><br>System.out.println(x);   <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = !(a &gt; b); <span class="hljs-comment">//对结果进行反转，本来应该是true</span><br>System.out.println(x); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> x = !(a &gt; b); <span class="hljs-comment">//对结果进行反转，本来应该是true</span><br>System.out.println(x); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">&amp; <span class="hljs-comment">//按位与，注意，返回的是运算后的同类型值，不是boolean！</span><br>| <span class="hljs-comment">//按位或</span><br>^ <span class="hljs-comment">//按位异或 0 ^ 0 = 0</span><br>~ <span class="hljs-comment"><code class="language-hljs java">&amp; <span class="hljs-comment">//按位与，注意，返回的是运算后的同类型值，不是boolean！</span><br>| <span class="hljs-comment">//按位或</span><br>^ <span class="hljs-comment">//按位异或 0 ^ 0 = 0</span><br>~ <span class="hljs-comment">//按位非</span><br></code></pre></td></tr></table></figure><p>按位运算实际上是根据值的二进制编码来计算结果，例如按位与，以4bit为例：</p><p>0101 &amp; 0100 = 0100 （只有同时为1对应位才得1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>System.out.println(a &amp; b); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>System.out.println(a &amp; b); <span class="hljs-comment">//结果为7</span><br></code></pre></td></tr></table></figure><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>三目运算符其实是为了简化代码而生，可以根据条件是否满足来决定返回值，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>String str = a &gt; b ? <span class="hljs-string">&quot;行&quot;</span> : <span class="hljs-string">&quot;不行&quot;</span>;  <span class="hljs-comment">// 判断条件(只能是boolean,或返回boolean的表达式) ? 满足的返回值 : 不满足的返回值 </span><br>System.out.println(<span class="hljs-string">&quot;汉堡做的行不行？&quot;</span>+str);  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">15</span>;<br>String str = a &gt; b ? <span class="hljs-string">&quot;行&quot;</span> : <span class="hljs-string">&quot;不行&quot;</span>;  <span class="hljs-comment">// 判断条件(只能是boolean,或返回boolean的表达式) ? 满足的返回值 : 不满足的返回值 </span><br>System.out.println(<span class="hljs-string">&quot;汉堡做的行不行？&quot;</span>+str);  <span class="hljs-comment">//汉堡做的行不行？不行</span><br></code></pre></td></tr></table></figure><p>理解三目运算符，就很容易理解后面的if-else语句了。</p><hr><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来帮我进行更灵活的控制。比如，判断用户输入的数字，大于1则输出ok，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！</p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>选择结构包含if和switch类型，选择结构能够帮助我们根据条件判断，再执行哪一块代码。</p><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>就像上面所说，判断用户输入的数字，大于1则输出ok，小于1则输出no，要实现这种效果，我们首先可以采用if语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">if</span>(判断条件)&#123;<br>  <span class="hljs-comment">//判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">//判断失败执行的内容</span><br>&#125;<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">if</span>(判断条件)&#123;<br>  <span class="hljs-comment">//判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">//判断失败执行的内容</span><br>&#125;<br><span class="hljs-comment">//if的内容执行完成后，后面的内容正常执行</span><br></code></pre></td></tr></table></figure><p>其中，<code>else</code>语句不是必须的。</p><p>现在，又来了一个新的需求，用户输入的是1打印ok，输入2，打印yes，其他打印no，那么这样就需要我们进行多种条件的判断了，当然if能进行多分支判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">//判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-comment">//再次判断，如果判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">//判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-comment">//再次判断，如果判断成功执行的内容</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">//上面的都没成功，只能走这里</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样，<code>else</code>语句不是必须的。</p><p>现在，又来了一个新的需求，用户输入1之后，在判断用户下一次输入的是什么，如果是1，打印yes，不是就打印no，这样就可以用嵌套if了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">//前提是判断条件1要成功才能进来！</span><br>  <span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-comment">//判断成功执行的内容</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">//前提是判断条件1要成功才能进来！</span><br>  <span class="hljs-keyword">if</span>(判断条件<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-comment">//判断成功执行的内容</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//判断失败执行的内容</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>我们不难发现，虽然<code>else-if</code>能解决多分支判断的问题，但是效率实在是太低了，多分支if采用的是逐级向下判断，显然费时费力，那么有没有一直更专业的解决多分支判断问题的东西呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">switch</span>(判断主体)&#123;<br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//break用于跳出switch语句，不添加会导致程序继续向下运行！</span><br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">3</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">switch</span>(判断主体)&#123;<br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//break用于跳出switch语句，不添加会导致程序继续向下运行！</span><br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> 值<span class="hljs-number">3</span>:<br>    <span class="hljs-comment">//运行xxx</span><br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述语句中，只有判断主体等于case后面的值时，才会执行case中的语句，同时需要使用break来跳出switch语句，否则会继续向下运行！</p><p>为什么switch效率更高呢，因为switch采用二分思想进行查找（这也是为什么switch只能判断值相等的原因），能够更快地找到我们想要的结果！</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>小明想向小红表白，于是他在屏幕上打印了520个 “我爱你”，我们用Java该如何实现呢？</p><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p>for语句是比较灵活的循环控制语句，一个for语句的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">for</span>(初始条件;循环条件;更新)&#123;<br>  <span class="hljs-comment">//循环执行的内容</span><br>&#125;<br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">for</span>(初始条件;循环条件;更新)&#123;<br>  <span class="hljs-comment">//循环执行的内容</span><br>&#125;<br><span class="hljs-comment">//循环结束后，继续执行</span><br></code></pre></td></tr></table></figure><ul><li>初始条件：循环开始时的条件，一般用于定义控制循环的变量。</li><li>循环条件：每轮循环开始之前，进行一次判断，如果满足则继续，不满足则结束，要求为boolean变量或是boolean表达式。</li><li>更新：每轮循环结束后都会执行的内容，一般写增量表达式。</li></ul><p>初始条件、循环条件、更新条件不是缺一不可，甚至可以都缺！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">520</span>;i++)&#123;<br>  System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">520</span>;i++)&#123;<br>  System.out.println(<span class="hljs-string">"我爱你"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>  <span class="hljs-comment">//这里的内容将会永远地进行下去！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>增强for循环在数组时再讲解！</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while循环和for循环类似，但是它更加的简单，只需要添加维持循环的判断条件即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">while</span>(循环条件)&#123;<br>  <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">while</span>(循环条件)&#123;<br>  <span class="hljs-comment">//循环执行的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>和for一样，每次循环开始，当循环条件不满足时，自动退出！那么有时候我们希望先执行了我们的代码再去判断怎么办呢，我们可以使用do-while语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">do</span>&#123;<br>  <span class="hljs-comment">//执行内容</span><br>&#125;<span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">do</span>&#123;<br>  <span class="hljs-comment">//执行内容</span><br>&#125;<span class="hljs-keyword">while</span>(循环条件);<br></code></pre></td></tr></table></figure><p>一定会先执行do里面的内容，再做判断！</p><p>思考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>  <br>&#125;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>  <br>&#125;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">//它们的性能谁更高？</span><br></code></pre></td></tr></table></figure><hr><h2 id="面向过程编程实战（基础-算法）"><a href="#面向过程编程实战（基础-算法）" class="headerlink" title="面向过程编程实战（基础+算法）"></a>面向过程编程实战（基础+算法）</h2><h3 id="打印九九乘法表"><a href="#打印九九乘法表" class="headerlink" title="打印九九乘法表"></a>打印九九乘法表</h3><p>简单：将九九乘法表打印到控制台。</p><h3 id="求1000以内的水仙花数"><a href="#求1000以内的水仙花数" class="headerlink" title="求1000以内的水仙花数"></a>求1000以内的水仙花数</h3><p>中等：打印1000以内所有满足水仙花的数，“水仙花数”是指一个三位数其各位数字的立方和等于该数本身，例如153是“水仙花数”，因为：153 = 1^3 + 5^3 + 3^3</p><h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><p>困难：一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？例如n=2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。</p><p>动态规划：其实，就是利用，上次得到的结果，给下一次作参考，下一次就能利用上次的结果快速得到结果，依次类推</p><hr><p>不对啊，别的教程都讲了数组、方法，怎么我们还没讲就进入面向对象了呢？</p><ul><li>数组在Java中，并非基本类型，数组是编程不可见的对象类型，学习了面向对象再来理解，会更加容易！</li><li>方法在Java中是类具有的属性，所以，在了解了对象类型之后，再来了解方法，就更加简单了！</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring/SpringBoot常用注解</title>
      <link href="/2021/11/29/40566.html/"/>
      <url>/2021/11/29/40566.html/</url>
      
        <content type="html"><![CDATA[<h4 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1.@SpringBootApplication"></a>1.@SpringBootApplication</h4><span id="more"></span><p>可以把 @SpringBootApplication看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。</p><h4 id="2-Spring-Bean相关"><a href="#2-Spring-Bean相关" class="headerlink" title="2.Spring Bean相关"></a>2.Spring Bean相关</h4><h5 id="2-1-Autowired"><a href="#2-1-Autowired" class="headerlink" title="2.1 @Autowired"></a>2.1 @Autowired</h5><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理。</p><h5 id="2-2-Component-Repository-Service-Controller"><a href="#2-2-Component-Repository-Service-Controller" class="headerlink" title="2.2 @Component,@Repository,@Service, @Controller"></a>2.2 @Component,@Repository,@Service, @Controller</h5><p>我们一般使用 @Autowired 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,可以采用以下注解实现：<br>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。<br>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。<br>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。<br>@Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</p>]]></content>
      
      
      <categories>
          
          <category> Spring/SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot_tm表结构设计</title>
      <link href="/2021/11/19/27267.html/"/>
      <url>/2021/11/19/27267.html/</url>
      
        <content type="html"><![CDATA[<h2 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h2><span id="more"></span><h3 id="建表顺序"><a href="#建表顺序" class="headerlink" title="建表顺序"></a>建表顺序</h3><p>在建表过程中，会设置外键约束，所以表和表之间有依赖关系。 因此会先建立被外键指向的表，比如User,Category，然后再是其他表</p><h4 id="1-用户表"><a href="#1-用户表" class="headerlink" title="1.用户表"></a>1.用户表</h4><p>salt 是盐，用来和 shiro 结合的时候，加密用的</p><blockquote><p>CREATE TABLE user (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   name varchar(255) DEFAULT NULL,<br>   password varchar(255) DEFAULT NULL,<br>   salt varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id)<br> ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></blockquote><h4 id="2-分类表"><a href="#2-分类表" class="headerlink" title="2.分类表"></a>2.分类表</h4><blockquote><p>CREATE TABLE category (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   name varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote><h4 id="3-属性表"><a href="#3-属性表" class="headerlink" title="3.属性表"></a>3.属性表</h4><p>从这个表开始， 就有外键约束了。<br>本表的外键cid，指向分类表的id字段</p><blockquote><p>CREATE TABLE property (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   cid int(11) DEFAULT NULL,<br>   name varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_property_category FOREIGN KEY (cid) REFERENCES category (id)<br> ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></blockquote><h4 id="4-产品表"><a href="#4-产品表" class="headerlink" title="4.产品表"></a>4.产品表</h4><p>产品表字段稍多，讲解一下<br>name: 产品名称<br>subTitle: 小标题<br>originalPrice: 原始价格<br>promotePrice: 优惠价格<br>stock: 库存<br>createDate: 创建日期</p><p>本表的外键cid，指向分类表的id字段</p><blockquote><p>CREATE TABLE product (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   name varchar(255) DEFAULT NULL,<br>   subTitle varchar(255) DEFAULT NULL,<br>   originalPrice float DEFAULT NULL,<br>   promotePrice float DEFAULT NULL,<br>   stock int(11) DEFAULT NULL,<br>   cid int(11) DEFAULT NULL,<br>   createDate datetime DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_product_category FOREIGN KEY (cid) REFERENCES category (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote><h4 id="5-属性值表"><a href="#5-属性值表" class="headerlink" title="5.属性值表"></a>5.属性值表</h4><p>本表有两个外键<br>外键ptid，指向属性表的id字段<br>外键pid，指向产品表的id字段</p><blockquote><p>CREATE TABLE propertyvalue (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   pid int(11) DEFAULT NULL,<br>   ptid int(11) DEFAULT NULL,<br>   value varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_propertyvalue_property FOREIGN KEY (ptid) REFERENCES property (id),<br>   CONSTRAINT fk_propertyvalue_product FOREIGN KEY (pid) REFERENCES product (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote><h4 id="6-产品图片表"><a href="#6-产品图片表" class="headerlink" title="6.产品图片表"></a>6.产品图片表</h4><p>type表示类型，产品图片分单个图片和详情图片两种</p><p>本表的外键pid，指向产品表的id字段</p><blockquote><p>CREATE TABLE productimage (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   pid int(11) DEFAULT NULL,<br>   type varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_productimage_product FOREIGN KEY (pid) REFERENCES product (id)<br> ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p></blockquote><h4 id="7-评价表"><a href="#7-评价表" class="headerlink" title="7.评价表"></a>7.评价表</h4><p>外键pid，指向产品表的id字段<br>外键uid，指向用户表的id字段</p><blockquote><p>CREATE TABLE review (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   content varchar(4000) DEFAULT NULL,<br>   uid int(11) DEFAULT NULL,<br>   pid int(11) DEFAULT NULL,<br>   createDate datetime DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_review_product FOREIGN KEY (pid) REFERENCES product (id),<br>     CONSTRAINT fk_review_user FOREIGN KEY (uid) REFERENCES user (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote><h4 id="8-订单表"><a href="#8-订单表" class="headerlink" title="8.订单表"></a>8.订单表</h4><p>订单表的字段也比较多，讲解一下：<br>orderCode： 订单号<br>address:收货地址<br>post: 邮编<br>receiver: 收货人信息<br>mobile: 手机号码<br>userMessage: 用户备注信息<br>createDate: 订单创建日期<br>payDate: 支付日期<br>deliveryDate: 发货日期<br>confirmDate：确认收货日期<br>status: 订单状态<br>外键uid，指向用户表id字段</p><blockquote><p>CREATE TABLE order_ (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   orderCode varchar(255) DEFAULT NULL,<br>   address varchar(255) DEFAULT NULL,<br>   post varchar(255) DEFAULT NULL,<br>   receiver varchar(255) DEFAULT NULL,<br>   mobile varchar(255) DEFAULT NULL,<br>   userMessage varchar(255) DEFAULT NULL,<br>   createDate datetime DEFAULT NULL,<br>   payDate datetime DEFAULT NULL,<br>   deliveryDate datetime DEFAULT NULL,<br>   confirmDate datetime DEFAULT NULL,<br>   uid int(11) DEFAULT NULL,<br>   status varchar(255) DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_order_user FOREIGN KEY (uid) REFERENCES user (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote><h4 id="9-订单项表"><a href="#9-订单项表" class="headerlink" title="9.订单项表"></a>9.订单项表</h4><p>这个表是外键最多的一个表<br>外键pid，指向产品表id字段<br>外键oid，指向订单表id字段<br>外键uid，指向用户表id字段<br>number字段表示购买数量</p><blockquote><p>CREATE TABLE orderitem (<br>   id int(11) NOT NULL AUTO_INCREMENT,<br>   pid int(11) DEFAULT NULL,<br>   oid int(11) DEFAULT NULL,<br>   uid int(11) DEFAULT NULL,<br>   number int(11) DEFAULT NULL,<br>   PRIMARY KEY (id),<br>   CONSTRAINT fk_orderitem_user FOREIGN KEY (uid) REFERENCES user (id),<br>   CONSTRAINT fk_orderitem_product FOREIGN KEY (pid) REFERENCES product (id),<br>   CONSTRAINT fk_orderitem_order FOREIGN KEY (oid) REFERENCES order_ (id)<br> ) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Doc</title>
      <link href="/2021/11/17/52269.html/"/>
      <url>/2021/11/17/52269.html/</url>
      
        <content type="html"><![CDATA[<h1 id="notes"><a href="#notes" class="headerlink" title="notes"></a>notes</h1><span id="more"></span><h1 id="1-张志虎-测向交叉定位体制下平台航迹最优规划算法"><a href="#1-张志虎-测向交叉定位体制下平台航迹最优规划算法" class="headerlink" title="1.张志虎 测向交叉定位体制下平台航迹最优规划算法"></a>1.张志虎 测向交叉定位体制下平台航迹最优规划算法</h1><h3 id="可观测性-最优航路算法-精度几何散布-最优航迹规划"><a href="#可观测性-最优航路算法-精度几何散布-最优航迹规划" class="headerlink" title="可观测性; 最优航路算法; 精度几何散布; 最优航迹规划"></a>可观测性; 最优航路算法; 精度几何散布; 最优航迹规划</h3><p>单站被动雷达由于可观测性较弱，对其进行航迹优化可以提高系统可观测性。给出无限制条件下的最优航<br>路算法，以最小化克劳美劳下界的迹即精度几何散布作为航路优化的性能指标，针对实际环境，又研究只采取 180°转<br>弯条件下的时长已知和未知两种环境下的最优航迹规划算法，给出了最优的航路规划，同时给出不同情景下的跟误差。</p><h1 id="2-张君君-对固定辐射源的多站无源定位研究"><a href="#2-张君君-对固定辐射源的多站无源定位研究" class="headerlink" title="2.张君君 对固定辐射源的多站无源定位研究"></a>2.张君君 对固定辐射源的多站无源定位研究</h1><h3 id="无源定位-运动多站-精度分析-布站优化-布谷鸟搜索算法"><a href="#无源定位-运动多站-精度分析-布站优化-布谷鸟搜索算法" class="headerlink" title="无源定位 运动多站 精度分析 布站优化 布谷鸟搜索算法"></a>无源定位 运动多站 精度分析 布站优化 布谷鸟搜索算法</h3><p>无源定位是一门相对独立的定位技术，既可以作为一种辐射源位置获取的重要手<br>段，也可以用作许多有源探测定位系统的补充。无源定位具有不同于雷达的多种优势，<br>因此受到世界各国的青睐。<br>多站无源定位相比单站无源定位具有容错率高，可利用的<br>数据多等特点，但是对各定位站的协同工作能力具有较高的要求。目前对多站无源定<br>位的研究主要集中在协同信号处理、定位算法、定位精度分析、布站优化等方面。而<br>这些都是围绕如何提高无源定位系统的性能来展开的。<br>本文首先介绍了几种常见的多站无源定位体制，分别对测向交叉法、无源时差法、<br>无源频差法以及多站联合定位法的基本定位原理做了研究。<br>然后以多站无源定位体制为基础，研究了运动多站对固定目标辐射源的定位算法<br>和定位精度。详细推导了运动多站无源频差定位和空间四站时差定位的定位方程以及<br>定位精度公式，并进行实验仿真做出了相应的结果对比，分析了各测量参数对定位精<br>度的影响。在进行运动双站时差/频差联合定位的相关研究时，除了对定位精度进行<br>分析外，针对定位方程中存在非线性方程求解复杂的问题，在对差分进化算法和牛顿<br>迭代法研究后，提出了基于差分进化算法和牛顿迭代法的目标位置求解模型，实现了<br>对目标位置的精确估计。实验表明该方法具有良好的性能以及不需要提供迭代初始点<br>等优点。<br>最后针对无源定位在应用中常见的布站优化问题，以空间四站时差定位体制为应<br>用背景，先是研究并仿真了几种常见布站构型的定位精度和适用场景，然后基于最优<br>化理论，提出了基于布谷鸟搜索算法的无源定位布站优化方法。通过与使用差分进化<br>算法的仿真结果进行对比，验证了该算法切实可行，而且还具有更好的收敛速度。</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote><p>第一章 绪论</p><blockquote><p>研究背景及意义<br>多站无源定位技术的研究现状<br>论文主要研究内容  </p></blockquote></blockquote><blockquote><p>第二章 多站无源定位体制</p><blockquote><p>1 引言<br>2 测向交叉法    </p><blockquote><p>2.1 双站测向交叉定位<br>2.2 基于 SWLS 的测向交叉定位  </p></blockquote></blockquote></blockquote><blockquote><blockquote><p>3 无源时差定位法<br>4 无源频差定位法<br>5 多站联合定位法</p><blockquote><p>5.1 测向/时差联合定位<br>5.2时差/频差联合定位  </p></blockquote></blockquote></blockquote><blockquote><blockquote><p>6 小结</p></blockquote></blockquote><blockquote><p>第三章 运动多站无源定位算法及精度分析  </p><blockquote><p>1 引言<br>2 运动多站对固定目标的无源频差定位    </p><blockquote><p>2.1 基本原理及目标位置求解<br>2.2 多普勒频差曲线精度推导<br>2.3 多普勒频差曲线分布仿真分析</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>3 空间四站时差定位原理<br>4 运动双站时差/频差联合定位<br>5 小结</p></blockquote></blockquote><blockquote><p>第四章 多站无源定位布站优化</p><blockquote><p>1 引言<br>2 布站方式对定位精度的影响<br>3 多站无源定位布站的最优化问题  </p><blockquote><p>3.1 最优化问题<br>3.2 多站无源定位布站的最优化问题描述</p></blockquote></blockquote><blockquote><p>4 基于差分进化算法的布站优化<br>5 基于布谷鸟搜索算法的布站优化</p><blockquote><p>5.1 基于布谷鸟搜索算法的布站优化原理<br>5.2 仿真分析  </p></blockquote></blockquote></blockquote><blockquote><blockquote><p>6 小结  </p></blockquote><p>第五章 总结与展望</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>“spring整合redis”</title>
      <link href="/2021/11/16/47151.html/"/>
      <url>/2021/11/16/47151.html/</url>
      
        <content type="html"><![CDATA[<h1 id="spring整合redis"><a href="#spring整合redis" class="headerlink" title="spring整合redis"></a>spring整合redis</h1><hr><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.搭建SpringBoot工程</p><p>2.引入redis起步依赖</p><p>3.配置redis相关属性</p><p>4.注入RedisTemplate模板</p><p>5.编写测试方法，测试</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2021/11/15/63785.html/"/>
      <url>/2021/11/15/63785.html/</url>
      
        <content type="html"><![CDATA[<h1 id="我的博客"><a href="#我的博客" class="headerlink" title="我的博客"></a>我的博客</h1><span id="more"></span><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用标题时需要使用#</p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>这是第一个段落内容</p><p>这是第二个段落内容</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><blockquote><p>这是一段引用段落将会被高亮显示</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>[百度] (<a href="https://www.baidu.com/?tn=44004473_27_oem_dg">https://www.baidu.com/?tn=44004473_27_oem_dg</a>)</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>![风景]（<a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg38.51tietu.net%2Fpic%2F2017-010520%2F20170105204459da41352i05a51903.jpg&amp;refer=http%3A%2F%2Fimg38.51tietu.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639553891&amp;t=0db40b6436229ffd99cd448638031620%EF%BC%89">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg38.51tietu.net%2Fpic%2F2017-010520%2F20170105204459da41352i05a51903.jpg&amp;refer=http%3A%2F%2Fimg38.51tietu.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1639553891&amp;t=0db40b6436229ffd99cd448638031620）</a></p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>无序列表项</li><li>无序列表项</li><li>无序列表项<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2></li></ul><ol><li>有序列表项1</li><li>有序列表项2</li><li>有序列表项3<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2></li></ol><hr><hr><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/15/16107.html/"/>
      <url>/2021/11/15/16107.html/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash">$ hexo new <span class="hljs-string"><code class="language-hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
